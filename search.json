[{"title":"API--MaxPoling1D","url":"/2022/01/26/API%E2%80%94%E2%80%94MaxPoling1D%E8%AF%A6%E8%A7%A3/","content":"官方文档：[https://www.tensorflow.org/api_docs/python/tf/keras/layers/MaxPool1D]\nAPI–MaxPoling1DAPI说明该函数会创建一层池化层，通过在大小为pool_size的空间窗口上取最大值，对输入进行处理。窗口每次的移动步数为strides。\n使用“valid”padding选项时，结果输出的形状为：output_shape=（input_shape-pool_size+1）/strips使用“SAME”填充选项时得到的输出形状是：output_shape = input_shape / strides\n参数说明tf.keras.layers.MaxPool1D(    pool_size=2, strides=None, padding=&#x27;valid&#x27;,    data_format=&#x27;channels_last&#x27;, **kwargs)\npool_size  :空间窗口大小strides    :窗口移动步长padding    :窗口覆盖模式当使用“valid”padding时：   不会对矩阵外部填充\nx = tf.constant([1., 2., 3., 4., 5.])x = tf.reshape(x, [1, 5, 1])max_pool_1d = tf.keras.layers.MaxPooling1D(pool_size=2,   strides=1, padding=&#x27;valid&#x27;)max_pool_1d(x)\n当使用“SAME”padding时：   对矩阵外部填充0\nx = tf.constant([1., 2., 3., 4., 5.])x = tf.reshape(x, [1, 5, 1])max_pool_1d = tf.keras.layers.MaxPooling1D(pool_size=2,   strides=1, padding=&#x27;same&#x27;)max_pool_1d(x)\ndata_format  :数据形式Input shape:\nIf data_format=&#x27;channels_last&#x27;: 3D tensor with shape (batch_size, steps, features).If data_format=&#x27;channels_first&#x27;: 3D tensor with shape (batch_size, features, steps).\n\nOutput shape:\nIf data_format=&#x27;channels_last&#x27;: 3D tensor with shape (batch_size, downsampled_steps, features).If data_format=&#x27;channels_first&#x27;: 3D tensor with shape (batch_size, features, downsampled_steps).","categories":["机器学习","卷积神经网络"],"tags":["深度学习","卷积神经网络","layers","池化层- 计算机","机器学习"]},{"title":"Anaconda使用","url":"/2022/05/06/Anaconda%E4%BD%BF%E7%94%A8/","content":"介绍Conda是Anaconda中的一个开源的包和环境管理工具，可以在终端窗口通过命令行使用，也可以在Anaconda Navigator中通过图形化界面使用,对编程创建独立的环境和包管理，最初是为Python语言开发，现在已不限制语言，支持Python, R, Ruby, Lua, Scala, Java, JavaScript,C/ C++, FORTRAN等。\n安装使用使用conda管理环境#创建环境conda create -n yourname python=3.6#查看环境conda env list#进入环境conda activate yourname#产看该环境中已安装的第三方库conda list#关闭虚拟环境conda deactivate\n\n管理conda#查看版本conda --version#更新至最新版本conda update conda\n\n实用配置配置pycharm中","tags":["Anconda"]},{"title":"Flutter-界面报错-No-MediaQuery-widget-ancestor-found","url":"/2022/03/14/Flutter-%E7%95%8C%E9%9D%A2%E6%8A%A5%E9%94%99-No-MediaQuery-widget-ancestor-found/","content":"Flutter 界面报错 ( No MediaQuery widget ancestor found. | Scaffold widgets require a MediaQuery )报错如下（红屏）\n错误代码：\n// @dart=2.9import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_app/page/welcome.dart&#x27;;void main() &#123;   runApp(Welcome());&#125;\n\n分析修改忘了未跳转后页面添加一层 MaterialApp解决如下import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_app/page/welcome.dart&#x27;;void main() =&gt; runApp(MaterialApp(      title: &#x27;导航演示1&#x27;,      home: Welcome(),    ));\n","categories":["计算机","Flutter","错误记录"],"tags":["Flutter","错误记录"]},{"title":"ElementUi整合入vue","url":"/2022/07/26/ElementUi%E6%95%B4%E5%90%88%E5%85%A5vue/","content":"","tags":["ElementUi","Vue"]},{"title":"Aop概括","url":"/2022/07/01/Aop%E6%A6%82%E6%8B%AC/","content":"AOP概述及出现背景面向切面编程\naop概述AOP全称为Aspect Oriented Programming的缩写，意为：面向切面编程。将程序中公用代码进行抽离，通过动态代理实现程序功能的统一维护的一种技术。使代码耦合性降低，提高了开发的效率。\naop可以完成的功能日志记录，性能统计，安全控制，事务处理，异常处理等等。\naop与oop区别OOP：（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。java实体类就是面向对象编程的最准确的体现。AOP：则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。\nspring AOP底层实现介绍spring的AOP底层是由 JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术)实现。\nJDK动态代理：Jdk动态代理只针对于接口操作。\nCGLIB：可以针对没有接口的java类和有接口的java类。\n","tags":["aop","spring","蜗牛学院笔记"]},{"title":"JDBC详解","url":"/2022/05/11/JDBC%E8%AF%A6%E8%A7%A3/","content":"JDBC介绍介绍什么是JDBC\n    Java数据库连接（Java DataBase Connectivity）\n    \nJDBC作用\n    能够帮助我们实现用java代码操作数据库\n    \nJDBC的本质\n    JDBC是JavaEE技术之一\n    \n    JavaEE是13种技术的统称\n    \n    JDBC就是SUN公司提供的一套规范，一套接口\n\n案例0.导入jar包1.注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);2.获取数据库连接对象Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db6&quot;, &quot;root&quot;, &quot;123&quot;);3.获取执行sql语句的对象Statement stat = conn.createStatement();4.执行sql语句int i = stat.executeUpdate(&quot;insert into user values(1,&#x27;tom&#x27;, 18)&quot;);System.out.println(i);5.释放资源stat.close();conn.close();\n步骤详解0.导入jar包\t为什么要jar包？\t\t因为我们用java语句操作数据库，具体的实现类和方法都在jar里呢，JDBC只是提供一些接口\t\t1.注册驱动\tClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\t解释：将com.mysql.jdbc.Driver.class文件加载进内存方法区中，形成字节码文件对象\t\t为什么要注册驱动？\t\t告诉程序要操作的数据库是哪一个数据库\t\t注册驱动的原始代码：DriverManager.registerDrvier(new Driver());\t按照原始写法有两点不好的地方：\t\t1.太过依赖于jar包，如果jar不存在，编译的时候就报错了\t\t2.会造成2次注册\t\t2.获取数据库连接对象\tConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db6&quot;, &quot;root&quot;, &quot;123&quot;);\t\t三个参数：\t\t\t1.第一个参数：jdbc:mysql://localhost:3306/db6\t\t\t\t\t\t\t协议         IP地址  端口 数据库名\t\t\t2.第二个参数：root 用户名\t\t\t3.第三个参数：123  密码\t\t\t\t\t有几个重载的方法：\t\t\tpublic static Connection getConnection(String url,String user, String password)\t\t\tpublic static Connection getConnection(String url)\t\t\tpublic static Connection getConnection(String url,java.util.Properties info)\t\t\t\t\t注意：如果ip是localhost，端口是3306的话，第一个参数可以简写为：jdbc:mysql:///db63.获取执行sql语句的对象\tStatement stat = conn.createStatement();\t\t后面要修改写法，因为上面的写法是有弊端的，有什么弊端呢？不知道\t\tPreparedStatement ps = conn.prepareStatement(&quot;sql语句&quot;);\t使用PreparedStatement能够解决sql注入问题，因为它采用的是预处理模式，里面使用的是占位符？\t\t\t\t4.执行sql语句\tint i = stat.executeUpdate(&quot;insert into user values(1,&#x27;tom&#x27;, 18)&quot;);\tSystem.out.println(i);\t\tint executeUpdate()：增删改\t\t返回值：实际影响的行数\t\t\tResultSet executeQuery()：查询\t\t返回值：结果集对象\t\t\tResultSet：\t\t\t\tboolean next()：判断结果集里有没有数据\t\t\t\tint getInt(int i)：根据第几个字段获取对应的字段的数据\t\t\t\tint getInt(String name)：根据指定的字段名获取对应的字段数据\t\t\t\tString getString(int i)：根据第几个字段获取对应的字段的数据\t\t\t\tString getString(String name)：根据指定的字段名获取对应的字段数据\t\t\tboolean execute()：增删改查，底层使用的，我们自己用的很少\t\t返回值：\t\t\t增删改 返回false\t\t\t查询   返回true5.释放资源\trs.close();\tstat.close();\tconn.close();\n\nJDBC工具类public class JdbcUtils &#123;\tprivate static String driver;\tprivate static String url;\tprivate static String username;\tprivate static String password;\t\tstatic &#123;\t\ttry &#123;\t\t\tProperties p = new Properties();\t\t\tp.load(JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;));\t\t\t\t\t\tdriver = p.getProperty(&quot;driver&quot;);\t\t\turl = p.getProperty(&quot;url&quot;);\t\t\tusername = p.getProperty(&quot;username&quot;);\t\t\tpassword = p.getProperty(&quot;password&quot;);\t\t\t\t\t\t//注册驱动\t\t\tClass.forName(driver);\t\t&#125; catch(Exception e) &#123;\t\t\tSystem.out.println(&quot;初始化失败&quot;);\t\t&#125;\t&#125;\t\tpublic static Connection getConnection() throws SQLException &#123;\t\t//获取数据连接对象\t\tConnection conn = DriverManager.getConnection(url, username, password);\t\treturn conn;\t&#125;\t\tpublic static void close(Connection conn, PreparedStatement ps) &#123;\t\tclose(conn, ps, null);\t&#125;\t\tpublic static void close(Connection conn, PreparedStatement ps, ResultSet rs) &#123;\t\tif(rs != null) &#123;\t\t\ttry &#123;\t\t\t\trs.close();\t\t\t&#125; catch (SQLException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t\tif(ps != null) &#123;\t\t\ttry &#123;\t\t\t\tps.close();\t\t\t&#125; catch (SQLException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t\tif(conn != null) &#123;\t\t\ttry &#123;\t\t\t\tconn.close();\t\t\t&#125; catch (SQLException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;&#125;\nJDBC事务处理案例：转账\t//获取数据库连接对象\tConnection conn = JdbcUtils.getConnection();\t\t//开启事务\tconn.setAutoCommit(false);\t\t//获取执行sql语句对象\tPreparedStatement ps = conn.prepareStatement(&quot;update user set money = money + ? where name = ?&quot;);\t\t//tom减去100元钱\tps.setInt(1, -100);\tps.setString(2, &quot;tom&quot;);\tps.executeUpdate();\t\tSystem.out.println(1/0);\t\t//jerry加100元钱\tps.setInt(1, 100);\tps.setString(2, &quot;jerry&quot;);\tps.executeUpdate();\t\t//提交事务\tconn.commit();\t\t//释放资源\tJdbcUtils.close(conn, ps);\n","tags":["javaEE","数据库","JDBC"]},{"title":"JdncTemplate","url":"/2022/05/29/JdncTemplate/","content":"JdbcTemplate简介JdbcTemplate是Spring框架针对Jdbc的封装，它就是一个(Jdbc工具类)，简化了代码的书写，提供了更加方便的操作。JdbcTemplate也是一个基于ORM思想的工具类(小框架)。\nORM架构简介对象关系映射(Object Relational Mapping)在实际开发中，往往是数据库中的一张表会对应Java中一个类，类名和表名，字段名和属性名都是一样的。\nJdbcTemplate的基本使用使用步骤：1.导入相关的jar包    导入5个关联jar包\n2.创建JdbcTemplate对象    JdbcTemplate jt = new JdbcTemplate();\n3.将数据库连接池对象封装到JdbcTemplate对象中方案一：通过JdbcTemplate有参构造赋值        JdbcTemplate jt = new JdbcTemplate(数据库连接池对象);\n方案二：通过JdbcTemplate中的setXXX()方法赋值        JdbcTemplate jt = new JdbcTemplate();        jt.setDataSource(数据库连接池对象);\n4.执行sql语句\n添加：\tjt.update(&quot;insert into user values(null, ?, ?)&quot;, &quot;tom&quot;, &quot;123&quot;);\t\t\t修改：\tjt.update(&quot;update user set username = ?, password = ? where id = ?&quot;, &quot;jerry&quot;,&quot;root&quot;,&quot;1&quot;);\t\t\t删除：\tjt.update(&quot;delete from user where id = ?&quot;, 1);\t\t\t查询：\t查询多条记录？\t\tList&lt;User&gt; users = jt.query(&quot;select * from user&quot;, \t\tnew BeanPropertyRowMapper&lt;User&gt;(User.class));\t\t\t\t    查询一条记录？    \tUser user = jt.queryForObject(&quot;select * from user where id = ?&quot;,     \tnew BeanPropertyRowMapper&lt;User&gt;(User.class), 1);\t\t\t\t    查询一个数据？    \t查询id为1的username是什么？    \t\t\tString username = jt.queryForObject(&quot;select username from user where id = ?&quot;,     \t\t\tString.class, 1);    \t\t\tSystem.out.println(username);\t\t\t\t\t    \t查询表中有多少条记录？    \t\tint count = jt.queryForObject(&quot;select count(*) from user&quot;, int.class);    \t\tSystem.out.println(count); ","tags":["数据库","JDBC","JdbcTemplate"]},{"title":"Jenkins入门","url":"/2022/03/28/Jenkins%E5%85%A5%E9%97%A8/","content":"第一章  Jenkins是什么？Jenkins介绍是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。\n持续集成持续集成指的是，频繁地（一天多次）将代码集成到主干。将软件个人研发的部分向软件整体部分交付，频繁进行集成以便更快地发现其中的错误。\n持续交付持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。\n持续部署持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。\n官网官方文档\n第二章 快速安装Jenkins通常作为一个独立的应用程序在其自己的流程中运行， 内置Java servlet 容器/应用程序服务器（Jetty）。Jenkins也可以运行在不同的Java servlet容器(（如Apache Tomcat 或 GlassFish）)中作为servlet运行,但是设置本篇暂不讲起。\n安装平台(Docker)可以参考上篇Docker安装。\n在Docker中下载并运行Jenkins注意：安装最低配置不少于256M内存，不低于1G磁盘，JDK版本&gt;=8（openjdk也可以）。\n拉取镜像我们使用官网推荐的jenkinsci/blueocean该镜像包含当前的长期支持 (LTS) 的Jenkins版本 （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件。但是发现网速根本行不通，于是又给自己配了个docker加速器。\n可以看我另一个帖子docker加速器此外还有停更的jenkins停更了，和长期版本的jenkins/jenkins。\ndocker pull jenkinsci/blueocean\n\n运行容器使用以下docker run 命令将其作为Docker中的容器运行\ndocker run \\  -u root \\  --rm \\       #关闭时自动删除  -d \\         #后台运行  -p 8080:8080 \\   -p 50000:50000 \\   -v jenkins-data:/var/jenkins_home \\   -v /var/run/docker.sock:/var/run/docker.sock \\   jenkinsci/blueocean \n\n然后我们根据docker hub文档指示在容器里运行镜像\nrun -p 8080:8080 jenkinsci/blueocean\n\n打开本地端口浏览到 http://localhost:8080或安装时为Jenkins配置的任何端口），并等待 解锁 Jenkins 页面出现。\n1.从Jenkins控制台日志输出中，复制自动生成的字母数字密码（在两组星号之间）。2.然后创建第一个管理员用户如果不知道自己需要哪些插件 请选择安装建议的插件\n3.最后重启jenkins.大功告成\n注意:如果该页面在一分钟后不会自动刷新，请使用Web浏览器手动刷新页面。如果需要，请使用您刚刚创建的用户的凭据登录到Jenkins，并准备好开始使用Jenkins！\n","categories":["centos/linux","Jenkins"],"tags":["Jenkins","centos","docker"]},{"title":"My first blog","url":"/2022/01/01/My%20first%20blog/","content":"今天是2022年元旦节，我开心的发布了第一篇文章，希望给自己一个新的开始。新的一年，祝你心情好，身体好，一切顺心！","categories":["生活随笔"],"tags":["生活"]},{"title":"Kneighborsclassifier中参数说明","url":"/2022/03/21/Kneighborsclassifier%E4%B8%AD%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/","content":"官方文档：[https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html?highlight=kneighborsclassifier#sklearn.neighbors.KNeighborsClassifier]\nAPI–sklearn.neighbors.KNeighborsClassifie参数如下class sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, *, weights=&#x27;uniform&#x27;, algorithm=&#x27;auto&#x27;, leaf_size=30, p=2, metric=&#x27;minkowski&#x27;, metric_params=None, n_jobs=None)[source]\nn_neighborsint, default=5:临近参数所搜寻数量，默认为5。\nweights{‘uniform’, ‘distance’} or callable, default=’uniform’:‘uniform’ :默认每个neighborhood权重相等，一般默认为此设置。\n‘distance’:以距离为指标\n[callable] :由用户定义，可以接受数组的功能，返回一个包含相同形状的权重数组。\nalgorithm{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, default=’auto’：快速搜索算法，默认是auto\nball_tree ：使用ball_tree算法\nkd_tree   ：使用kd_tree算法\nbrute     ：使用brute-force搜索\nauto      ：根据传递给fit的值，自动尝试最合适的算法。\nleaf_sizeint, default=30：树的大小，传给BallTree或者KDTree算法，将影响构造和查询的速度以及存储的内存。最佳值取决于问题性质(一般默认是30，可以在其值不大的范围内调试看看效果。)\np: int, default=2对于Minkowski metric很重要的参数。\np=1:manhattan_distance (l1)p=2:euclidean_distance (l2)metric: str or callable, default=’minkowski’p：p=1是曼哈顿距离，p=2的欧氏距离。\nmetric_params:dict, default=None距离公式的其他关键参数，默认为None。\nn_jobs:int, default=None：n_jobsint, default=None并行处理。默认为1，临近点搜索。如果为-1，表示CPU的所有cores都并行工作。\n方法：fit(X, y)：拟合训练数据集\npredict(X)，predict_proba(X)：输出预测，输出预测为每个类的概率\n例子：&gt;&gt;&gt; X = [[0], [1], [2], [3]]&gt;&gt;&gt; y = [0, 0, 1, 1]&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier&gt;&gt;&gt; neigh = KNeighborsClassifier(n_neighbors=3)&gt;&gt;&gt; neigh.fit(X, y)KNeighborsClassifier(...)&gt;&gt;&gt; print(neigh.predict([[1.1]]))                #输出预测[0]&gt;&gt;&gt; print(neigh.predict_proba([[0.9]]))          #输出预测为每个类的概率[[0.666... 0.333...]]\nkneighbors([X, n_neighbors, return_distance])例子：&gt;&gt;&gt; samples = [[0., 0., 0.], [0., .5, 0.], [1., 1., .5]]&gt;&gt;&gt; from sklearn.neighbors import NearestNeighbors&gt;&gt;&gt; neigh = NearestNeighbors(n_neighbors=1)&gt;&gt;&gt; neigh.fit(samples)NearestNeighbors(n_neighbors=1)&gt;&gt;&gt; print(neigh.kneighbors([[1., 1., 1.]]))array([[0.5]]), array([[2]])\n\nkneighbors_graph([X, n_neighbors, mode])&gt;&gt;&gt; X = [[0], [3], [1]]&gt;&gt;&gt; from sklearn.neighbors import NearestNeighbors&gt;&gt;&gt; neigh = NearestNeighbors(n_neighbors=2)&gt;&gt;&gt; neigh.fit(X)NearestNeighbors(n_neighbors=2)&gt;&gt;&gt; A = neigh.kneighbors_graph(X)&gt;&gt;&gt; A.toarray()array([[1., 0., 1.],       [0., 1., 1.],       [1., 0., 1.]])","categories":["机器学习","KNN"],"tags":["机器学习","KNN","参数说明","sklearn"]},{"title":"NoSQL数据库","url":"/2022/09/25/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"1.NoSQL数据库简介1.1. 技术发展技术的分类\n1、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN\n2、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis\n3、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch\n1.1.1 Web1.0时代数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。\n\n1.1.2 Web2.0时代随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。\n\n1.1.3  解决CPU及内存压力\n1.1.4  解决IO压力\n1.2 NoSQL数据库1.2.1  NoSQL数据库概述NoSQL(NoSQL = *Not Only SQL* )，意即“不仅仅是SQL”，泛指****非关系型的数据库****。 \nNoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。\n\n不遵循SQL标准。\n\n不支持ACID。\n\n远超于SQL的性能。\n\n\n1.2.2 NoSQL适用场景\n对数据高并发的读写\n\n海量数据的读写\n\n对数据高可扩展性的\n\n\n1.2.3 NoSQL不适用场景\n需要事务支持\n\n基于sql的结构化查询存储，处理复杂的关系,需要即席查询。\n\n用不着sql的和用了sql也不行的情况，请考虑用NoSql\n\n\n1.2.4 数据库\nMemcahe\n\n很早出现的NoSql数据库\n\n数据都在内存中，一般不持久化\n\n支持简单的key-value模式，支持类型单一\n\n一般是作为缓存数据库辅助持久化的数据库\n\n\n\nRedis\n\n几乎覆盖了Memcached的绝大部分功能\n\n数据都在内存中，支持持久化，主要用作备份恢复\n\n除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。\n\n一般是作为缓存数据库辅助持久化的数据库\n\n\n\nMongoDB\n\n高性能、开源、模式自由(schema  free)的*文档型数据库*\n数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘\n虽然是key-value模式，但是对value（尤其是****json****）提供了丰富的查询功能\n支持二进制数据及大型对象\n可以根据数据的特点*替代RDBMS* ，成为独立的数据库。或者配合RDBMS，存储特定的数据。\n\n\n\n","tags":["nosql","尚硅谷redis6笔记"]},{"title":"ORM架构","url":"/2022/05/18/ORM%E6%9E%B6%E6%9E%84/","content":"ORM架构概念ORM，即Object Relational Mapping，它是对象关系模型的简称。它的作用是在关系型数据库和对象之间作一个映射。使程序能够通过操纵描述对象方式来操纵数据库。\nORM 把数据库映射成对象。\n数据库的表（table） --&gt; 类（class）记录（record，行数据）--&gt; 对象（object）字段（field）--&gt; 对象的属性（attribute）\n优缺点优点\n数据模型都在一个地方定义，更容易更新和维护，也利于重用代码。\nORM 有现成的工具，很多功能都可以自动完成，比如数据消毒、预处理、事务等等。\n它迫使你使用 MVC 架构，ORM 就是天然的 Model，最终使代码更清晰。\n基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。\n你不必编写性能不佳的 SQL。\n\n缺点\nORM 库不是轻量级工具，需要花很多精力学习和设置。\n对于复杂的查询，ORM 要么是无法表达，要么是性能不如原生的 SQL。\nORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL。\n\n","tags":["JDBC","ORM","JPA"]},{"title":"Spring事务","url":"/2022/07/01/Spring%E4%BA%8B%E5%8A%A1/","content":"事务属性事务的特性\n原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。\n一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。\n隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。\n持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。\n\nSpring事务的配置方式Spring支持编程式事务管理以及声明式事务管理两种方式。\n1. 编程式事务管理编程式事务管理是侵入性事务管理，使用TransactionTemplate或者直接使用PlatformTransactionManager，对于编程式事务管理，Spring推荐使用TransactionTemplate。\n2. 声明式事务管理声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的编程方式。唯一不足的地方就是声明式事务管理的粒度是方法级别，而编程式事务管理是可以到代码块的，但是可以通过提取方法的方式完成声明式事务管理的配置。\n事务的传播机制事务的传播性一般用在事务嵌套的场景，比如一个事务方法里面调用了另外一个事务方法，那么两个方法是各自作为独立的方法提交还是内层的事务合并到外层的事务一起提交，这就是需要事务传播机制的配置来确定怎么样执行。常用的事务传播机制如下：\n\nPROPAGATION_REQUIREDSpring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行\nPROPAGATION_REQUES_NEW该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可\nPROPAGATION_SUPPORT如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务\nPROPAGATION_NOT_SUPPORT该传播机制不支持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码\nPROPAGATION_NEVER该传播机制不支持外层事务，即如果外层有事务就抛出异常\nPROPAGATION_MANDATORY与NEVER相反，如果外层没有事务，则抛出异常\nPROPAGATION_NESTED该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的，如果子事务没有把异常吃掉，基本还是会引起全部回滚的。\n\n\n传播规则回答了这样一个问题：一个新的事务应该被启动还是被挂起，或者是一个方法是否应该在事务性上下文中运行。\n\n事务的隔离级别事务的隔离级别定义一个事务可能受其他并发务活动活动影响的程度，可以把事务的隔离级别想象为这个事务对于事务处理数据的自私程度。\n在一个典型的应用程序中，多个事务同时运行，经常会为了完成他们的工作而操作同一个数据。并发虽然是必需的，但是会导致以下问题：\n\n脏读（Dirty read）脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。\n不可重复读（Nonrepeatable read）不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。\n\n\n不可重复读重点在修改。\n\n3. 幻读（Phantom reads）\n\n幻读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。\n\n幻读重点在新增或删除。\n\n在理想状态下，事务之间将完全隔离，从而可以防止这些问题发生。然而，完全隔离会影响性能，因为隔离经常涉及到锁定在数据库中的记录（甚至有时是锁表）。完全隔离要求事务相互等待来完成工作，会阻碍并发。因此，可以根据业务场景选择不同的隔离级别。\n\n\n\n隔离级别\n含义\n\n\n\nISOLATION_DEFAULT\n使用后端数据库默认的隔离级别\n\n\nISOLATION_READ_UNCOMMITTED\n允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。\n\n\nISOLATION_READ_COMMITTED\n（Oracle 默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。\n\n\nISOLATION_REPEATABLE_READ\n（MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。\n\n\nISOLATION_SERIALIZABLE\n完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。\n\n\n只读如果一个事务只对数据库执行读操作，那么该数据库就可能利用那个事务的只读特性，采取某些优化措施。通过把一个事务声明为只读，可以给后端数据库一个机会来应用那些它认为合适的优化措施。由于只读的优化措施是在一个事务启动时由后端数据库实施的， 因此，只有对于那些具有可能启动一个新事务的传播行为（PROPAGATION_REQUIRES_NEW、PROPAGATION_REQUIRED、 ROPAGATION_NESTED）的方法来说，将事务声明为只读才有意义。\n事务超时为了使一个应用程序很好地执行，它的事务不能运行太长时间。因此，声明式事务的下一个特性就是它的超时。\n假设事务的运行时间变得格外的长，由于事务可能涉及对数据库的锁定，所以长时间运行的事务会不必要地占用数据库资源。这时就可以声明一个事务在特定秒数后自动回滚，不必等它自己结束。\n由于超时时钟在一个事务启动的时候开始的，因此，只有对于那些具有可能启动一个新事务的传播行为（PROPAGATION_REQUIRES_NEW、PROPAGATION_REQUIRED、ROPAGATION_NESTED）的方法来说，声明事务超时才有意义。\n回滚规则在默认设置下，事务只在出现运行时异常（runtime exception）时回滚，而在出现受检查异常（checked exception）时不回滚（这一行为和EJB中的回滚行为是一致的）。不过，可以声明在出现特定受检查异常时像运行时异常一样回滚。同样，也可以声明一个事务在出现特定的异常时不回滚，即使特定的异常是运行时异常。\n声明式事务配置Spring的配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--        数据源    --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;woniu&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--       SqlSessionFactory    --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        扫描dao    --&gt;    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.woniu.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置事务管理器        DataSourceTransactionManager提供了事务管理的代码    --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置事务的信息        配置传播机制、隔离级别、是否只读、回滚条件    --&gt;    &lt;tx:advice id=&quot;advice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;save&quot; propagation=&quot;REQUIRED&quot; isolation=&quot;DEFAULT&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.RuntimeException&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--        配置AOP    --&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* com.woniu.service..*.*(..))&quot;/&gt;        &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;pc&quot;&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;&lt;/beans&gt;\n\n\n\n注解的方式配置声明式事务&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--        数据源    --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;woniu&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--       SqlSessionFactory    --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        扫描dao    --&gt;    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.woniu.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置事务管理器        DataSourceTransactionManager提供了事务管理的代码    --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt;\n\n@Service@Transactional  //将DataSourceTransactionManager切入到当前类的所有的方法public class DeptServiceImpl implements DeptService &#123;    @Autowired    private DeptDao deptDao;    @Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.DEFAULT,readOnly = false,rollbackFor = java.lang.RuntimeException.class )    @Override    public void save(Dept dept) &#123;        deptDao.insert(dept);        throw new RuntimeException(&quot;异常出现，事务回滚！&quot;);    &#125;&#125;\n\n","tags":["spring","蜗牛学院笔记","事务"]},{"title":"Thymeleaf模板引擎","url":"/2022/07/11/Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","content":"模板引擎概述模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。\n模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这就大大提升了开发效率，良好的设计也使得代码重用变得更加容易。\n市面上主流的 Java 模板引擎有：JSP、Velocity、Freemarker、Thymeleaf\nThymeleaf是一个现代服务器端Java模板引擎，适用于Web和独立环境，能够处理HTML，XML，JavaScript，CSS甚至纯文本。\nThymeleaf的主要目标是提供一种优雅且高度可维护的模板创建方式。为实现这一目标，它以自然模板的概念为基础，将其逻辑注入模板文件，其方式不会影响模板被用作设计原型。这改善了设计沟通，缩小了设计和开发团队之间的差距。\n\n\n模板引擎的基本使用导入命名空间和pom文件里的坐标\n\n\n这样的话，在idea中写代码的时候，就会有thymeleaf的代码提示。引入thymeleaf的坐标\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n语法规则th：任意html属性；来替换原生属性的值例如：th:text；改变当前元素里面的文本内容\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF‐8&quot;&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;成功！&lt;/h1&gt;&lt;!‐‐th:text 将div里面的文本内容设置为 ‐‐&gt;&lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":["蜗牛学院笔记","Thymeleaf"]},{"title":"bert中文模型-cnn","url":"/2022/06/26/bert%E4%B8%AD%E6%96%87%E6%A8%A1%E5%9E%8B-cnn/","content":"任务介绍本次课程设计任务选择的是中文医疗信息处理挑战榜CBLUE(Chinese Biomedical Language UnderstandingEvaluation)中的医疗搜索查询词-页面标题相关性（KUAKE-QTR）。在医疗搜索中，评估搜索词(Query)表述主题和落地页标题(Title)表述主题的匹配程度，将Query和Title的相关度共分为4档（0-3），0分为最差，3分为匹配最好。Query的主题是指query的专注点,用户在输入query是希望找到与query主题相关的网页。该任务需要判断Query主题和Title主题是否一致及达到多大程度上的一致\n\n数据集介绍Query和Title的相关度共分为3档（0-2），0分为相关性最差，2分表示相关性最好。2分：表示A与B等价，表述完全一致。1分： B为A的语义子集，B指代范围小于A。0分：B为A的语义父集，B指代范围大于A； 或者A与B语义毫无关联。\n评测数据：本评测开放训练集数据24174条，验证集数据2913条，测试集数据5465条。数据集名称为：KUAKE-QTR(KUAKE - Query Title Relevance dataset)。数据集下载文件为：KUAKE-QTR.zip, 包括：\nKUAKE-QTR_train.json: 训练集KUAKE-QTR_dev.json: 验证集KUAKE-QTR_test.json: 测试集，选手提交的时候需要为每条记录增加“label”字段example_gold.json: 标准答案示例example_pred.json: 提交结果示例README.txt: 说明文件\n知识点介绍HamingfaceHugging Face起初是一家总部位于纽约的聊天机器人初创服务商，经过不断发展成为了专注于NLP技术的大型开源社区。尤其是在github上开源的自然语言处理，预训练模型库 Transformers，已被下载超过百万次。我们此次使用的bert预训练模型也在其中。\nbert中文模型bert是谷歌公司发布的预训练模型，在机器阅读理解顶级水平测试SQuAD1.1中表现出惊人的成绩，后来又延伸出许多变种，其中bert中文模型就是其中一种。\n模型构建预训练模型基于transformers库使用，通过Models - Hugging Face 下载bert-base-chinese的预训练模型，将模型下载至本地。通过bert-base-chinese自带的分词工具包训练词向量。后来使用pytorch深度学习框架构建神经网络，经过尝试发现两层卷积配合三层全连接层效果最好\nhuggingface中下载下这三个\n定义数据集因为要使用torch的数据加载器，所以需要定义数据集，及把数据定义在类中。\n#定义数据集class Dataset(torch.utils.data.Dataset):    def __init__(self):        path=&#x27;KUAKE-QTR/KUAKE-QTR_train.json&#x27;        f=open(path,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)        dataset=json.load(f)                self.dataset = dataset            def __len__(self):        return len(self.dataset)    def __getitem__(self, i):        query = self.dataset[i][&#x27;query&#x27;]        title = self.dataset[i][&#x27;title&#x27;]        label = int(self.dataset[i][&#x27;label&#x27;])        return query, title, labeldataset = Dataset()sentence1, sentence2, label = dataset[0]     len(dataset), sentence1, sentence2, label\n加载分词工具#加载分词工具token = BertTokenizer.from_pretrained(&#x27;bert-base-chinese/vocab.txt&#x27;)\n模型试算试算查看维度\n#加载预训练模型pretrained = BertModel.from_pretrained(&#x27;bert-base-chinese&#x27;)# print(pretrained)#不训练,不需要计算梯度for param in pretrained.parameters():    param.requires_grad_(False)#模型试算last_hidden_state, pooler_output, all_hidden_states = pretrained(           input_ids=input_ids,           attention_mask=attention_mask,           token_type_ids=token_type_ids,           output_hidden_states= True)\n定义下游任务模型下游定义两个卷积层，三个线性层\nclass Model(torch.nn.Module):    def __init__(self):        super().__init__()        layer1 = nn.Sequential()       #input 16,  768,40    batchsize:16,词向量：768  每句话字数：40        layer1.add_module(&#x27;conv1&#x27;,nn.Conv1d(768,128,4,2,padding=1))#16,128,20        layer1.add_module(&#x27;relu1&#x27;,nn.ReLU())        layer1.add_module(&#x27;pool1&#x27;,nn.MaxPool1d(2,1)) #16,128,19        self.layer1 = layer1                layer2 = nn.Sequential()       #input 16,128,19        layer2.add_module(&#x27;conv2&#x27;,nn.Conv1d(128,32,4,1,padding=0))#16,32,16        layer2.add_module(&#x27;relu2&#x27;,nn.ReLU())        layer2.add_module(&#x27;pool2&#x27;,nn.MaxPool1d(2,1)) #16,32,15        self.layer2=layer2                layer4=nn.Sequential()        layer4.add_module(&#x27;fc1&#x27;,nn.Linear(480,160))   #7680  1920        layer4.add_module(&#x27;fc_relu1&#x27;,nn.ReLU())        layer4.add_module(&#x27;fc2&#x27;,nn.Linear(160,40))        layer4.add_module(&#x27;fc_relu2&#x27;,nn.ReLU())        layer4.add_module(&#x27;fc3&#x27;,nn.Linear(40,4))        self.layer4 = layer4    def forward(self, input_ids, attention_mask, token_type_ids):        with torch.no_grad():            last_hidden_state, pooler_output, all_hidden_states = pretrained(input_ids=input_ids,                             attention_mask=attention_mask,                             token_type_ids=token_type_ids,                             output_hidden_states= True)        conv1 = self.layer1(last_hidden_state.permute(0,2,1))        conv2 = self.layer2(conv1)        fc_input = conv2.view(conv2.size()[0],-1)       #转为一维向量形式        fc_out = self.layer4(fc_input)        fc_out=fc_out.softmax(dim=1)      #归一化函数        return fc_outmodel = Model()\n完整代码训练代码import torchimport torch.nn as nnimport jsonfrom transformers import BertTokenizer      #字典和分词工具import numpy as np#定义数据集class Dataset(torch.utils.data.Dataset):    def __init__(self):        path=&#x27;KUAKE-QTR/KUAKE-QTR_train.json&#x27;        f=open(path,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)        dataset=json.load(f)                self.dataset = dataset            def __len__(self):        return len(self.dataset)    def __getitem__(self, i):        query = self.dataset[i][&#x27;query&#x27;]        title = self.dataset[i][&#x27;title&#x27;]        label = int(self.dataset[i][&#x27;label&#x27;])        return query, title, labeldataset = Dataset()sentence1, sentence2, label = dataset[0]   #加载分词工具token = BertTokenizer.from_pretrained(&#x27;bert-base-chinese/vocab.txt&#x27;)def collate_fn(data):    sents=[i[:2] for i in data]                #两句话    labels=[i[2] for i in data]                #编码        #编码    data=token.batch_encode_plus(batch_text_or_text_pairs=sents,                            truncation=True,                            padding=&#x27;max_length&#x27;,                            max_length=40,                            return_tensors=&#x27;pt&#x27;,                            return_length=True,                            add_special_tokens=True)        #input_ids:编码之后的数字    #attention_mask:是补零的位置是0,其他位置是1    #token_type_ids:第一个句子和特殊符号的位置是0,第二个句子的位置是1        input_ids=data[&#x27;input_ids&#x27;]    attention_mask=data[&#x27;attention_mask&#x27;]    token_type_ids=data[&#x27;token_type_ids&#x27;]    labels=torch.LongTensor(labels)        return input_ids, attention_mask, token_type_ids, labels    #数据加载器loader=torch.utils.data.DataLoader(dataset=dataset,                                  batch_size=16,                                  collate_fn=collate_fn,                                  shuffle=True,                                  drop_last=True)for i, (input_ids,attention_mask,token_type_ids,        labels) in enumerate(loader):    break    from transformers import BertModel#加载预训练模型pretrained = BertModel.from_pretrained(&#x27;bert-base-chinese&#x27;)# print(pretrained)#不训练,不需要计算梯度for param in pretrained.parameters():    param.requires_grad_(False)#模型试算last_hidden_state, pooler_output, all_hidden_states = pretrained(           input_ids=input_ids,           attention_mask=attention_mask,           token_type_ids=token_type_ids,           output_hidden_states= True)print(last_hidden_state.shape)            #batch_size:16   最大句子长度：40  词向量：768out=last_hidden_state[:, 0].reshape(16,768,1)    #调换维度进入tensor中print(out.shape)                #tensor#定义下游任务模型class Model(torch.nn.Module):    def __init__(self):        super().__init__()        layer1 = nn.Sequential()       #input 16,  768,40        layer1.add_module(&#x27;conv1&#x27;,nn.Conv1d(768,128,4,2,padding=1))#16,128,20        layer1.add_module(&#x27;relu1&#x27;,nn.ReLU())        layer1.add_module(&#x27;pool1&#x27;,nn.MaxPool1d(2,1)) #16,128,19        self.layer1 = layer1                layer2 = nn.Sequential()       #input 16,128,19        layer2.add_module(&#x27;conv2&#x27;,nn.Conv1d(128,32,4,1,padding=0))#16,32,16        layer2.add_module(&#x27;relu2&#x27;,nn.ReLU())        layer2.add_module(&#x27;pool2&#x27;,nn.MaxPool1d(2,1)) #16,32,15        self.layer2=layer2                layer4=nn.Sequential()        layer4.add_module(&#x27;fc1&#x27;,nn.Linear(480,160))   #7680  1920        layer4.add_module(&#x27;fc_relu1&#x27;,nn.ReLU())        layer4.add_module(&#x27;fc2&#x27;,nn.Linear(160,40))        layer4.add_module(&#x27;fc_relu2&#x27;,nn.ReLU())        layer4.add_module(&#x27;fc3&#x27;,nn.Linear(40,4))        self.layer4 = layer4#         self.fc = torch.nn.Linear(768, 4)    def forward(self, input_ids, attention_mask, token_type_ids):        with torch.no_grad():            last_hidden_state, pooler_output, all_hidden_states = pretrained(input_ids=input_ids,                             attention_mask=attention_mask,                             token_type_ids=token_type_ids,                             output_hidden_states= True)#         last_hidden_state= (last_hidden_state[:, 0]).reshape(16,768,1)        conv1 = self.layer1(last_hidden_state.permute(0,2,1))#         out = out.softmax(dim=1) #         conv1 = self.layer1(last_hidden_state.permute(0,2,1))        conv2 = self.layer2(conv1)#         fc_input = conv2.view(-1)#         fc_input = conv2.view(1,7680)#conv2.size()[0]        fc_input = conv2.view(conv2.size()[0],-1)       #转为一维向量形式#         fc_input = conv2.view(-1，7680)        fc_out = self.layer4(fc_input)        fc_out=fc_out.softmax(dim=1)      #归一化函数        return fc_outmodel = Model()model(input_ids=input_ids,      attention_mask=attention_mask,      token_type_ids=token_type_ids).shapeprint(model)from transformers import AdamW#训练optimizer = AdamW(model.parameters(), lr=5e-4)        #自适应梯度方法criterion = torch.nn.CrossEntropyLoss()       #model.train()for epoch in range(5):    for i, (input_ids, attention_mask, token_type_ids,        labels) in enumerate(loader):        out = model(input_ids=input_ids,                    attention_mask=attention_mask,                    token_type_ids=token_type_ids)        loss = criterion(out, labels)        loss.backward()        optimizer.step()        optimizer.zero_grad()        if i % 100 == 0:            out = out.argmax(dim=1)            accuracy = (out == labels).sum().item() / len(labels)            print(i, loss.item(), accuracy)        if i == 1510:            break\n测试代码class DatasetTest(torch.utils.data.Dataset):    def __init__(self):        path=&#x27;KUAKE-QTR/KUAKE-QTR_dev.json&#x27;        f=open(path,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;)        dataset=json.load(f)                self.dataset = dataset            def __len__(self):        return len(self.dataset)    def __getitem__(self, i):        query = self.dataset[i][&#x27;query&#x27;]        title = self.dataset[i][&#x27;title&#x27;]        label = int(self.dataset[i][&#x27;label&#x27;])        return query, title, label#测试def test():    model.eval()    correct = 0    total = 0    loader_test = torch.utils.data.DataLoader(dataset=DatasetTest(),                                              batch_size=16,                                              collate_fn=collate_fn,                                              shuffle=True,                                              drop_last=True)    for i, (input_ids, attention_mask, token_type_ids,            labels) in enumerate(loader_test):        if i == 182:      #2913/16==182            break        with torch.no_grad():            out = model(input_ids=input_ids,                        attention_mask=attention_mask,                        token_type_ids=token_type_ids)        pred = out.argmax(dim=1)        correct += (pred == labels).sum().item()        total += len(labels)    print(correct / total) test()# 保存模型torch.save(model.state_dict(), &#x27;models/cnn21.pth&#x27;)","tags":["bert-base-chinese","医疗信息处理评测基准CBLUE","页面标题相关性","nlp"]},{"title":"centos下一些常用的命令","url":"/2022/04/12/centos%E4%B8%8B%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","content":"基础命令删除命令#删除目录或者文件，如果是链接文件，则只删除这个链接文件而不是链接指向的文件rm xx#    -r　　　　　　递归删除目录#　　-f　　　　　　忽略不存在提示和确认提示，本身确认提示系统默认添加-i参数#　　-i　　　　　　删除文件前提示，输入y确认，输入任何非y字符取消一般 -rf联合使用# 删除文件夹里所有文件rm -rf  *# 删除文件夹里所有文件除了a,brm -f  !(a|b)\n复制移动命令#移动mv 文件 /xx/xx路径cp 参数 源文件/目录 目标目录-r 复制目录-p 连带文件属性复制-d 若源文件事链接文件 则复制链接属性-a 相当于-pdr#移动某文件夹下所有文件到另一个文件夹mv  目标文件的上一级目录/*  新的目录\n创建命令# 创建文件touch  文件名# 创建文件夹mkdir  文件名# 创建嵌套的文件夹mkdir -p a/b/c    \n\n\n解压命令tar.gz文件压缩tar cvfz backup.tar.gz /xxx/       -c, --create              create a new archive       -v, --verbose              verbosely list files processed       -f, --file [HOSTNAME:]F              use archive file or device F (default /dev/rmt0)       -z, --gzip, --ungzip              filter the archive through gzip\ntar.gz文件解压tar -zxvf xxx.tar.gz这样会生成一个以文件名命名的文件夹       -z, --gzip, --ungzip              filter the archive through gzip       -x, --extract, --get              extract files from an archive       -v, --verbose              verbosely list files processed       -f, --file [HOSTNAME:]F              use archive file or device F (default /dev/rmt0)#指定路径解压tar -xvzf filename.tar.gz -C ~/path/to/extract\n\n其他类型*.tar 用 tar –xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar –xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar –xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar –xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压\n\n文本编辑命令显示/隐藏行号#显示行号:set number/nu #隐藏行号:set nonu","tags":["centos","常用命令"]},{"title":"centos下安装虚拟机","url":"/2022/04/06/centos%E4%B8%8B%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/","content":"今天老师终于把五台服务器权限交给我了。然后为了避免让服务器崩溃，只能在服务器(centos)下安装虚拟机进行训练了了。注意:   ssh连接用 ‘ssh  -Y root@host’\ncentos下安装虚拟机（kvm）1.安装加载kvm1.1查看系统版本cat /etc/centos-release\n\n1.2验证CPU是否支持虚拟化输入有vmx或svm就支持，支持虚拟化则就支持KVM\ncat /proc/cpuinfo | egrep &#x27;vmx|svm&#x27;\n1.3看看是否加载KVMlsmod | grep kvm\n\n1.4关闭selinuxsetenforce 0vim /etc/sysconfig/selinux      #修改为SELINUX=disabled\n1.5安装KVM相关软件包yum install qemu-kvm qemu-img \\ virt-manager libvirt libvirt-python virt-manager \\ libvirt-client virt-install virt-viewer -y# qemu-kvm: KVM模块# libvirt: 虚拟管理模块# virt-manager: 图形界面管理虚拟机# virt-install: 虚拟机命令行安装工具\n\n1.6启动libvirt并设置开机自启动systemctl start libvirtdsystemctl enable libvirtd\n\n2.kvm的配置2.1 先查看自己分区df -hT     #记得将存储池放在自己较大的区域，否则就是默认\n\n2.2 进入图形化virt-manager\n\n2.3 协议选择VNC\n打开使用命令virt-manager","categories":["centos/linux","KVM"],"tags":["centos/linux","KVM"]},{"title":"centos下查看自己ip的几种方法","url":"/2022/03/31/centos%E4%B8%8B%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1ip%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","content":"linux下获取自己ip地址使用dig命令查找公共IP地址dig命令是一个DNS查找实用程序，用于Linux系统通过连接到OpenDNS服务器来查找公共IP地址。\n$ dig +short myip.opendns.com @resolver1.opendns.com \n\n使用wget命令获取公共IP地址$ wget http://ipecho.net/plain -O - -q ; echo\n\n使用curl命令获取公共地址$ curl ipecho.net/plain; echo$ curl icanhazip.com$ curl ifconfig.me","categories":["centos/linux"],"tags":["centos","网络","ip"]},{"title":"centos下的几种下载方式","url":"/2022/05/16/centos%E4%B8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F/","content":""},{"title":"centos关闭防火墙","url":"/2022/03/30/centos%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/","content":"今天部署rancher时，发现web页面总被防火墙阻拦。\n解决方法：先查看防火墙状态\nsystemctl status firewalld.service\n\nactive(running)表示防火墙开启\n关闭防火墙\nsystemctl stop firewalld service\n\n开关机设置\nsystemctl disable firewalld.service       #开机禁止防火墙服务器systemctl enable firewalld.service        #开机启动防火墙服务器","categories":["centos/linux"],"tags":["centos","防火墙"]},{"title":"docker中部署jar包","url":"/2022/04/14/docker%E4%B8%AD%E9%83%A8%E7%BD%B2jar%E5%8C%85/","content":"编写Dockerfile文件在自己目录下创建文件#创建文件touch Dockerfile #修改vi Dockerfile\n然后按照以下格式\n# 使用这个命令会将java8 环境集成在你打好的镜像中FROM java:8# 作者名MAINTAINER xxx# 将jar包改成你想要的名字ADD jeecg-boot.jar xxx.jar# 端口EXPOSE 8080# jar包启动命令ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;xxx.jar&quot;]\n制作镜像然后我们开始用build命令制作镜像\n#格式为docker build [参数] [路径] [目标]#例如docker build -t 镜像名字 .\n成功\n运行容器docker run -itd –name xxx xxx.jar\n然后神奇的发现报错了。status状态码127\n查看状态码125：是由Docker守护程序本身造成的，一般是因为 docker run 命令本身报错了126：无法调用所包含的命令，例如权限不足，无法访问目录或者执行命令127：找不到所包含的命令，例如环境中没有安装 curl 命令，但你调用了 curl 命令，那就找不到咯128+N：N是Bash的信号，比如信号是15，那么128+15=143，这时候 docker 的 退出代码就是 Exited(143)\n似乎是Dockerfile里面不能拉取jdk8导致。只能自己拉取一个jdk8的镜像了\n重新拉取并运行jdk8镜像#拉取docker pull jdk:8#运行成容器docker run -d -it -name xxx -p 8080:8080 jave#进入容器docker exec -it id bash#将宿主机jar包复制到容器（重开一个终端）docker cp 宿主机地址 id:容器地址# 在容器中运行jar包java -jar xxx.jar","tags":["docker","jar打包","Dockerfile"]},{"title":"docker入门(centos)","url":"/2022/03/28/docker%E5%85%A5%E9%97%A8/","content":"第一章 docker简史Docker项目最初是由一家名为DotCloud的平台即服务厂商所打造，其后该公司更名为Docker。Docker 在1.8以前直接使用Linux Containers (LXC)，而后自己抽象出Libcontainer层，支持多种容器技术，默认采用LXC实现。与其它容器平台不同，Docker引入了一整套与容器管理相关的生态系统。其中包括一套高效的分层式容器镜像模型、一套全局及本地容器注册表、一个精简化REST API以及一套命令行界面等等。\n第二章 容器和镜像\n容器(container)什么是容器呢？容器就是在你的电脑上一个隔绝其他配置的地方，可以理解为一个小虚拟机，它拥有自己的终端空间(kernel namespaces)、根目录(chroot)和控制组(cgroups)。它的特点如下：\n\n 可以运行镜像(image),你可以创造删除移动修改docker的API或者CLI.\n 可以运行在本地电脑或虚拟机，甚至配置在本地\n 非常便捷，可以在几乎所有操作系统下运行\n 每个容器是独立的，可以独自运行自己的软件、配置\n\n镜像(images)什么是镜像呢？当运行容器时，容器需要独立的文件系统。这个文件系统就是镜像。一个镜像需要包含所需的依赖、脚本各种二进制文件等等。当然我们也可以将容器打包成镜像，在另一台环境不同的机器上运行。因为容器自带配置，所以省去了很多配置环境带来的麻烦。\n仓库(repository)仓库是集中保管镜像的地方，仓库分为公开仓库(public)和私有仓库(private)两种形式。\n\n 最大的开放仓库是Docker hub\n 国内的公开仓库包括阿里云，网易云都有容器服务器等\n\n第三章 如何开始centos下安装docker安装方法有三种，可以挑自己需要的\n\n 设置docker仓库进行安装，这也本文所介绍的\n 提前下载，并选择RPM包进行手动安装(适合连不了网的电脑)\n 使用便捷的自动化脚本\n\n首先可能要卸载旧版本sudo yum remove docker \\                 docker-client \\                 docker-client-latest \\                 docker-common \\                 docker-latest \\                 docker-latest-logrotate \\                 docker-logrotate \\                 docker-engine\n设置仓库$ sudo yum install -y yum-utils$ sudo yum-config-manager \\   --add-repo \\   https://download.docker.com/linux/centos/docker-ce.repo\n\n注意，如果连接不上仓库可以考虑国内的镜像。臂如清华开源的[https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/] ,进网站注意自己找所需要的版本替代即可。docker加速器\n安装Docker查看版本\nyum list docker-ce --showduplicates|sort -r\n安装你刚刚下的\n$ sudo yum install docker-ce docker-ce-cli containerd.io或者yum -y install docker-ce-xx.xx.x.ce\n\n启动和重启Docker$ sudo systemctl start docker$ systemctl restart docker\n然后可以用命令：docker version测试Docker是否安装成功，并查看版本信息。\n第四章 Docker使用管理容器# 列出所有运行的容器docker psdocker pa -a  #查看所有容器# 进入容器docker exec -it 容器id bashdocker update –-restart=always id #设置开机自启docker start 容器id\t\t# 启动容器docker restart 容器id\t# 重启容器docker stop 容器id\t\t# 停止正在运行的容器docker kill 容器id\t\t# 强制停止当前容器# 新建容器并启动docker run [可选参数] image--name=&quot;Name&quot;\t 容器名字,用于区分容器-d\t\t\t\t后台方式运行-it\t\t\t\t使用交互方式运行,进入容器查看内容-p\t\t\t\t指定容器端口(小写)-p ip:主机端口:容器端口例如：-p 8080:8080# 容器停止并退出exit# 容器不停止退出Ctrl+p+q# 删除指定容器,不能删除正在运行的容器,强制删除用rm -fdocker rm 容器id# 从容器内拷贝文件到主机docker cp 容器id:容器内路径 目的主机路径\n管理镜像# 下载镜像docker pull 镜像名[:tag]# 查看本地所有镜像docker images# 搜索镜像docker search 镜像名字# 删除镜像docker rmi `docker rmi -f 镜像id`：删除指定镜像 `docker rmi -f 镜像id 镜像id 镜像id`：删除指定多个镜像 `docker rmi -f $(docker images -aq)`：删除全部镜像#查看容器映射docker inspect 容器id\n\n进阶status状态码125：是由Docker守护程序本身造成的，一般是因为 docker run 命令本身报错了126：无法调用所包含的命令，例如权限不足，无法访问目录或者执行命令127：找不到所包含的命令，例如环境中没有安装 curl 命令，但你调用了 curl 命令，那就找不到咯128+N：N是Bash的信号，比如信号是15，那么128+15=143，这时候 docker 的 退出代码就是 Exited(143)\n","categories":["centos/linux","docker"],"tags":["centos","docker","linux"]},{"title":"docker加速器","url":"/2022/03/28/docker%E5%8A%A0%E9%80%9F%E5%99%A8/","content":"本来以为自己挂个vpn，docker就可以不用配国内镜像的。结果发现不行哈哈哈哈这是配置前\n配置成功后\n\n\n 首先配置镜像加速器\nsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://ia2rmrkg.mirror.aliyuncs.com&quot;]&#125;EOF\n 然后关闭重启docker\nsudo systemctl daemon-reloadsudo systemctl restart docker\n然后就可以随意pull，但是国内镜像好少。好多官网推荐的镜像都没有\n\n\n阿里云镜像地址\n","categories":["centos/linux","docker"],"tags":["centos","docker"]},{"title":"filter组件","url":"/2022/07/21/filter%E7%BB%84%E4%BB%B6/","content":"Filter概念：过滤器，javaweb三大组件之一\n过滤器的作用\n可以解决获取请求参数中文乱码问题，将代码从servlet转移到了filter中\n登录验证\n过滤一些敏感词汇\n\n过滤器的生命周期生命周期init()doFilter()destroy()\nfilter + servlet的执行流程1.当服务器开启的时候，会执行filter的init()2.当我们第一次访问servlet的时候，会先执行servlet的init()，然后会执行filter的doFilter的放行前代码              然后会执行servlet中的service()，然后会执行filter的doFilter的放行后代码3.如果我们重复访问servlet的时候，会重复执行filter的doFilter的放行前代码，servlet中的service()，              filter的doFilter的放行后代码4.当服务器正常关闭的时候，会执行servlet的destroy()，然后会执行filter的destroy()\n过滤器的url-pattern的配置配置servlet的url-pattern是为了设置具体如何访问这个servlet配置filter的url-pattern是为设置具体拦截(过滤)哪些资源\n常见的配置格式：\n1./XXX\t/servletDemo01\t/demo01.jsp\t2./XXX/*\t/user/*\t/goods/*\t\t/user/findAll\t/user/add\t/user/delete\t/goods/findAll\t3.*.jsp4./*\t拦截所有资源\n\n过滤器的配置方式方式一：配置文件方式\t\t\t&lt;filter&gt;\t\t\t\t&lt;filter-name&gt;filterDemo01&lt;/filter-name&gt;\t\t\t\t&lt;filter-class&gt;com.filter.FilterDemo01&lt;/filter-class&gt;\t\t\t&lt;/filter&gt;\t\t\t&lt;filter-mapping&gt;\t\t\t\t&lt;filter-name&gt;filterDemo01&lt;/filter-name&gt;\t\t\t\t&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\t\t\t&lt;/filter-mapping&gt;```\t\t####\t方式二：注解方式@WebFilter(&quot;/servletDemo01&quot;)\t\t\t### 过滤器链过滤器链就是配置多个过滤器#### 例子\t\t\tservletDemo01  2个过滤器\t\t\t\t\t\tfilter1...init\t\t\tfilter3...init\t\t\t\t\t\tfilter1...前\t\t\tfilter3...前\t\t\tservlet...service\t\t\tfilter1...后\t\t\tfilter3...后\t\t\t#### 多个过滤器的先后执行顺序？\t\t\t配置文件方式：\t\t\t\t是根据filter的上下位置有关，上面的先执行，下面的后执行\t\t\t\t\t\t\t注解方式：\t\t\t\t是根据Filter的类名的字典顺序进行比较，小的先执行，大的后执行### 过滤器的入门小案例1.创建一个类，实现一个接口，重写一些方法\n        public class FilterDemo01 implements Filter &#123;\n            @Override\n            public void init(FilterConfig filterConfig) throws ServletException &#123;\n                \n            &#125;\n\n            @Override\n            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n                    throws IOException, ServletException &#123;\n                System.out.println(&quot;filterDemo01...doFilter...&quot;);\n                chain.doFilter(request, response);\n            &#125;\n\n            @Override\n            public void destroy() &#123;\n                \n            &#125;\n        &#125;\n\n2.进行简单的配置\n        &lt;filter&gt;\n            &lt;filter-name&gt;filterDemo01&lt;/filter-name&gt;\n            &lt;filter-class&gt;com.filter.FilterDemo01&lt;/filter-class&gt;\n        &lt;/filter&gt;\n        &lt;filter-mapping&gt;\n            &lt;filter-name&gt;filterDemo01&lt;/filter-name&gt;\n            &lt;url-pattern&gt;/servletDemo01&lt;/url-pattern&gt;\n        &lt;/filter-mapping&gt;\n\n\n### filter和interceptor的区别\n1.filter接口在javax.servlet包下面。inteceptor定义在org.springframework.web.servlet中。\n\n2.filter是servlet规定的，interceptor即可用于web程序，也可用于application中。\n\n3.filter是servlet容器支持的，interceptor是spring框架支持的。\n\n4.filter只在方法前后执行，interceptor粒度更细，可以深入到方法前后，异常抛出前后。\n\n","tags":["过滤器","filter"]},{"title":"find查找","url":"/2022/04/21/find%E6%9F%A5%E6%89%BE/","content":"linux的find查找命令使用方式：  find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path…] [expression]\n根据文件名查找\n    -name  文件名：根据指定文件名进行查找\n\n根据文件从属关系查找\n    -user  指定属主:根据文件属主查找\n\n    -group  指定属组:根据文件属组查找\n\n    -uid UID:根据属主UID查找\n\n    -gid GID:根据属组GID查找\n\n    -nouser:查找没有属主的文件\n\n    -nogroup:查找没有属组的文件\n\n根据文件类型查找\n    -type *\n\n    f：普通文件\n\n    d:目录文件\n\n    i:符号链接文件\n\n    b:块设备文件\n\n    c:字符设备文件\n\n    p:管道文件\n\n    s:套接字文件\n\n组和测试：\n    -a：与，相当于&amp;\n\n    -o：或，相当于|\n\n    -not: 非相当于！\n\n根据文件大小查找：\n    -size[+|-]#UNIT\n\n    查找/etc中大于1M的文件 并且为普通文件的所有文件并且查看\n\n   find /etc -size +1M -a -type f -ls\n\n    查找/etc中小于1M的文件 并且为普通文件的所有文件并且查看\n\n   find /etc -size -1M -a -type f -ls\n\n根据时间查找\n    -atime[+|-]     以天为单位的          最近访问时间\n\n    -mtime[+|-]                                    最近更改时间\n\n    -ctime[+|-]                                     最近改动时间\n\n    -amin[+|-]      以分为单位              同上\n\n    -mmin                                            同上\n\n    -cmin                                             同上\n\n根据权限查找\n    -perm[/|-]mode\n\n    /：任意一个用户满足条件即为满足\n\n    -：满足指定的权限即为满足\n\n    支持八进制权限位\n\n处理动作：\n    -ls：相当于ls -l（把查找到的文件输出为长格式）\n\n    -ok 命令 &#123;&#125; \\ :把查找到的文件按照指定的命令做出相应的动作某些操作需要用户每次手动确认\n\n    -exec 命令 &#123;&#125; \\：把查找到的文件按照指定的命令做出相应的动作某些命令不需要用户每次手动确认\n\n    find | xargs        管道给下一个命令进行操纵。（由于有一些命令不支持过长的参数所以用这个可以躲避这样的问题）\n\n   -fls  文件路径：将查找到的文件保存到指定的路径上。\n\n","tags":["linux","查找命令"]},{"title":"flask服务器部署","url":"/2022/05/15/flask%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/","content":"先拉取docker镜像docker pull python:3.6\n\n运行镜像docker run python:3.6 -p 2222:2222     #一定要记得留端口docker exec -d -it 容器id bash\n\n把python文件传输到docker中#再开一个终端docker cp main.py 容器id:路径\n\n运行","tags":["docker","centos/linux","flask"]},{"title":"github上传大文件","url":"/2022/04/10/github%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/","content":""},{"title":"git的克隆与上传","url":"/2022/04/10/git%E7%9A%84%E5%85%8B%E9%9A%86%E4%B8%8E%E4%B8%8A%E4%BC%A0/","content":"git clone创建本地仓库先在本地创建自己一个文件夹作为本地仓库。然后打开 git bash\ngit clone  仓库ssh链接\n\ngit add将文件加入缓存区#将数据全部添加缓存，不用一个个添加git add .\n\ngit status查看文件状态\ngit commit提交命令git commit -m &#x27;注释&#x27;\n\ngit push拉取仓库git pull origin master\ngit push将本地master分支上所有代码，都推送到master分支上#推送到起始分支git push origin master\n\ngit log可以查看日志","tags":["git"]},{"title":"Hello World","url":"/2021/12/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"ide常用快捷键","url":"/2022/05/05/ide%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"java快捷键psvm\tpublic static void main(String[] args)&#123;&#125;sout\tSystem.out.println()souf\tSystem.out.printf()fori\tfor (int i = 0; i &lt; ; i++) &#123; &#125;\n\n基本操作快捷键ctrl+x //删除行(其实是剪切)ctrl+d //复制当前选择内容，没有选中内容则为复制当前行双击shift\t//查找文件ctrl+shift+f\t//查找内容ctrl+shift+r\t//查找替换内容ctrl+鼠标右键\t//链接到接口等关联ctrl+alt+鼠标右键\t//链接到接口的实现类","tags":["ide","javaee"]},{"title":"java多线程机制","url":"/2022/05/06/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/","content":"多线程概念什么是进程打开一个应用程序，就开启一条进程。\n什么是线程进程中的一条执行单元，执行路径\n什么是并行在同一时刻，多个指令可以在多个CPU上同时执行\n什么是并发在同一时刻，多个指令可以在一个CPU上交替执行\n多线程实现方法方法一            1.定义一个类，继承Thread类2.重写run()方法3.创建该类对象4.调用strat()方法\n例如\npackage com.thread1;public class Demo01 &#123;\tpublic static void main(String[] args) &#123;\t\t//创建第一个线程\t\tMyThread mt1 = new MyThread();\t\t//mt1.run();\t\tmt1.start();//开启线程，底层调用了run()方法\t\t\t\t//创建第二个线程\t\tMyThread mt2 = new MyThread();\t\t//mt2.run();\t\tmt2.start();\t\t\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t&#125;&#125;class MyThread extends Thread &#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t&#125;&#125;\n\n方法二            1.定义一个类，实现Runnable接口2.重写run()方法3.创建该类对象4.创建Thread对象，把上一个对象传入其中5.调用start()方法 \n例如\npackage com.thread1;public class Demo02 &#123;\tpublic static void main(String[] args) &#123;\t\tMyRunnable mr = new MyRunnable();\t\t\t\tThread t1 = new Thread(mr);\t\tt1.start();\t\t\t\tThread t2 = new Thread(mr);\t\tt2.start();\t\t\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t&#125;&#125;class MyRunnable implements Runnable &#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t&#125;&#125;\n\n方法三            1.定义一个类，实现Callable接口2.重写call()方法3.创建该类对象对象4.创建Future的实现类FutureTask对象，将上一个对象传入其中5.调用get()，可以获取到线程执行完之后的返回值结果6.创建Thread对象，将上一个对象传入其中7.调用start()方法\n例如\npackage com.thread1;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Demo03 &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\tMyCallable mc = new MyCallable();\t\t\t\tFutureTask&lt;String&gt; ft1 = new FutureTask&lt;&gt;(mc);\t\tThread t1 = new Thread(ft1);\t\tt1.start();\t\t\t\tFutureTask&lt;String&gt; ft2 = new FutureTask&lt;&gt;(mc);\t\tThread t2 = new Thread(ft2);\t\tt2.start();\t\t\t\tfor(int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t\t\t\tSystem.out.println(ft1.get());\t\tSystem.out.println(ft2.get());\t&#125;&#125;class MyCallable implements Callable&lt;String&gt; &#123;\t@Override\tpublic String call() throws Exception &#123;\t\tfor(int i = 1; i &lt;= 1000; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t\treturn &quot;约吗&quot;;\t&#125;&#125;\n三种方法的区别1.继承Thread优点：编写代码比较简单，可以直接使用Thread类中的方法\n缺点：扩展性比较差，因为继承了一个类就不能再继承其他的类\n\n2.实现Runnable和Callable接口优点：扩展性比较好，在实现接口的同时还可以继承其他的类\n缺点：编写代码比较复杂，而且不能直接使用Thread类中的方法\n\nThread中的常用API    public final void setName(String name)：设置线程的名字\tpublic final String getName()：获取正在执行的线程的名字\tpublic static Thread currentThread()：获取当前正在执行的线程对象\tpublic final void setPriority(int newPriority)：设置线程优先级#\t\t\t默认优先级为5#\t\t\t数字越大优先级越高#\t\t\t优先级范围：1-10\t\t\t\tpublic final int getPriority()：获取线程优先级\tpublic final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程\t\t\t用户线程全部执行完了守护线程如果没执行完的话它会自动被jvm终止，然后结束程序\tpublic static void sleep(long millis)：让线程睡一会\n\n线程的生命周期#五种状态    新建状态\t就绪状态\t运行状态\t阻塞状态\t死亡状态\n!{}(1.jpg)\n多线程并发问题例子比如一家电影院在出售电影票，一共有三个窗口出售100张。\npublic class Demo01 &#123;\tpublic static void main(String[] args) &#123;\t\tTicket t = new Ticket();\t\t\t\tThread t1 = new Thread(t, &quot;窗口1&quot;);\t\tt1.start();\t\t\t\tThread t2 = new Thread(t, &quot;窗口2&quot;);\t\tt2.start();\t\t\t\tThread t3 = new Thread(t, &quot;窗口3&quot;);\t\tt3.start();\t&#125;&#125;class Ticket implements Runnable &#123;\tpublic int tickets = 100;\t\t@Override\tpublic void run() &#123;\t\t//售票\t\twhile(true) &#123;\t\t\tif(tickets &gt; 0) &#123;\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;...正在出售第...&quot; + tickets + &quot;...张票&quot;);\t\t\t\ttickets--;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n查看结果发现有1.重复的票数2.负数的票数\n解决方法同步代码块1.同步代码块格式：synchronized(锁对象) &#123;\t\t\t\t&#125;\t\t\t\t注意：锁对象可以是任意引用数据类型的对象，但是要保证多个线程是同一把锁对象\t\t\t\t我们什么时候需要用到同步机制？\t1.是多线程的程序\t2.是否有共享资源\t3.操作共享资源的代码是否有多条\t\t\t\t同步代码块又该写在哪个位置？\t把出现共享资源的代码都包含起来即可\n同步格式2.同步方法格式：\t修饰符 synchronized 返回值类型 方法的名字(形参) &#123;\t\tXXXOOO;\t&#125;\t\t\t\t\t同步方法的锁对象是什么？\tthis\n静态同步方法3.静态同步方法格式：\t修饰符 synchronized static 返回值类型 方法的名字(形参) &#123;\t\tXXXOOO;\t&#125;\t\t\t\t\t静态同步方法的锁对象是什么？\t字节码文件对象\t类名.class\nLock锁4.Lock锁ReentrantLock lock = new ReentrantLock();lock.lock();lock.unlock();\n\n\n","tags":["javaee","多线程","蜗牛学苑笔记"]},{"title":"java枚举类","url":"/2022/05/11/java%E6%9E%9A%E4%B8%BE%E7%B1%BB/","content":""},{"title":"java线程的其他机制","url":"/2022/05/11/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E6%9C%BA%E5%88%B6/","content":"1.等待唤醒机制解决生产者和消费者的问题\npublic final void wait()：让线程等待public final void notify()：唤醒线程public final void notifyAll()：唤醒所有线程\nwait()方法和sleep()方法的区别    1.wait()是Object类中的普通成员方法\n      sleep()是Thread类中的静态成员方法\n      \n    2.wait()方法等待之后，必须被唤醒\n      sleep()方法睡觉之后，自己会醒\n     \n    3.wait()方法在等待的时候，会释放锁对象\n      sleep()方法在睡觉的时候，不会释放锁对象\n\n2.关于Java中线程安全的类StringBuffer和StringBuilder    StringBuilder：线程不安全的，效率高\n    StringBuffer：线程安全的，效率低\n\nArrayList和Vector    ArrayList：线程不安全的，效率高\n    Vector：线程安全，效率低\n\nHashMap和Hashtable    HashMap：线程不安全，效率高\n    Hashtable：线程安全，效率低\n\n3.死锁现象同步代码块的嵌套会造成死锁现象\n4.Timer类  用法:可安排任务执行一次，或者定期重复执行，计时器类\n常见构造方法public Timer()：   #创建一个新计时器\n常见成员方法public void schedule(TimerTask task, Date time)：安排在指定的时间执行指定的任务。public void schedule(TimerTask task, long delay)：安排在指定延迟后执行指定的任务。public void schedule(TimerTask task, Date firstTime, long period)：\t安排指定的任务在指定的时间开始进行重复的固定延迟执行。public void schedule(TimerTask task, long delay, long period)：\t安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。\n\n5.单例设计模式介绍使用单例设计模式，能够实现一个类只能有一个对象\n实现1饿汉式(立即加载)：因为饿，非常着急的要吃东西\t\t\tclass Singleton &#123;\t\t\t\tprivate static final Singleton singleton = new Singleton();\t\t\t\t\t\t\t\tprivate Singleton() &#123;\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\tpublic static Singleton getInstance() &#123;\t\t\t\t\treturn singleton;\t\t\t\t&#125;\t\t\t&#125;\t\t\t优点：不会出现多线程并发访问问题缺点：对象太早的进内存，太晚消失，占内存\t\t\t\n实现2方法1                class Singleton &#123;\t\t\t\t\tprivate static Singleton singleton;\t\t\t\t\t\t\t\t\t\tprivate Singleton() &#123;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tpublic static Singleton getInstance() &#123;\t\t\t\t\t\tif(singleton == null) &#123;\t\t\t\t\t\t\tsingleton = new Singleton();\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\treturn singleton;\t\t\t\t\t&#125;\t\t\t\t&#125;优点：对象不会太早的进内存，不占用内存缺点：在多线程中，可能会创建出多个对象，就不构成单例了\n\n方法2\t\t\t\tclass Singleton &#123;\t\t\t\t\tprivate static Singleton singleton;\t\t\t\t\t\t\t\t\t\tprivate Singleton() &#123;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tpublic static synchronized Singleton getInstance() &#123;\t\t\t\t\t\tif(singleton == null) &#123;\t\t\t\t\t\t\tsingleton = new Singleton();\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\treturn singleton;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t优点：不占内存，解决线程安全问题缺点：效率低\n\n方法3(主推荐)\t\t\t\tclass Singleton &#123;\t\t\t\t\tprivate static Singleton singleton;\t\t\t\t\t\t\t\t\t\tprivate Singleton() &#123;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tpublic static Singleton getInstance() &#123;\t\t\t\t\t\tif(singleton == null) &#123;\t\t\t\t\t\t\tsynchronized(Singleton.class) &#123;\t\t\t\t\t\t\t\tif(singleton == null) &#123;\t\t\t\t\t\t\t\t\tsingleton = new Singleton();\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\treturn singleton;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t优点：不占内存，解决线程安全问题，解决线程安全引发的效率低问题\n\n\n","tags":["javaee","多线程","蜗牛学苑笔记"]},{"title":"k8s入门","url":"/2022/04/26/k8s%E5%85%A5%E9%97%A8/","content":"k8s概念先上中文文档\nMasterNodeEtcdReplication ControllerReplicaSetDeploymentPodServiceLabelVolumeNamespaceConfigMap","tags":["centos/linux","linux","服务器"]},{"title":"linux下的目录结构","url":"/2022/04/19/linux%E4%B8%8B%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","content":"/boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。/etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。/lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。/sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中指令集合：\n/bin：存放着最常用的程序和指令/sbin：只有系统管理员能使用的程序和指令。外部文件管理：\n**/dev **：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。/media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。/mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。临时文件：\n/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。/lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。/tmp：这个目录是用来存放一些临时文件的。账户：\n/root：系统管理员的用户主目录。/home：用户的主目录，以用户的账号命名的。/usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。/usr/bin：系统用户使用的应用程序与指令。/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。/usr/src：内核源代码默认的放置目录。运行过程中要用：\n/var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。/proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。扩展用的：\n/opt：默认是空的，我们安装额外软件可以放在这个里面。/srv：存放服务启动后需要提取的数据（不用服务器就是空）\n","tags":["centos/linux","目录结构"]},{"title":"listen组件","url":"/2022/07/21/listen%E7%BB%84%E4%BB%B6/","content":"Listener简介监听器，是javaweb三大组件之一\nServeltContextListenerServeltContextListener入门小案例？        1.创建一个类，实现监听器接口，重写抽象方法\n\t\t\tpublic class MyServletContextListener implements ServletContextListener &#123;\t\t\t\t@Override\t\t\t\tpublic void contextInitialized(ServletContextEvent sce) &#123;\t\t\t\t\tSystem.out.println(&quot;servletContext对象被创建...&quot;);\t\t\t\t&#125;\t\t\t\t@Override\t\t\t\tpublic void contextDestroyed(ServletContextEvent sce) &#123;\t\t\t\t\tSystem.out.println(&quot;servletContext对象被销毁...&quot;);\t\t\t\t&#125;\t\t\t&#125;```\t\t\t\t2.进行简单配置\n        &lt;listener&gt;\n            &lt;listener-class&gt;com.listener.MyServletContextListener&lt;/listener-class&gt;\n        &lt;/listener&gt;\n\n### ServletRequestListener\t\t\tServletRequestListener入门小案例\t\t1.创建一个类，实现监听器接口，重写抽象方法\n        public class MyServletRequestListener implements ServletRequestListener &#123;\n            @Override\n            public void requestInitialized(ServletRequestEvent sre) &#123;\n                System.out.println(&quot;request对象被创建...&quot;);\n            &#125;\n            \n            @Override\n            public void requestDestroyed(ServletRequestEvent sre) &#123;\n                System.out.println(&quot;request对象被销毁了...&quot;);\n            &#125;\n        &#125;\n\n2.进行简单配置\n        &lt;listener&gt;\n            &lt;listener-class&gt;com.listener.MyServletRequestListener&lt;/listener-class&gt;\n        &lt;/listener&gt;\n\n### listener配置方式#### 方式一：配置文件方式\n\n    com.listener.MyServletRequestListener\n\n```        \n#### 方式二：注解方式\n@WebListener\n","tags":["listener","监听器"]},{"title":"markdown的语法","url":"/2022/01/08/markdown/","content":"markdown的语法斜体和粗体*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~\n分级标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n超链接（同时可以插入图像）[超链接]# 带有文字的链接[文字](链接)\n\n代码行使用```#include &lt;stdio.h&gt;int main(void)&#123;    printf(&quot;Hello world\\n&quot;);&#125;结尾```\n\n","categories":["计算机","博客"],"tags":["markdown","博客"]},{"title":"mybaits","url":"/2022/05/30/mybaits/","content":"MyBatis简介介绍MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。iBATIS一词来源于“internet”和“abatis”的组合，是一个(基于Java的持久层框架)。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）MyBatis基于ORM思想的框架\n使用Java代码操作数据库的方式1.JDBC 最原始的2.JdbcTemplate JDBC工具类 基于ORM3.MyBatis 框架 基于ORM\nMyBatis的优点1.简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学\n习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。\n    \n2.灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 \nsql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。\n    \n3.解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，\n更易单元测试。sql和代码的分离，提高了可维护性。\n    \n4.提供映射标签，支持对象与数据库的orm字段关系映射\n    \n5.提供对象关系映射标签，支持对象关系组建维护\n    \n6.提供xml标签，支持编写动态sql\n\nMyBatis的使用步骤：1.导入相关jar2个jar包            \nmybatis.jar\nmysql驱动.jar\n\n2.编写普通的Java类创建一个User类\n\n3.编写Dao的接口UserDao接口\n    里面提供增删改查等方法\n\n4.编写MyBatis核心配置文件在src路径下创建一个名为sqlMapConfig.xml的配置文件，建议名字不要起别的\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;\t&lt;environments default=&quot;mysql&quot;&gt;\t\t&lt;environment id=&quot;mysql&quot;&gt;\t\t\t&lt;transactionManager type=&quot;JDBC&quot;/&gt;\t\t\t&lt;dataSource type=&quot;POOLED&quot;&gt;\t\t\t\t&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\t\t\t\t&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db6&quot;/&gt;\t\t\t\t&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\t\t\t\t&lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt;\t\t\t&lt;/dataSource&gt;\t\t&lt;/environment&gt;\t&lt;/environments&gt;\t\t\t\t\t&lt;mappers&gt;\t\t&lt;mapper resource=&quot;com/mybatis/dao/UserMapper.xml&quot;/&gt;\t&lt;/mappers&gt;&lt;/configuration&gt;\n\n5.编写MyBatis的映射文件在dao包下创建一个名为UserMapper.xml的映射文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mybatis.dao.UserDao&quot;&gt;\t&lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatis.pojo.User&quot;&gt;\t\tselect * from user\t&lt;/select&gt;&lt;/mapper&gt;\n\n6.进行测试1.获取流对象，读取核心核心配置文件\tInputStream is = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\t\t\t\t2.创建SqlSession工厂的构建者对象\tSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\t\t\t\t3.获取SqlSession工厂对象\tSqlSessionFactory factory = builder.build(is);\t\t\t\t4.获取SqlSession对象\tSqlSession session = factory.openSession();\t\t\t\t5.获取UserDao的代理对象\tUserDao userDao = session.getMapper(UserDao.class);\t\t\t\t6.调用查询方法\tList&lt;User&gt; users = userDao.findAll();\tfor (User user : users) &#123;\t\tSystem.out.println(user);\t&#125;","tags":["数据库","mybaits"]},{"title":"mybaits和spring集成","url":"/2022/06/15/mybaits%E5%92%8Cspring%E9%9B%86%E6%88%90/","content":"Spring与MyBatis集成Spring+Mybatis \n1、添加依赖&lt;!-- mybatis --&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;5.1.38&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;druid&lt;/artifactId&gt;      &lt;version&gt;1.1.23&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.4.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 对于持久层框架的支持 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;      &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- mybatis和Spring关联的jar --&gt;    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;2.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.12&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;\n\n2、逆向生成Mybatis代码（手写）方法一ide下载”better-mybaits-generator”\n方法二使用脚本Mybatis-Generator\n添加依赖&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.5&lt;/version&gt;            &lt;configuration&gt;                &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;                &lt;verbose&gt;true&lt;/verbose&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;            &lt;executions&gt;                &lt;!-- &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; --&gt;            &lt;/executions&gt;            &lt;dependencies&gt;                &lt;dependency&gt;                    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                    &lt;version&gt;1.3.5&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n创建配置文件generatorContext.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;&lt;generatorConfiguration&gt;    &lt;classPathEntry            location=&quot;D:/javaee/repository/mysql/mysql-connector-java/8.0.25/mysql-connector-java-8.0.25.jar&quot; /&gt;    &lt;context id=&quot;mysql&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;!-- 生成的Java文件的编码 --&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;!-- 格式化java代码 --&gt;        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;        &lt;!-- 格式化XML代码 --&gt;        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;        &lt;!--beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号；--&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!-- 为了防止生成的代码中有很多注释，比较难看，加入下面的配置控制 --&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/seven_group?serverTimezone=UTC&amp;amp;charactorEncoding=utf-8&quot;                        userId=&quot;root&quot; password=&quot;root&quot; /&gt;        &lt;!--实体生成路径 --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.Springdemo.enity&quot;                            targetProject=&quot;src/main/java&quot; &gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;!--&lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;--&gt;        &lt;/javaModelGenerator&gt;        &lt;!--mapper文件生成路径 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.Springdemo&quot;                         targetProject=&quot;src/main/resources&quot; /&gt;        &lt;!--dao层生成路径 --&gt;        &lt;javaClientGenerator targetPackage=&quot;com.Springdemo&quot;                             targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot; /&gt;        &lt;table tableName=&quot;表明字&quot; domainObjectName=&quot;要创建的名字&quot;               enableCountByExample=&quot;true&quot;               enableUpdateByExample=&quot;true&quot;               enableDeleteByExample=&quot;true&quot;               enableSelectByExample=&quot;true&quot;               selectByExampleQueryId=&quot;false&quot;&gt;        &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;        &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;\n注意    1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；\n启动配置文件右键启动!{}(1.png)\n3、Spring的配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!--        扫描所有要被Spring管理的实例    --&gt;    &lt;context:component-scan base-package=&quot;com.woniu&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--        生成数据库连接池对象    --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;!--&lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;--&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        生成SqlSessionFactory    --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.woniu.pojo&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        扫描所有dao        通过下面的配置扫描com.woniu.dao,将所有dao接口对应dao.xml生成对应的实例    --&gt;    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.woniu.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n4、生成代码EmpService\npackage com.woniu.service.impl;import com.woniu.dao.EmpDAO;import com.woniu.pojo.Emp;import com.woniu.service.EmpService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @Author: Panda * @Date: 2021/4/21 11:57 * @Description: */@Servicepublic class EmpServiceImpl implements EmpService &#123;    @Autowired    private EmpDAO empDAO;    @Override    public List&lt;Emp&gt; getAllEmps() &#123;        return empDAO.selectByExample(null);    &#125;&#125;\n\nEmpServlet\npackage com.woniu.controller;import com.woniu.pojo.Emp;import com.woniu.service.EmpService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;/** * @Author: Panda * @Date: 2021/4/21 12:02 * @Description: */@WebServlet(&quot;/emp&quot;)public class EmpServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app.xml&quot;);        EmpService empService = (EmpService) applicationContext.getBean(&quot;empServiceImpl&quot;);        List&lt;Emp&gt; emps = empService.getAllEmps();        req.setAttribute(&quot;emps&quot;,emps);        req.getRequestDispatcher(&quot;list.jsp&quot;).forward(req,resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;\n\nlist.jsp\n&lt;%@ page import=&quot;com.woniu.pojo.Emp&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%--  Created by IntelliJ IDEA.  User: Panda  Date: 2021/4/21  Time: 12:07  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;%           List&lt;Emp&gt; emps = (List&lt;Emp&gt;) request.getAttribute(&quot;emps&quot;);           for(Emp emp:emps)&#123;        %&gt;            &lt;li&gt;&lt;%=emp.getEname() %&gt;&lt;/li&gt;        &lt;%           &#125;        %&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\n","tags":["spring","蜗牛学院笔记","mybaits"]},{"title":"mysql数据库的约束","url":"/2022/04/02/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BA%A6%E6%9D%9F/","content":"mysql的各种约束非空约束  NOT NULL保证列中所有的数据不能有null值。\n语法如下:\n\n添加约束\n-- 创建表时添加非空约束CREATE TABLE 表名(   列名 数据类型 NOT NULL,   …); -- 建完表后添加非空约束ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL; -- 删除约束ALTER TABLE 表名 MODIFY 字段名 数据类型;\n\n唯一约束  UNIQUE保证列中所有数据各不相同。\n语法如下:\n\n添加约束\n -- 创建表时添加唯一约束 CREATE TABLE 表名(    列名 数据类型 UNIQUE [AUTO_INCREMENT],    -- AUTO_INCREMENT: 当不指定值时自动增长,如id     );  CREATE TABLE 表名(    列名 数据类型,        [CONSTRAINT] [约束名称] UNIQUE(列名) );  -- 建完表后添加唯一约束 ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;-- 删除约束 ALTER TABLE 表名 DROP INDEX 字段名;\n\n主键约束  PRIMARY KEY主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。比如id\n语法如下:\n\n添加约束\n-- 创建表时添加主键约束CREATE TABLE 表名(   列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],   …); CREATE TABLE 表名(   列名 数据类型,   [CONSTRAINT] [约束名称] PRIMARY KEY(列名)); -- 建完表后添加主键约束ALTER TABLE 表名 ADD PRIMARY KEY(字段名);-- 删除约束ALTER TABLE 表名 DROP PRIMARY KEY;\n检查约束  CHECK保证列中的值满足某一条件。\n\n语法如下:*\n\n添加约束\n\n\n\n默认约束  DEFAULT保存数据时，未指定值则采用默认值\n语法如下:\n\n添加约束-- 创建表时添加默认约束CREATE TABLE 表名(   列名 数据类型 DEFAULT 默认值,   …); -- 建完表后添加默认约束ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; -- 删除约束ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;\n\n外键约束  FOREIGN KEY外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。(可以建立多表)\n语法如下:\n\n添加约束 -- 创建表时添加外键约束CREATE TABLE 表名(   列名 数据类型,   …   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) );  -- 建完表后添加外键约束ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); -- 删除外键约束ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n","categories":["数据库","mysql"],"tags":["数据库","mysql"]},{"title":"mysql的四种锁总结","url":"/2022/09/19/mysql%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%94%81%E6%80%BB%E7%BB%93/","content":"前言分析加入我们要搭建一个删库存的工程，库存在并发量极大的情况容易发生超卖情况。一旦发生超卖，会形成订单成交数量比库存量多的情况。\n//不加锁的情况@Servicepublic class StockService &#123;   private Stock stock = new Stock();    public synchronized void deduct_yuan()&#123;        stock.setStock(stock.getStock()-1);        System.out.println(&quot;库存余量&quot;+stock.getStock());    &#125;&#125;\n\n\n\n压力测试工具：jmeter可自行下载，在bin中打开bat文件\n\n逐步添加线程组  http请求 图表\n\n\n\n运行和清除\n\n1.jvm本地锁1.1 synchronized同步锁@Servicepublic class StockService &#123;    @Autowired    private StockMapper stockMapper;        public synchronized void deduct()&#123;    \t\t//先查询库存是否充足            Stock stock=this.stockMapper.selectOne(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;,&quot;1001&quot;));                        //再减库存            if(stock!=null&amp;&amp;stock.getCount()&gt;0)&#123;                stock.setCount(stock.getCount()-1);                this.stockMapper.updateById(stock);    &#125;&#125;\n\n添加关键字synchronized以后，StockService就具备了对象锁，同一时刻就只有一个请求能够获取到锁。虽然不会发生超卖现象，但是只能一个接一个删减下去，效率极低。\n1.2ReentrantLock锁@Servicepublic class StockService &#123;     @Autowired    private StockMapper stockMapper;\tprivate ReentrantLock lock=new ReentrantLock();\t    public void deduct()&#123;        lock.lock();        try &#123;            Stock stock=this.stockMapper.selectOne(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;,&quot;1001&quot;));            if(stock!=null&amp;&amp;stock.getCount()&gt;0)&#123;                stock.setCount(stock.getCount()-1);                this.stockMapper.updateById(stock);            &#125;        &#125;finally &#123;            lock.unlock();        &#125;    &#125;&#125;\n\n1.3三种情况导致的本地锁失效1.3.1 多例模式@Service@Scope(value = &quot;prototype&quot;,proxyMode = ScopedProxyMode.TARGET_CLASS)public class StockService &#123;     @Autowired    private StockMapper stockMapper;\tprivate ReentrantLock lock=new ReentrantLock();\t    public void deduct()&#123;//        lock.lock();        try &#123;            Stock stock=this.stockMapper.selectOne(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;,&quot;1001&quot;));            if(stock!=null&amp;&amp;stock.getCount()&gt;0)&#123;                stock.setCount(stock.getCount()-1);                this.stockMapper.updateById(stock);            &#125;        &#125;finally &#123;//          lock.unlock();        &#125;    &#125;&#125;\n\n1.3.2 事务@Service@Scope(value = &quot;prototype&quot;,proxyMode = ScopedProxyMode.TARGET_CLASS)public class StockService &#123;     @Autowired    private StockMapper stockMapper;\tprivate ReentrantLock lock=new ReentrantLock();\t    @Transactional(isolation = Isolation.READ_UNCOMMITTED)    public void deduct()&#123;        lock.lock();        try &#123;            Stock stock=this.stockMapper.selectOne(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;,&quot;1001&quot;));            if(stock!=null&amp;&amp;stock.getCount()&gt;0)&#123;                stock.setCount(stock.getCount()-1);                this.stockMapper.updateById(stock);            &#125;        &#125;finally &#123;            lock.unlock();        &#125;    &#125;&#125;\n\n\n\n1.3.3 集群部署集群部署会导致jvm本地锁失效\n2.sql语句//先修改mapper@Mapperpublic interface StockMapper extends BaseMapper&lt;Stock&gt; &#123;    @Update(&quot;update db_stock set count=count - #&#123;count&#125; where product_code = #&#123;productCode&#125; and count &gt;= #&#123;count&#125;&quot;)    int updataStock(@Param(&quot;productCode&quot;) String productCode, @Param(&quot;count&quot;) Integer count);&#125;\n\n\n\n@Servicepublic class StockService &#123;     @Autowired    private StockMapper stockMapper;    \tpublic void deduct()&#123;            this.stockMapper.updataStock(&quot;1001&quot;,1);    &#125;&#125;\n\n2.1 优点sql锁解决了jvm本地锁三种情况失效的情况\n2.2 缺点1.锁范围问题\n2.同一个商品有多条库存记录        例如 不同表里记载了同一个商品不同属性\n3.无法记录库存变化前后的状态    例如操作前有多少工具，操作后有多少工具。无法展现\n3.悲观锁在MySQL的InnoDB中，预设的Tansaction isolation level 为REPEATABLE READ（可重读）\n在SELECT 的读取锁定主要分为两种方式：\n\nSELECT … LOCK IN SHARE MODE　（共享锁）\nSELECT … FOR UPDATE                     （悲观锁）\n\n这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。\n悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁\n但是SELECT … LOCK IN SHARE MODE　（共享锁）在有一方事务要Update同一个表单时很容易造成死锁现象。\n所以最好用SELECT … FOR UPDATE （悲观锁）\n改造mapper\n@Mapperpublic interface StockMapper extends BaseMapper&lt;Stock&gt; &#123;    @Select(&quot;select * from db_stock where product_code =#&#123;productCode&#125; for update&quot;)    List&lt;Stock&gt; queryStock(String productCode);&#125;\n\n修改service\n@Servicepublic class StockService &#123;     @Autowired    private StockMapper stockMapper;        @Transactional    public void deduct()&#123;        //1.查询库存信息并锁定库存信息        List&lt;Stock&gt; stocks =this.stockMapper.queryStock(&quot;1001&quot;);        //这里取第一个仓库        Stock stock=stocks.get(0);        //2.判断库存是否充足        if (stock!=null &amp;&amp; stock.getCount()&gt;0)&#123;            //3.扣减库存            stock.setCount(stock.getCount()-1);            this.stockMapper.updateById(stock);        &#125;    &#125;&#125;\n\n\n\n4.乐观锁乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则重试。\n使用数据版本（Version）记录机制实现，这是乐观锁最常用的实现 方式。一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新。\n给db_stock表添加version字段：\n\n同时记得需要给Stock实体类添加version属性。\n代码实现\n@Servicepublic class StockService &#123;    @Autowired   private StockMapper stockMapper;       public void deduct()&#123;        //1.查询库存信息并锁定库存信息        List&lt;Stock&gt; stocks =this.stockMapper.selectList(new QueryWrapper&lt;Stock&gt;().eq(&quot;product_code&quot;,&quot;1001&quot;));        //这里取第一个仓库        Stock stock=stocks.get(0);        //2.判断库存是否充足        if (stock!=null &amp;&amp; stock.getCount()&gt;0)&#123;            //3.扣减库存            stock.setCount(stock.getCount()-1);            Integer version=stock.getVersion();            stock.setVersion(stock.getVersion() +1);            if (this.stockMapper.update(stock,new UpdateWrapper&lt;Stock&gt;().eq(&quot;id&quot;,stock.getId()).eq(&quot;version&quot;,version))==0)&#123;                //如果更新失败，则进行重试                try &#123;                    Thread.sleep(20);                &#125; catch (InterruptedException e) &#123;                &#125;                this.deduct();            &#125;        &#125;&#125;\n\n\n\n5. mysql锁总结性能：一个sql &gt; 悲观锁 &gt; jvm锁 &gt; 乐观锁\n如果追求极致性能、业务场景简单并且不需要记录数据前后变化的情况下。\n​        优先选择：一个sql\n如果写并发量较低（多读），争抢不是很激烈的情况下优先选择：乐观锁\n如果写并发量较高，一般会经常冲突，此时选择乐观锁的话，会导致业务代码不间断的重试。\n​        优先选择：mysql悲观锁\n不推荐jvm本地锁。       性能：一个sql &gt; 悲观锁 &gt; jvm锁 &gt; 乐观锁\n","tags":["mysql","锁"]},{"title":"nginx入门","url":"/2022/04/12/nginx%E5%85%A5%E9%97%A8/","content":"nginx简介先看官网的介绍.NGINX应用程序平台是一套产品，它们共同构成了企业创建具有性能、可靠性、安全性和规模的应用程序所需的核心。NGINX应用平台包括用于负载均衡和应用程序交付的NGINX Plus、用于安全的NGINX App Protect，以及用于运行应用程序代码的NGINX单元，所有这些都由NGINX Controller监控和管理。它的功能有1.作为web服务器 （本篇着重讲解，其余的日后整理）2.正向代理3.反向代理4.负载均衡5.动静分离\nnginx的安装下载地址 （记得下载stable长期稳定版）\nnginx的常用命令和配置文件nginx -s signalsignal：stop — fast shutdownquit — graceful shutdownreload — reloading the configuration filereopen — reopening the log files\n注意：输入命令前要加上可执行文件,如:\n./sbin/nginx -s stop\nnginx.conf编写listen：80如果配置项直接就是listen 80，那么相当于默认监听该端口下的所有地址，即*.80。\n查看进程ps -ef|grep nginx\n\n\ndocker run  -d -it --name jeecg_nginx -p 2233:2233 --restart=always -v /data/nginx_cn_en_pu/nginx/logs/nginx:/var/log/nginx -v /data/nginx_cn_en_pu/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /data/nginx_cn_en_pu/nginx/conf.d:/etc/nginx/conf.d -v /data/nginx_cn_en_pu/nginx/html:/usr/share/nginx/html nginx","tags":["centos/linux","web服务器"]},{"title":"opencv图像变换","url":"/2022/01/11/opencv%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2/","content":"图片处理图片处理四个步骤 1.load 2.info 3.resize 4.check\n共同代码：\nimport cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeprint(imgInfo)height=imgInfo[0]width=imgInfo[1]mode=imgInfo[2]        #颜色\n图片缩放将长高等比例缩小\ndstHeight=int(height*0.5)           #等比例缩小dstWidth=int(width*0.5)dst=cv2.resize(img,(dstHeight,dstWidth))\n图片剪切dst=img[100:200,0:300]            #从多少像素切到多少像素\n\n图片移位使用warpAffine()函数移位matShift=np.float32([[1,0,100],[0,1,200]])         #2*3dst=cv2.warpAffine(img,matShift,(height,width))      #1-data  2-mat  3-info\nwarpAffine变换矩阵实现图像移位\nvoid cv::warpAffine     (   InputArray      src,        OutputArray     dst,        InputArray      M,        Size    dsize,        int     flags = INTER_LINEAR,        int     borderMode = BORDER_CONSTANT,        const Scalar &amp;      borderValue = Scalar()     )\n参数解释：. src: 输入图像. dst: 输出图像，尺寸由dsize指定，图像类型与原图像一致. M: 2X3的变换矩阵. dsize: 指定图像输出尺寸. flags: 插值算法标识符，有默认值INTER_LINEAR，如果插值算法为WARP_INVERSE_MAP, \nfor循环移动像素移位dst = np.zeros(img.shape,np.uint8)height = imgInfo[0]width = imgInfo[1]for i in range(0,height):    for j in range(0,width-100):        dst[i,j+100]=img[i,j]\n\n图片镜像newImgInfo=(height*2,width,mode)dst=np.zeros(newImgInfo,np.uint8)         #设置画板for i in range(0,height):                 #for 循环转置像素    for j in range(0,width):        dst[i,j]=img[i,j]        dst[height*2-i-1,j]=img[i,j]for i in range(0,width):    dst[height,i]=(0,0,255)      #BGR\n图片缩放img=cv2.imread(&#x27;image0.jpg&#x27;,1)cv2.imshow(&#x27;src&#x27;,img)matScale=np.float32([[0.5,0,0],[0,0.5,0]])dst=cv2.warpAffine(img,matScale,(int(width/2),int(height/2)))\n\n仿射变换matSrc=np.float32([[0,0],[0,height-1],[width-1,0]])matDst=np.float32([[50,50],[300,height-200],[width-300,100]])matAffine=cv2.getAffineTransform(matSrc,matDst)dst=cv2.warpAffine(img,matAffine,(width,height))\n\n旋转变化matRotate = cv2.getRotationMatrix2D((height*0.5,width*0.5),45,1)dst = cv2.warpAffine(img,matRotate,(height,width))\ngetRotationMatrix2D函数调用形式\nMat getRotationMatrix2D(Point2f center, double angle, double scale)\n参数详解：\nPoint2f center：表示旋转的中心点double angle：表示旋转的角度double scale：图像缩放因子","categories":["机器学习","opencv"],"tags":["机器学习","opencv","图片处理"]},{"title":"python字典的浅拷贝和深拷贝","url":"/2022/08/23/python%E5%AD%97%E5%85%B8%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","content":"写脚本遇到的一个小知识\n浅拷贝a.copy()\n其作用是返回一个对字典d进行浅拷贝而得到的新字典。\nstu1=&#123;&#x27;姓名&#x27;:&#x27;小明&#x27;,&#x27;年龄&#x27;:19,&#x27;score&#x27;:&#123;&#x27;python&#x27;:95&#125;&#125;stu2=stu1  #直接赋值，此时stu2和stu1指向同一个字典对象stu3=stu1.copy() #使用copy方法进行浅拷贝print(&#x27;stu1、stu2和stu3的内存地址分别为：&#x27;,id(stu1),id(stu2),id(stu3))# 2665578033656 2665578033656 2665580572960stu1[&#x27;name&#x27;]=&#x27;马红&#x27; #将stu1中键为name的元素的值修改为#&#x27;马红&#x27;print(&#x27;stu1的值为：&#x27;,stu1)#stu1的值为： &#123;&#x27;姓名&#x27;: &#x27;小明&#x27;, &#x27;年龄&#x27;: 19, &#x27;score&#x27;: &#123;&#x27;python&#x27;: 95&#125;, &#x27;name&#x27;: &#x27;马红&#x27;&#125;print(&#x27;stu2的值为：&#x27;,stu2)stu2的值为： &#123;&#x27;姓名&#x27;: &#x27;小明&#x27;, &#x27;年龄&#x27;: 19, &#x27;score&#x27;: &#123;&#x27;python&#x27;: 95&#125;, &#x27;name&#x27;: &#x27;马红&#x27;&#125;print(&#x27;stu3的值为：&#x27;,stu3)stu3的值为： &#123;&#x27;姓名&#x27;: &#x27;小明&#x27;, &#x27;年龄&#x27;: 19, &#x27;score&#x27;: &#123;&#x27;python&#x27;: 95&#125;&#125;\n\n\n\n\n\n深拷贝a.deepcopy()\n深拷贝不仅使得原有字典对象和生成的字典对象对应不同的内存空间，而且使得两个字典对象中的可变类型元素对应不同的内存空间，从而使得两个字典对象完全独立。其作用是根据字典d进行深拷贝创建一个新的字典对象并返回。\nimport copy #导入copy模块stu1=&#123;&#x27;name&#x27;:&#x27;李晓明&#x27;,&#x27;age&#x27;:19,&#x27;score&#x27;:&#123;&#x27;python&#x27;:95,&#x27;math&#x27;:92&#125;&#125;stu2=copy.deepcopy(stu1) #使用deepcopy方法进行深拷贝print(&quot;stu1和stu2的内存地址分别为：&quot;, id(stu1), id(stu2))#2135839142392 2136735144048print(&quot;stu1[&#x27;score&#x27;]和stu2[&#x27;score&#x27;]的内存地址分别为：&quot;,id(stu1[&#x27;score&#x27;]), id(stu2[&#x27;score&#x27;]))#2135839142320 2136716170080stu1[&#x27;score&#x27;][&#x27;python&#x27;]=100print(&#x27;stu1的值为：&#x27;,stu1)stu1的值为： &#123;&#x27;name&#x27;: &#x27;李晓明&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: &#123;&#x27;python&#x27;: 100, &#x27;math&#x27;: 92&#125;&#125;print(&#x27;stu2的值为：&#x27;,stu2)stu2的值为： &#123;&#x27;name&#x27;: &#x27;李晓明&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: &#123;&#x27;python&#x27;: 95, &#x27;math&#x27;: 92&#125;&#125;\n\n\n\n结论深拷贝不仅使得原有字典对象和生成的字典对象对应不同的内存空间，而且使得两个字典对象中的可变类型元素对应不同的内存空间，从而使得两个字典对象完全独立。\n","tags":["python","浅拷贝深拷贝"]},{"title":"rancher入门","url":"/2022/03/30/rancher%E5%85%A5%E9%97%A8/","content":"第一章  什么是rancherRancher是一个开源的企业级全栈化容器部署及管理平台。随着Kubernetes在市场上的崛起，Rancher 专门部署和管理在任何提供商的任何地方运行的Kubernetes集群。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。\nrancher又以下四部分组成\n基础设施编排Rancher可以使用任何公有云或者私有云的Linux主机资源。Linux主机可以是虚拟机，也可以是物理机。Rancher仅需要主机有CPU，内存，本地磁盘和网络资源。从Rancher的角度来说，一台云厂商提供的云主机和一台自己的物理机是一样的。\nRancher为运行容器化的应用实现了一层灵活的基础设施服务。Rancher的基础设施服务包括网络， 存储， 负载均衡， DNS和安全模块。Rancher的基础设施服务也是通过容器部署的，所以同样Rancher的基础设施服务可以运行在任何Linux主机上。\n容器编排与调度很多用户都会选择使用容器编排调度框架来运行容器化应用。Rancher包含了当前全部主流的编排调度引擎，例如Docker Swarm， Kubernetes， 和Mesos。同一个用户可以创建Swarm或者Kubernetes集群。并且可以使用原生的Swarm或者Kubernetes工具管理应用。\n除了Swarm，Kubernetes和Mesos之外，Rancher还支持自己的Cattle容器编排调度引擎。Cattle被广泛用于编排Rancher自己的基础设施服务以及用于Swarm集群，Kubernetes集群和Mesos集群的配置，管理与升级。\n应用商店Rancher的用户可以在应用商店里一键部署由多个容器组成的应用。用户可以管理这个部署的应用，并且可以在这个应用有新的可用版本时进行自动化的升级。Rancher提供了一个由Rancher社区维护的应用商店，其中包括了一系列的流行应用。Rancher的用户也可以创建自己的私有应用商店。\n企业级权限管理Rancher支持灵活的插件式的用户认证。支持Active Directory，LDAP， Github等 认证方式。 Rancher支持在环境级别的基于角色的访问控制 (RBAC)，可以通过角色来配置某个用户或者用户组对开发环境或者生产环境的访问权限。\n下图展示了Rancher的主要组件和功能：\n第二章  rancher安装和介绍快速部署 Rancher 和 Kubernetes 集群的方式共有三种：\n\n一种是在 Amazon EKS 上部署 Rancher\n另一种是在虚拟机上部署 Rancher，支持的虚拟机厂商包括：AWS、DigitalOcean、Azure、Google Cloud Platform 和 Vagrant。\n采用在已有虚拟机上手动部署（也是本文采用的方式）\n\n相关名词介绍Rancher Server： 是用于管理和配置 Kubernetes 集群。你可以通过 Rancher Server 的 UI 与下游 Kubernetes 集群进行交互。\n**RKE（Rancher Kubernetes Engine)**：是经过认证的 Kubernetes 发行版，它拥有对应的 CLI 工具可用于创建和管理 Kubernetes 集群。在 Rancher UI 中创建集群时，它将调用 RKE 来配置 Rancher 启动的 Kubernetes 集群。\n**K3s (轻量级 Kubernetes)**： 和 RKE 类似，也是经过认证的 Kubernetes 发行版。它比 RKE 更新，更易用且更轻量化，全部组件都在一个小于 100 MB 的二进制文件中。从 Rancher v2.4 开始，Rancher 可以安装在 K3s 集群上。\nRKE2是一个完全合规的 Kubernetes 发行版，专注于安全和合规性。\nRancherD是安装 Rancher 的新工具，从 Rancher v2.5.4 开始支持。它是一个实验性功能。RancherD 是一个二进制文件，它首先启动一个 RKE2 Kubernetes 集群，然后在集群上安装 Rancher Server Helm chart。\n常规pull rancher镜像docker pull rancher/server\n\n运行docker run -d --restart=unless-stopped -p 8080:8080 rancher/server\n\n\n第三章  如何通过ui界面管理(暂时使用1.6版本，以后会更新)\n点击添加主机\n根据步骤操作\n1 安装docker\n2 UDP端口测试\n#先确定是否装有nc服务which nc#用法:nc -vuz &lt;目标服务器 IP&gt; &lt;待测试端口&gt;# 参数说明：-v 详细输出（用两个-v可得到更详细的内容）-u 使用UDP传输协议-z 让nc只扫描端口，不发送任何的数据\n\n3 在主机上增加标签，起个名字\n4 设置此台主机ip\n5 cv到另一台主机上运行rancher\nrancher文档rancher官网\n","categories":["centos/linux","rancher"],"tags":["centos","docker","rancher"]},{"title":"pytorch的loss.backward","url":"/2022/09/06/pytorch%E7%9A%84loss-backward/","content":"反向传播loss.backward()顾名思义，就是将损失loss向输入测进行反向传播，同时对于需要进行的梯度计算的所有变量x（requies_grad-True）,计算梯度\nd/dx loss,并将其累积到梯度x。grad中备用，即：x.grad=x.grad+d/dx loss\noptimizer.step()优化器对x的值进行更新，例如随机梯度下降SGD\noptimzer.zero_grad()清除优化器上所有x的x.grad，在每次loss.backward()之前，不要忘记使用，否则之前的梯度将会累积。\n例子x=torch.tensor([1.,2.],requires_grad=True)# x:tensor([1.,2.],requires_grad=True)y=100*x# y: tensor([100.,200.],grad_fn=&lt;SumBackward0&gt;)loss=y.sunm()# y: tensor([300.],grad_fn=&lt;SumBackward0&gt;)print(x.grad)    #none  反向传播前  梯度不存在loss.backward()print(x.grad)     #x的梯度为 tensor([100.，100.]optim=torch.optim.SGD([x],lr=0.001)print(x)    # x:tensor([1.,2.],requires_grad=True)optim.step()print(x)    # x:tensor([0.9000,1.9000],requires_grad=True)\n\n","tags":["pytorch","loss"]},{"title":"rancher管理服务器","url":"/2022/04/22/rancher%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":""},{"title":"redis6配置以及新数据类型","url":"/2022/09/25/redis6%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"1.redis配置1.1 Units单位配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit。大小写不敏感\n\n1.2  ###INCLUDES包含###类似jsp中的include，多实例的情况可以把公用的配置文件提取出来。\n\n1.3 网络相关配置1. bind\n默认情况bind=127.0.0.1只能接受本机的访问请求\n\n不写的情况下，无限制接受任何ip地址的访问\n\n生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉\n\n如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应\n\n\n2. protected-mode将本机访问保护模式设置no\n3.port端口号，默认6379\n4.tcp-backlog\n设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。\n\n在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。\n\n注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果\n\n\n\n5.timeout一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。\n6. tcp-keepalive\n对访问客户端的一种心跳检测，每个n秒检测一次。\n\n单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 \n\n\n1.4 GENERAL通用1. daemonize\n是否为后台进程，设置为yes\n\n守护进程，后台启动\n\n\n2. pidfile\n存放pid文件的位置，每个实例会产生一个不同的pid文件\n\n\n3.loglevel\n指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice\n\n四个级别根据使用阶段来选择，生产环境选择notice 或者warning\n\n\n4.logfile日志文件名称\n5.database 16设定库的数量 默认16，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id\n1.5 SECURITY 安全\n临时密码：在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。\n\nconfig get requirepassconfig set requirepass &quot;123456&quot;auth 123456# true\n\n\n\n\n永久密码：需要再配置文件中进行设置。\n\n\n\n1.6 LIMITS限制1. maxclients\n设置redis同时可以与多少个客户端进行连接。\n 默认情况下为10000个客户端。\n如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。\n\n2.maxmemory\n建议****必须设置****，否则，将内存占满，造成服务器宕机\n设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。\n 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。\n但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。\n\n3.maxmemory-policy\nvolatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）\nallkeys-lru：在所有集合key中，使用LRU算法移除key\nvolatile-random：在过期集合中移除随机的key，只对设置了过期时间的键 \nallkeys-random：在所有集合key中，移除随机的key \nvolatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key\nnoeviction：不进行移除。针对写操作，只是返回错误信息\n\n4. maxmemory-samples\n设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。\n一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。\n\n2.发布和订阅\nRedis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。\n\nRedis 客户端可以订阅任意数量的频道。\n\n\n\n\n# 打开一个客户端订阅channel1SUBSCRIBE channel1# 打卡另一个客户端publish channel1 hello# 第一个客户端就可以看到消息\n\n\n\n\n\n3.redis6的新增数据类型1.Bitmaps现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图\n \n合理地使用操作位能够有效地提高内存使用率和开发效率。\n​    Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：\n（1） Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。\n（2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。\n \n2. HypertLogLog在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。\n但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。\n解决基数问题有很多种方案：\n（1）数据存储在MySQL表中，使用distinct count计算不重复个数\n（2）使用Redis提供的hash、set、bitmaps等数据结构来处理\n以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。\n能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n什么是基数?\n比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。\n*命令*\n1、pfadd \n（1）格式\npfadd &lt; element&gt; [element …]  添加指定元素到 HyperLogLog 中\n \n（2）实例\n \n​    将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。\n2、pfcount\n（1）格式\npfcount [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可\n \n（2）实例\n \n3、pfmerge\n（1）格式\npfmerge [sourcekey …]  将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得\n \n（2）实例\n \n3. Geospatial*简介*\nRedis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。\n*命令*\n1、geoadd\n（1）格式\ngeoadd&lt; longitude&gt; [longitude latitude member…]  添加地理位置（经度，纬度，名称）\n \n（2）实例\ngeoadd china:city 121.47 31.23 shanghai\ngeoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing\n \n两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。\n有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。\n当坐标位置超出指定范围时，该命令将会返回一个错误。\n已经添加的数据，是无法再次往里面添加的。\n2、geopos  \n（1）格式\ngeopos   [member…]  获得指定地区的坐标值\n \n（2）实例\n \n3、geodist\n（1）格式\ngeodist  [m|km|ft|mi ]  获取两个位置之间的直线距离\n \n（2）实例\n获取两个位置之间的直线距离\n \n单位：\nm 表示单位为米[默认值]。\nkm 表示单位为千米。\nmi 表示单位为英里。\nft 表示单位为英尺。\n如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位\n4、georadius\n（1）格式\ngeoradius&lt; longitude&gt;radius m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素\n经度 纬度 距离 单位\n（2）实例\n \n","tags":["redis6"]},{"title":"redis6基础操作","url":"/2022/09/25/redis6%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","content":"1. jedis测试// Jedis所需要的jar包&lt;dependency&gt;&lt;groupId&gt;redis.clients&lt;/groupId&gt;&lt;artifactId&gt;jedis&lt;/artifactId&gt;&lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;\n\n注意事项\n\n禁用Linux的防火墙：Linux(CentOS7)里执行命令\n\n*systemctl stop/disable firewalld.service*  \n\nredis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no\n\n\n常用操作// 测试程序package com.atguigu.jedis;import redis.clients.jedis.Jedis;public class Demo01 &#123;public static void main(String[] args) &#123;Jedis jedis = new Jedis(&quot;192.168.137.3&quot;,6379);String pong = jedis.ping();System.out.println(&quot;连接成功：&quot;+pong);jedis.close();&#125;&#125;\n\n// 相关数据类型//     Keyjedis.set(&quot;k1&quot;, &quot;v1&quot;);jedis.set(&quot;k2&quot;, &quot;v2&quot;);jedis.set(&quot;k3&quot;, &quot;v3&quot;);Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;);System.out.println(keys.size());for (String key : keys) &#123;System.out.println(key);&#125;System.out.println(jedis.exists(&quot;k1&quot;));System.out.println(jedis.ttl(&quot;k1&quot;));                System.out.println(jedis.get(&quot;k1&quot;));//Stringjedis.mset(&quot;str1&quot;,&quot;v1&quot;,&quot;str2&quot;,&quot;v2&quot;,&quot;str3&quot;,&quot;v3&quot;);System.out.println(jedis.mget(&quot;str1&quot;,&quot;str2&quot;,&quot;str3&quot;));//ListList&lt;String&gt; list = jedis.lrange(&quot;mylist&quot;,0,-1);for (String element : list) &#123;System.out.println(element);&#125;//setjedis.sadd(&quot;orders&quot;, &quot;order01&quot;);jedis.sadd(&quot;orders&quot;, &quot;order02&quot;);jedis.sadd(&quot;orders&quot;, &quot;order03&quot;);jedis.sadd(&quot;orders&quot;, &quot;order04&quot;);Set&lt;String&gt; smembers = jedis.smembers(&quot;orders&quot;);for (String order : smembers) &#123;System.out.println(order);&#125;jedis.srem(&quot;orders&quot;, &quot;order02&quot;);//hashjedis.hset(&quot;hash1&quot;,&quot;userName&quot;,&quot;lisi&quot;);System.out.println(jedis.hget(&quot;hash1&quot;,&quot;userName&quot;));Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();map.put(&quot;telphone&quot;,&quot;13810169999&quot;);map.put(&quot;address&quot;,&quot;atguigu&quot;);map.put(&quot;email&quot;,&quot;abc@163.com&quot;);jedis.hmset(&quot;hash2&quot;,map);List&lt;String&gt; result = jedis.hmget(&quot;hash2&quot;, &quot;telphone&quot;,&quot;email&quot;);for (String element : result) &#123;System.out.println(element);&#125;//zsetjedis.hset(&quot;hash1&quot;,&quot;userName&quot;,&quot;lisi&quot;);System.out.println(jedis.hget(&quot;hash1&quot;,&quot;userName&quot;));Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();map.put(&quot;telphone&quot;,&quot;13810169999&quot;);map.put(&quot;address&quot;,&quot;atguigu&quot;);map.put(&quot;email&quot;,&quot;abc@163.com&quot;);jedis.hmset(&quot;hash2&quot;,map);List&lt;String&gt; result = jedis.hmget(&quot;hash2&quot;, &quot;telphone&quot;,&quot;email&quot;);for (String element : result) &#123;System.out.println(element);&#125;\n\n\n\n\n\n2. redis和springboot整合2.1 相关配置&lt;!-- redis --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- spring2.X集成redis所需common-pool2--&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;&lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt;\n\n#Redis服务器地址spring.redis.host=192.168.140.136#Redis服务器连接端口spring.redis.port=6379#Redis数据库索引（默认为0）spring.redis.database= 0#连接超时时间（毫秒）spring.redis.timeout=1800000#连接池最大连接数（使用负值表示没有限制）spring.redis.lettuce.pool.max-active=20#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-wait=-1#连接池中的最大空闲连接spring.redis.lettuce.pool.max-idle=5#连接池中的最小空闲连接spring.redis.lettuce.pool.min-idle=0\n\n2.2 redisconfig类@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        template.setConnectionFactory(factory);//key序列化方式        template.setKeySerializer(redisSerializer);//value序列化        template.setValueSerializer(jackson2JsonRedisSerializer);//value hashmap序列化        template.setHashValueSerializer(jackson2JsonRedisSerializer);        return template;    &#125;    @Bean    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);//解决查询缓存转换异常的问题        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);// 配置序列化（解决乱码的问题）,过期时间600秒        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofSeconds(600))                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))                .disableCachingNullValues();        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)                .cacheDefaults(config)                .build();        return cacheManager;    &#125;&#125;\n\n2.3 测试一下@RestController@RequestMapping(&quot;/redisTest&quot;)public class RedisTestController &#123;    @Autowired    private RedisTemplate redisTemplate;    @GetMapping    public String testRedis() &#123;        //设置值到redis        redisTemplate.opsForValue().set(&quot;name&quot;,&quot;lucy&quot;);        //从redis获取值        String name = (String)redisTemplate.opsForValue().get(&quot;name&quot;);        return name;    &#125;&#125;\n\n\n\n3. 事务和锁机制3.1 redis事务定义Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\nRedis事务的主要作用就是串联多个命令防止别的命令插队。\n3.2 Multi、Exec、discard从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。\n\n3.3 事务的错误处理组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。\n\n如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。\n\n3.5 事务冲突的问题悲观锁\n*悲观锁(Pessimistic Lock)*, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。****传统的关系型数据库里边就用到了很多这种锁机制*，比如*行锁*，*表锁*等，*读锁*，*写锁****等，都是在做操作之前先上锁。\n乐观锁\n*乐观锁(Optimistic Lock)**,* 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。****乐观锁适用于多读的应用类型，这样可以提高吞吐量****。Redis就是利用这种check-and-set机制实现事务的。\nWATCH key [key …]在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务*执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。*\n\nunwatch取消 WATCH 命令对所有 key 的监视。\n如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。\nhttp://doc.redisfans.com/transaction/exec.html\n3.6 Redis 事务三特性Ø 单独的隔离操作 \n事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 \nØ 没有隔离级别的概念 \n队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行\nØ 不保证原子性 \n事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 \n3.7 Redis——事务——秒杀案例4. 持久化 (RDB、AOF)RDB（Redis DataBase）1.如何执行的Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。*RDB的缺点是*****最后一次持久化后的数据可能丢失****。\n2.fork\nFork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“****写时复制技术****”\n 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。\n\n3.持久化流程\n4. 配置*dump.rdb文件*\n在redis.conf中配置文件名称，默认为dump.rdb\n \n*配置位置*\nrdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下\ndir “/myredis/“\n \n*如何触发RDB快照；保持策略*\n*配置文件中默认的快照配置*\n \n*命令**save VS bgsave*\nsave ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。\n*bgsave：**Redis**会在后台异步进行快照操作， 快照同时还可以响应客户端请求。*\n可以通过lastsave 命令获取最后一次成功执行快照的时间\n*flushall**命令*\n执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义\n*###SNAPSHOTTING**快照**###*\n*Save*\n格式：save 秒钟 写操作次数\nRDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，\n*默认是1分钟内改了**1**万次，或**5**分钟内改了**10**次，或**15**分钟内改了**1**次。*\n禁用\n不设置save指令，或者给save传入空字符串\n*stop-writes-on-bgsave-error*\n \n当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.\n*rdbcompression* *压缩文件*\n \n对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。\n如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.\n*rdbchecksum* *检查完整性*\n \n在存储快照后，还可以让redis使用CRC64算法来进行数据校验，\n但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能\n推荐yes.\n*rdb**的备份*\n先通过config get dir  查询rdb文件的目录 \n将*.rdb的文件拷贝到别的地方\nrdb的恢复\n\n关闭Redis\n\n先把备份的文件拷贝到工作目录下 cp dump2.rdb dump.rdb\n\n启动Redis, 备份数据会直接加载\n\n\n5总结*优势*\n\n适合大规模的数据恢复\n\n对数据完整性和一致性要求不高更适合使用\n\n节省磁盘空间\n\n恢复速度快\n\n\n \n*劣势*\n\nFork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑\n\n虽然Redis在fork时使用了*写时拷贝技术*,但是如果数据庞大时还是比较消耗性能。\n\n在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。\n\n\n*如何停止*\n动态停止RDB：redis-cli config set save “”#save后给空值，表示禁用保存策略\n*小总结*\n \nAOF（Append Only File）1.如何执行的以*日志*的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(*读操作不记录*)， ****只许追加文件但不可以改写文件****，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作\n2.流程（1）客户端的请求写命令会被append追加到AOF缓冲区内；\n（2）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；\n（3）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；\n（4）Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的；\n \n3.配置*AOF默认不开启*可以在redis.conf中配置文件名称，默认为 appendonly.aof\nAOF文件的保存路径，同RDB的路径一致。\n*\\ AOF和RDB同时开启，redis听谁的？*AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）\n*AOF启动修复恢复*\nAOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。\n\n正常恢复\n\n 修改默认的appendonly no，改为yes\n 将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)\n恢复：重启redis然后重新加载\n\n\n异常恢复\n\n 修改默认的appendonly no，改为yes\n 如遇到****AOF文件损坏*，通过/usr/local/bin/*redis-check-aof–fix appendonly.aof****进行恢复\n 备份被写坏的AOF文件\n恢复：重启redis，然后重新加载\n\n\n\n*** AOF同步频率设置***\nappendfsync always\n\n始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好\n\nappendfsync everysec\n\n每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。\n\nappendfsync no\n\nredis不主动进行同步，把同步时机交给操作系统。\n*\\ Rewrite压缩*1是什么：AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof\n2重写原理，如何实现重写AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。\nno-appendfsync-on-rewrite：\n如果 no-appendfsync-on-rewrite=yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）\n​    如果 no-appendfsync-on-rewrite=no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）\n触发机制，何时重写\nRedis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发\n重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。 \nauto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）\nauto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。\n例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB\n系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,\n如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。 \n3、重写流程（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。\n（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。\n（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。\n（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。\n（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。\n \n4.总结*优势* \nn 备份机制更稳健，丢失数据概率更低。\nn 可读的日志文本，通过操作AOF稳健，可以处理误操作。\n*劣势*n 比起RDB占用更多的磁盘空间。\nn 恢复备份速度要慢。\nn 每次读写都同步的话，有一定的性能压力。\nn 存在个别Bug，造成恢复不能。\n*小总结* \n持久化哪一个好\n官方推荐两个都启用。\n\n如果对数据不敏感，可以选单独用RDB。\n\n不建议单独用 AOF，因为可能会出现Bug。\n\n如果只是做纯内存缓存，可以都不用。\n\n\n官网建议：\nRDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储\n\nAOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. \n\nRedis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大\n\n只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.\n\n同时开启两种持久化方式\n\n在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.\n\nRDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ \n\n建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。\n\n性能建议\n\n\n因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。 如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。\n\n","tags":["redis","jedis","redistemplate"]},{"title":"redis主从复制以及集群","url":"/2022/09/25/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%9B%86%E7%BE%A4/","content":"主从复制概括主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。\n特点：\n\n读写分离，性能扩展\n\n容灾快速恢复\n\n\n\n配置拷贝多个redis.conf文件// 新建redis6379.conf文件include /myredis/redis.confpidfile /var/run/redis_6379.pidport 6379dbfilename dump6379.rdb// 新建redis6380.conf文件include /myredis/redis.confpidfile /var/run/redis_6380.pidport 6380dbfilename dump6380.rdb// 新建redis6381.conf文件include /myredis/redis.confpidfile /var/run/redis_6381.pidport 6381dbfilename dump6381.rdb\n\n然后分别启动  \n\ninfo replication//打印主从复制的相关信息\n\n配从库slaveof  &lt;ip&gt;&lt;port&gt;//成为某个实例的从服务器,在80  81上执行\n\n在主机上写，在从机上可以读取数据，此时在从机上写将报错\n\n如果挂掉\n主机挂掉，重启就行，一切如初\n\n从机重启需重设：slaveof 127.0.0.1 6379\n\n可以将配置增加到文件中。永久生效。\n\n\n\n常用三点以及复制原理一主二仆切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？\n从机是否可以写？set可否？ \n主机shutdown后情况如何？从机是上位还是原地待命？\n主机又回来了后，主机新增记录，从机还能否顺利复制？ \n其中一台从机down后情况如何？依照原有它能跟上大部队吗？\n \n薪火相传上一个Slave可以是下一个slave的Master，Slave同样可以接收其他 slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。\n用 slaveof  \n中途变更转向:会清除之前的数据，重新建立拷贝最新的\n风险是一旦某个slave宕机，后面的slave都没法备份\n主机挂了，从机还是从机，无法写数据了\n \n \n反客为主当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。\n用 slaveof  no one  将从机变为主机。\n \n复制原理\nSlave启动成功连接到master后会发送一个sync命令\n\nMaster接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步\n\n全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n\n增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步\n\n但是只要是重新连接master,一次完全同步（全量复制)将被自动执行\n\n\n \n哨兵模式概括****反客为主的自动版****，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库\n部署故障恢复主从复制redis集群概括配置故障恢复主从复制","tags":["蜗牛学院笔记","redis6","主从复制","redis集群"]},{"title":"redis分布式锁","url":"/2022/09/25/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","content":""},{"title":"redis概括","url":"/2022/09/19/redis%E6%A6%82%E6%8B%AC/","content":"Redis简介Redis（==Re==mote ==Di==ctionary ==S==erver），即远程字典服务。\nRedis是用C语言编写的完全开源的、遵守BSD协议的、高性能的key-value数据库\nBSD是”Berkeley Software Distribution”的缩写，意思是“伯克利软件发行版”。\nBSD开源协议是一个给予使用者很大自由的协议。可以自由地使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。BSD鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用者在BSD代码上开发商业软件，因此BSD是对商业集成很友好的协议。\n我们先通过一个电商业务场景来对redis有一个整体的认识\n\n商品基本信息（名称、价格、厂商），存放于MySQL\n\n商品附加信息（描述、详情、评论），存放于MongoDB\n\n图片信息，存放于分布式文件系统 \n\n搜索关键字，ES、Lucene、solr\n\n热点信息，高频，波段性存放于redis\n\n\n(1) 比如2020年初，“口罩”就是热点信息\n(2) 比如情人节前后，“玫瑰花”、“巧克力”就是热点信息\n特点\n单线程，Redis是单线程的，所以Redis的所有单个操作都是原子性的。多个操作也能由事务来保证原子性（通过MULTI和EXEC这两个指令），因此在redis层面无需考虑并发所带来的影响\n\n性能极高，读110000/s，写81000/s\n\n丰富的数据类型：String、List、Hash，Set及Ordered Set\n\n支持持久化\n\n支持横向扩展\n\n丰富的特性，redis还支持publish/subscribe，通知，key过期等等特性\n\nredis的单个key和value的最大大小都是512M\n\n\n当redis接收到多个并发请求的时候，redis会把这多个并发请求存入一个队列中，然后按照队列的先后顺序，一个一个地执行命令。也就是redis同一时刻只执行一条命令，只有一条命令执行完了，才会继续执行下一条命令。 所以redis中的incr和decr是绝对的原子操作，绝对的线程安全。尽管redis是单线程模型的，但性能还是很高。\n\n\n \n\n\n\nredis作为单线程模型为什么性能还很高？\n\n纯内存访问：数据存放在内存中，内存的响应时间是极高的！\n\n非阻塞式的I/O操作：redis采用epoll作为I/O多路复用技术的实现\n\n采用单线程自然也就避免了线程的上下文切换和锁带来的开销\n\n\n关于epoll和I/O多路复用，是另外一个方向的讨论了，这里就不再深入探讨了。\n举个例子尽量解释一下吧。有一道算法题，一个班30个学生每人都在做这道题，做完的需要检查。检查方式有：1. 派30个老师，各自站在1个学生的旁边，时刻关注着学生的答题进度，一旦学生作答完毕，就进行检查，检查完毕后，对应的老师就撤了。这就是阻塞IO2. 派1个老师，哪个学生做完了就举手，就让这个老师检查答案，检查完一个学生的答案后，还继续等待下一个学生的答案。这基本上就是多路复用的体现了。 也就是一个线程可以同时监听多个套接字，哪个套接字准备好数据了，就读取哪个套接字的数据，然后发送到目的地，然后继续监听多个套接字。如下图所示，\\在同一个线程里面， 通过拨开关的方式，来同时传输多个I/O流\n\n\n\n\n\n\nRedis基本配置及通用命令基本配置拷贝redis.conf到安装目录\n\nredis默认不是后台运行的，可以通过修改该配置项为yes，让redis在后台运行daemonize no\n\n2.当redis以守护进程方式运行时，redis会把pid写入/var/run/redis_6379.pid文件中，也可以自己指定写入的位置pidfile /var/run/redis_6379.pid\n\nredis监听的端口port 6379\n\n设置redis连接密码，如果配置了连接密码，则客户端在连接redis时需要通过AUTH  命令来提供密码requirepass foobared\n\n绑定的主机地址，目前这样的配置这意味着只有当前机器才能连接redis服务bind 127.0.0.1如果设置bind为0.0.0.0则表示运行任何远程机器访问当前redis服务\n修改redis.conf配置文件，开启后台运行，将bind设置为0.0.0.0，然后再次启动redis服务，这次启动redis服务的时候，要指定redis配置文件的位置\n\n注意：在运行redis-server时，需要指定配置文件\n./redis-server ./redis.conf\n\n\n\n通用命令在linux中的命令redis-server:启动redis服务redis-cli：启动客户端通过配置文件进行连接。\nredis-benchmark：模拟数据读写的测试。在redis里运行的命令ping：测试是否连接成功\nselect 0-15：选择数据库（总共是16个数据库，默认是第0个）\n\nkeys 查看所有键\nset key value设置键值对，如果键已存在，会覆盖\nget key根据key获取value，如果key不存在就返回nil\ndel key返回删除的个数\ndbsize查看当前库中键值对的数量\nkeys * 查看当前库中所有键值对的内容\nkeys u查看当前库中所有key为u的键值对内容\nkeys u?查看当前库中所有以u开头，且后面只跟一列的键值对内容\nexists 判断某个键值是否存在\nmove  移动键值对到指定的数据库\nttl 显示指定的key还要过多久就过期（-1表示永不过期，-2表示已经过期）\nexpire  10设置指定的key，还能存活10秒\npersist key移除key的过期时间，key将持久保持\nflushdb清空当前库中的所有键值对 \nflushall清空所有库中的所有键值对 \ntype 查看指定key的类型\n\nString类型\nstrlen 查看指定key对应的值的长度\n127.0.0.1:6379&gt; set k1 abcfsdfsadfOK127.0.0.1:6379&gt; get k1&quot;abcfsdfsadf&quot;127.0.0.1:6379&gt; strlen k1(integer) 11127.0.0.1:6379&gt;\ngetrange   截取字符串\n127.0.0.1:6379&gt; get k1&quot;abcfsdfsadf&quot;127.0.0.1:6379&gt; getrange k1 3 5&quot;fsd&quot;127.0.0.1:6379&gt; getrange k1 2 4&quot;cfs&quot;127.0.0.1:6379&gt;\nsetrange   覆盖字符串的某一部分\n127.0.0.1:6379&gt; get k1&quot;abcfsdfsadf&quot;127.0.0.1:6379&gt; setrange k1 0 xyz(integer) 11127.0.0.1:6379&gt; get k1&quot;xyzfsdfsadf&quot;\nsetex   设置键值对的同时，指定过期时间\n127.0.0.1:6379&gt; setex k2 10 xyzOK127.0.0.1:6379&gt; ttl k2(integer) 6127.0.0.1:6379&gt; ttl k2(integer) 2127.0.0.1:6379&gt; ttl k2(integer) -2\nsetnx  指定的键值不存在时，才能成功完成本次操作，且返回1如果键值已经存在，则返回0\n127.0.0.1:6379&gt; setnx k3 abc(integer) 1127.0.0.1:6379&gt; get k3&quot;abc&quot;127.0.0.1:6379&gt; setnx k3 xye(integer) 0127.0.0.1:6379&gt; get k3&quot;abc&quot;\nmset k1 v1 k2 v2 k3 v3 批量设置key value\n127.0.0.1:6379&gt; mset k5 v5 k6 v6 k7 v7OK127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k1&quot;3) &quot;k5&quot;4) &quot;k6&quot;5) &quot;k7&quot;\nmget k1 k2 k3 批量取出值\n127.0.0.1:6379&gt; mget k5 k6 k71) &quot;v5&quot;2) &quot;v6&quot;3) &quot;v7&quot;\nmsetnx k1 v1 k2 v2 k3 v3注意在mset时，如果一部分键存在，一部分键不存在，则整个操作都是失败的！\n127.0.0.1:6379&gt; msetnx k1 v1 k2 v2 k3 v3(integer) 1127.0.0.1:6379&gt; mget k1 k2 k31) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k1 v1 k2 v2 k3 v3(integer) 0127.0.0.1:6379&gt; msetnx k1 v11 k2 v21 k3 v31(integer) 0127.0.0.1:6379&gt; mget k1 k2 k31) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; msetnx k11 v11 k12 v21 k3 v31(integer) 0127.0.0.1:6379&gt; mget k111) (nil)\ngetset key value先获取该key对应的值，然后再设置该key对应的值\n127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; getset k1 v11&quot;v1&quot;127.0.0.1:6379&gt; get k1&quot;v11&quot;127.0.0.1:6379&gt;\nincr key将指定key的value原子性地递增1，如果key不存在，其初始值为0，再incr之后其值为1。如果value的值不能转型成整型，如“hello”，该操作将执行失败并返回相应的信息。\n127.0.0.1:6379&gt; set num 1OK127.0.0.1:6379&gt; get num&quot;1&quot;127.0.0.1:6379&gt; incr num(integer) 2127.0.0.1:6379&gt; get num&quot;2&quot;\ndecr key将指定key的value原子性地递减1，如果key不存在，其初始值为0，再decr之后其值为-1。如果value的值不能转型成整型，如“hello”，该操作将执行失败并返回相应的信息。\n127.0.0.1:6379&gt; decr num2(integer) -1127.0.0.1:6379&gt; get num2&quot;-1&quot;\nappend key value拼凑字符串，如果该key存在，则在原有的value后追加该值如果该key不存在，则重新创建一个key/value\n127.0.0.1:6379&gt; append k1 123(integer) 6127.0.0.1:6379&gt; get k1&quot;v11123&quot;\nincrby key increment\n127.0.0.1:6379&gt; incrby num3 10(integer) 10127.0.0.1:6379&gt; get num3&quot;10&quot;\ndecrby key decrement \n127.0.0.1:6379&gt; decrby num3 3(integer) 17127.0.0.1:6379&gt; get num3&quot;17&quot;\n\nList类型list类型底层采取双向链表存储结果实现\n\n创建\nlpush list1 a b c d 在链表头加入元素 –&gt; d c b a\nrpush list2 a b c d 在链表尾加入元素 –&gt; a b c d\n注意，不同元素之间要用空格隔开，而不是逗号!\nlinsert list before|after foo bar \n在list中foo元素之前|之后插入bar元素\n \n127.0.0.1:6379&gt; lpush list2 1 2 3 4(integer) 4127.0.0.1:6379&gt; lrange list2 0 -1  #-1代表最后一个值1) &quot;4&quot;2) &quot;3&quot;3) &quot;2&quot;4) &quot;1&quot;\n查询lrange list1 start end其中start从0开始，查询结果包含start和end其中start和end也可以写成负数，-1表示倒数第1个元素，-2 表示倒数第2个元素llen list 获取列表中元素的个数lindex list 0 获取列表中指定下标的元素 \n\n修改lset list 2 foo 将list中，下标为2的元素内容替换成foorpop\n127.0.0.1:6379&gt; lset list1 2 fooOK127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;c&quot;3) &quot;foo&quot;4) &quot;a&quot;\nltrim list   截取指定范围的值后，再把截取出的值赋给list\n127.0.0.1:6379&gt; lrange list1 0 -11) &quot;list2&quot;2) &quot;d&quot;3) &quot;c&quot;4) &quot;foo&quot;5) &quot;a&quot;127.0.0.1:6379&gt; ltrim list1 1 2OK127.0.0.1:6379&gt; lrange list1 0 -11) &quot;d&quot;2) &quot;c&quot;\n删除lpop 删除并返回链表左侧的元素\n127.0.0.1:6379&gt; lpop list1&quot;d&quot;127.0.0.1:6379&gt; lrange list1 0 -11) &quot;c&quot;\nrpop 删除并返回链表右侧的元素b\n127.0.0.1:6379&gt; lrange list2 0 -11) &quot;4&quot;2) &quot;3&quot;3) &quot;2&quot;4) &quot;1&quot;127.0.0.1:6379&gt; rpop list2&quot;1&quot;127.0.0.1:6379&gt; lrange list2 0 -11) &quot;4&quot;2) &quot;3&quot;3) &quot;2&quot;\nblpop key timeout删除并返回链表左侧的元素，若列表中没有元素，阻塞等待timeout秒，如果timeout=0，则一直阻塞等待b\n127.0.0.1:6379&gt; blpop list1 5(nil)(5.01s)127.0.0.1:6379&gt; blpop list1 01) &quot;list1&quot;2) &quot;d&quot;(109.14s)\nbrpop key timeout删除并返回链表右侧的元素，若列表中没有元素，阻塞等待timeout秒，如果timeout=0，则一直阻塞等待\n\nlrem list 0 a  删除list中的所有a元素lrem list 1 a  从左向右，删除list中的1个a元素\n127.0.0.1:6379&gt; lrem list1 2 a(integer) 2127.0.0.1:6379&gt; lrange list1 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;d&quot; 5) &quot;c&quot; 6) &quot;b&quot; 7) &quot;d&quot; 8) &quot;c&quot; 9) &quot;b&quot;10) &quot;a&quot;11) &quot;d&quot;12) &quot;c&quot;13) &quot;b&quot;14) &quot;a&quot;15) &quot;d&quot;16) &quot;c&quot;17) &quot;c&quot;127.0.0.1:6379&gt; lrem list1 -2 c(integer) 2127.0.0.1:6379&gt; lrange list1 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;d&quot; 5) &quot;c&quot; 6) &quot;b&quot; 7) &quot;d&quot; 8) &quot;c&quot; 9) &quot;b&quot;10) &quot;a&quot;11) &quot;d&quot;12) &quot;c&quot;13) &quot;b&quot;14) &quot;a&quot;15) &quot;d&quot;\nlrem list -2 a 从右向左，删除list中的2个a元素 \n 利用list的命令，可以实现一些常用的数据结构\nStack = LPUSH + LPOP –&gt; FILO\nQueue = LPUSH +RPOP\nBlocking MQ（阻塞队列）= LPUSH + BRPOP\n关于redis中的list数据类型要注意的地方\n\n它是一个字符串链表，可以从left或right端添加值\n\n如果键不存在，则创建新的链表\n\n如果键已存在，则新增内容\n\n如果值全部移除，则对应的键也就消失了\n\n操作链表中的头元素和尾元素效果都很高，但是如果操作的是链表中间的元素，效率就很低\n\nlist可以对数据进行分页操作，通常第一页的数据来自于redis的list，第2页及更多的信息是通过数据库来获取的\n\n\nlist应用场景：微信朋友圈点赞，要求按照点赞顺序显示好友信息  \n\n\nHash类型Redis中的Hash类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于（但不限于）存储对象的信息。每一个Hash可以存储4294967295个键值对。\n\nhset key field value\nhmset key field value [field2 value2 …]\nhget key field\nhmget key fields\nhgetall key\nhdel key field\ndel key 删除整个hash\nhlen key \nhincrby key field increment  （注意，没有hdecriby）\nhexists key field \nhkeys key 获取key中的所有field\nhvals key 获取key中的所有value \n\nhash应用场景：存储对象。说到存储对象，string可以存储对象，下面简单讨论一下。\n\nstring存储对象，讲究整体性。要么更新整体，要么获取整体。偏向于“读为主”\n\nhash存储对象，可以用field的对象的各个属性分开，所以针对于更新操作显得更加灵活。偏向于“改为主”\n\n\nhash应用场景：电商购物车\n\n以用户id为key：cart:用户id\n\n以商品id为field\n\n以商品数量为value\n购物车操作\n1.添加商品：hset cart:1001 1044 1\n  2. 增加数量：hincrby cart:1001 1044 1\n  3. 商品总数：hlen cart:1001\n  4. 删除商品：hdel cart:1001 1044\n  5. 获取所有商品：hgetall cart:1001 \n\n\n\n当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要再查一次数据库，为了解决这个问题，可以这样重构：\n每条购物车中的商品记录保存成两条field:field1用于保存购买数量商品id:nums –&gt; 数量field2专用于保存购物车中显示的信息，包含文字描述，图片地址，价格等等商品id:info –&gt; json数据\nZset(sorted set) 有序集合简介Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。\n不同之处是有序集合的每个成员都关联了一个*评分（score）*,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。\n因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。\n访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。\n常用命令zadd  &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…将一个或多个 member 元素及其 score 值加入到有序集 key 当中。zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;  [WITHSCORES]   返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。zrangebyscore key minmax [withscores] [limit offset count]返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 zrevrangebyscore key maxmin [withscores] [limit offset count]               同上，改为从大到小排列。 zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;      为元素的score加上增量zrem  &lt;key&gt;&lt;value&gt;删除该集合下，指定值的元素 zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;统计该集合，分数区间内的元素个数 zrank &lt;key&gt;&lt;value&gt;返回该值在集合中的排名，从0开始。\n\n案例案例：如何利用zset实现一个文章访问量的排行榜？\n \n","tags":["蜗牛学院笔记","redis"]},{"title":"root用户启动firefox报错","url":"/2022/03/29/root%E7%94%A8%E6%88%B7%E5%90%AF%E5%8A%A8firefox%E6%8A%A5%E9%94%99/","content":"今天遇见了个很神奇的报错centos中admin账户可以打开火狐浏览器，而权限更高的root不可以\n报错如下：\n解决方案cd /run/user/1000# 然后修改权限就行了chown -R root ./\n\n然后就解决了，可能会警告，但是最后发现可以打开了。\n"},{"title":"servlet概括","url":"/2022/07/08/servlet%E6%A6%82%E6%8B%AC/","content":"servlet的生命周期？三个生命周期方法：init()：初始化方法service()：执行方法destroy()：销毁方法\n1.当我们通过浏览器第一次访问一个servlet的时候，servlet对象会被创建，    随后会执行init方法，随后会执行service方法\n2.当我们通过浏览器重复的访问同一个servlet的时候，servlet对象不会再创建，也不会再执行in法，    但是会执行service方法\n3.当我们正常的关闭服务器，就会执行destroy方法\n如何将Servlet对象的创建提前呢？需要配置：\n&lt;servlet&gt;\t&lt;servlet-name&gt;servletDemo02&lt;/servlet-name&gt;\t&lt;servlet-class&gt;com.servlet.ServletDemo02&lt;/servlet-class&gt;\t&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;\n\n\n注意：load-on-startup的默认值为-1，也就说当我们第一次访问servlet的时候才会创建对象，调用init方法      数字用来给多个servlet的创建时机排序的\nservlet的参数配置？等第三阶段学习三大框架整合的时候会用上\n&lt;servlet&gt;\t&lt;servlet-name&gt;servletDemo04&lt;/servlet-name&gt;\t&lt;servlet-class&gt;com.servlet.ServletDemo04&lt;/servlet-class&gt;\t&lt;init-param&gt;\t\t&lt;param-name&gt;name&lt;/param-name&gt;\t\t&lt;param-value&gt;tom&lt;/param-value&gt;\t&lt;/init-param&gt;\t&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;\n@Overridepublic void init(ServletConfig config) throws ServletException &#123;\t//获取到xml中配置的参数的数据\t\t\t\tString value = config.getInitParameter(&quot;name&quot;);\tSystem.out.println(value);&#125;\n\nservlet的注解配置//@WebServlet(urlPatterns= &#123;&quot;/servletDemo05&quot;&#125;)//@WebServlet(urlPatterns = &quot;/servletDemo05&quot;)//@WebServlet(value = &quot;/servletDemo05&quot;)@WebServlet(&quot;/servletDemo05&quot;)\n\nservlet的体系结构通用接口javax.servlet.Servlet 接口    通用的servlet接口    – javax.servlet.GenericServlet 抽象类    通用的servlet实现类        – javax.servlet.http.HttpServlet 抽象类    具体的实现类(针对http协议的servlet实现类)        –javax.servlet.ftp.FtpServlet        – javax.servlet.ppp.PPPServlet\n适配器设计模式interface A&#123;    public void aaaa();    public void bbbb();    public void cccc();    public void dddd();    public void eeee();                                                           &#125;//类B充当了适配器abstract class B interface A&#123;//抽象类中不一定有抽象方法，有抽象方法的一定是抽象类    @Override    public void aaa()&#123;    &#125;    .    .    .    @Override    public void eeee()&#123;    &#125;class C extends B&#123;\t//这样方法C就不用重写A中的所有方法\tpublic void bbb()&#123;\t&#125;&#125;\n\nIO流底层的设计模式装饰设计模式\n适配器设计模式\n\nservlet的实现方式？方式一：实现Servlet接口class ServletDemo1 implements Servlet &#123;\t&#125;\n方式二：继承GenericServletclass ServletDemo02 extends GenericServlet &#123;\t\t\t&#125;\n方式三：继承HttpServletclass ServletDemo03 extends HttpServlet &#123;\t\t\t&#125;\t注意：重写doGet()和doPost()\n\nservlet的url-pattern的配置？    @WebServlet(&quot;路径&quot;)\n\n    路径的写法有哪些？\n        1. /XXX\n            @WebServlet(&quot;/servletDemo1&quot;)\n            @WebServlet(&quot;/aaa&quot;)\n            \n        2. /XXX/OOO\n            @WebServlet(&quot;/aaa/servletDemo08&quot;)\n            @WebServlet(&quot;/aaa/bbb&quot;)\n            @WebServlet(&quot;/aaa/bbb/*&quot;)\n            \n        3. *.do\n            @WebServlet(&quot;*.do&quot;)\n            @WebServlet(&quot;*.aaa&quot;)\n            \n    注意：\n        1. /*.do\n            /和*.do是不能写在一起的\n            \n        2. /*/servletDemo08\n            此时的*不是通配符\n        \n        3. /\n\n","tags":["servlet"]},{"title":"shiro安全框架","url":"/2022/07/27/shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/","content":""},{"title":"softmax+交叉熵应用与多标签问题","url":"/2022/09/01/softmax-%E4%BA%A4%E5%8F%89%E7%86%B5%E5%BA%94%E7%94%A8%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98/","content":""},{"title":"simhash求文本相似度","url":"/2022/06/12/simhash%E6%B1%82%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6/","content":"定义SimHash是一种局部敏感hash，它也是Google公司进行海量网页去重使用的主要算法。\n传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统的hash算法产生的两个签名，如果原始内容在一定概率下是相等的；如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大。所以传统的Hash是无法在签名的维度上来衡量原内容的相似度，而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里估计大家就明白了，我们使用的simhash就算把文章中的字符串变成 01 串也还是可以用于计算相似度的，而传统的hash却不行。\n基本流程1.分词2.hash3.加权4.合并5.降维","tags":["机器学习","文本相似度"]},{"title":"sklearn.svm.SVC中kernel参数说明","url":"/2022/01/16/sklearn.svm.SVC%E4%B8%ADkernel%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/","content":"sklearn.svm.SVC中kernel参数说明线性核函数kernel=‘linear’采用线性核kernel=’linear’的效果和使用sklearn.svm.LinearSVC实现的效果一样，但采用线性核时速度较慢，特别是对于大数据集，推荐使用线性核时使用LinearSVC\n多项式核函数kernel=‘poly’degree代表d，表示多项式的次数gamma为多项式的系数，coef0代表r，表示多项式的偏置注：coef0是sklearn.svm.SVC中的参数\n径向基核函数kernel=‘rbf’可以将gamma理解为支持向量影响区域半径的倒数，gamma越大，支持向量影响区域越小，决策边界倾向于只包含支持向量，模型复杂度高，容易过拟合；gamma越小，支持向量影响区域越大，决策边界倾向于光滑，模型复杂度低，容易欠拟合；gamma的取值非常重要，即不能过小，也不能过大\nsigmod核函数kernel=‘sigmod’coef0控制r,sigmod核函数是线性核函数经过tanh函数映射变化\n","categories":["计算机","机器学习","scikit-learn","SVM"],"tags":["机器学习","scikit-learn","SVC"]},{"title":"springboot多环境配置","url":"/2022/07/11/springboot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"多环境配置因为一个项目可能不同的环境下运行\n开发  dev\n生成  prod\n测试  test\na、多环境配置文件，激活其中一个使用需要做三套配置。\n编写一个主配置文件\napplication.yml\n三个环境的配置文件\napplication-dev.yml\napplication-prod.yml\napplication-test.yml\nspring:\tprofiles:\t\tactive: dev|prod|test\n\nb、在主配置文件中编写三个环境的配置spring:  profiles:    active: dev---server:  port: 9091spring:  profiles: dev1---spring:  profiles: test1server:  port: 9092\n\n\n此时，还可以激活其他配置文件\n\n","tags":["springboot","多环境配置"]},{"title":"springboot日志配置","url":"/2022/07/11/springboot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/","content":"SpringBoot日志配置\n记录应用系统曰志主要有三个原因 记录操作轨迹、监控系统运行状况、回溯系统故障。​当系统发生线上问题时，完整的现场日志有助于工程师快速定位问题。\n\n日志规范\n推荐的日志文件命名方式为appName_logType_logName.log 其中 logType为日志类型，推荐分类有 stats monitor visit等， logName 为日志描述。这种命名的好处是通过文件名就可以知道曰志文件属于什么应用，什么类型 ，什么目的，也有利于归类查找。例如， mppserver 应用中单独监控时区转换异常的日志文件名定义为mppserver__monitor_timeZoneConvert.log\n\n避免无效日志打印\n生产环境禁止输出 DEBUG 曰志且有选择地输出 INFO日志。使用 INFO、WARN 级别来记录业务行为信息时，一定要控制日志输出量，以免磁盘空间不足。同时要为曰志文件设置合理的生命周期及时清理过期的日志。避免重复打印，务必在日志配置文件中设置 additivity=false\n\n日志框架分类与选择\n\n\n日志门面(日志的抽象层)\n日志实现\n\n\n\nJCL(Jakarta Commons Logging)（2014年后不再维护） jboss-logging （不适合企业项目开发使用） SLF4J(Simple Logging Facade for java)\nLog4j JUL(java.util.logging)（java.util.logging)(担心被抢市场,推出的) Log4j2( apache开发的很强大,借了log4j的名,但很多框架未适配上) Logback(Log4j同一个人开发的新框架,做了重大升级)\n\n\n[\n日志门面\n 门面设计模式是面向对象设计模式中的一种，日志框架采用的就是这种模式，类似JDBC 的设计理念。它只提供一套接口规范，自身不负责日志功能的实现。目的是让使用者不需要关注底层具体是哪个日志库来负责日志打印及具体的使用细节等。目前用得最为广泛的曰志门面有两种 slf4j和commons -logging\n\n日志库\n 负责实现日志相关功能，主流日志库有三个，分别为：log4j、log-jdk（java.util.logging.Logger）、logback。logback是最晚出现的，与log4j同一个作者，是log4j的升级版且本身实现了slf4j的接口。\n\n日志适配器\n 分为：日志门面适配器（日志库适配slf4j），日志库适配器（slf4j适配日志库）。\n\n\n日志门面适配器\n\n老工程用的日志库没有实现slf4j接口，如log4j；这时候工程里想使用slf4j+log4j的模式，就额外需要一个适配器（slf4j+log4j12）来解决接口不兼容问题\n\n\n日志库适配器\n\n老工程直接使用日志库API完成日志打印，要改成业界标准的门面模式（如slf4j+logback），但是老工程代码打印日志地方太多难以改动，这是就需要一个适配器来完成从旧日志库的API到slf4j的路由，这样在不改动原有代码的情况下也能使用slf4j来统一管理日志（如：log4j-over-slf4j），后续自由替换具体日志库也不成问题。\n\n\nSpring Boot 采用了 slf4j+logback 的组合形式，Spring Boot也提供对JUL、log4j2、Logback提供了默认配置\n\n\n\nSpringBoot默认日志配置新建springboot项目，引入web启动项，其他默认即可\npackage com.woniu.logdemo.controller;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @Author: Panda * @Date: 2020-07-17 10:16 * @Description: */@RequestMapping@RestControllerpublic class LogController &#123;        private static final Logger logger  = LoggerFactory.getLogger(LogController.class);        @GetMapping(&quot;/log&quot;)    public String logTest1(String name) &#123;       // 由低到高：trace &lt; debug &lt; info &lt; warn &lt; error        //2. Spring Boot默认设定的是 info 级别日志，(日志默认级别也称为root级别)。可修改默认级别日志：logging.level.root=级别名        //3. 可以进行调整日志级别，设定某个级别后，就只打印设定的这个级别及后面高级别的日志信息。没有指定级别的就用SpringBoot默认规定的级别：root级别        //4. 可修改指定包的日志级别：指定某个包下面的所有日志级别：logging.level.包名=级别名        logger.info(&quot;------------info--------------&#123;&#125;&quot;,name);        logger.error(&quot;------------error--------------&#123;&#125;&quot;,name);        logger.debug(&quot;------------debug--------------&#123;&#125;&quot;,name);        logger.trace(&quot;------------trace--------------&#123;&#125;&quot;,name);        logger.warn(&quot;------------warn--------------&#123;&#125;&quot;,name);        return &quot;log test...&quot;+name;    &#125;&#125;\n\n修改日志默认配置\n\n\nlogging.file.name\nlogging.file.path\n示例\n说明\n\n\n\n(none)\n(none)\n\n只在控制台输出\n\n\n指定文件名\n(none)\ndemo.log\n输出到当前项目根路径下的 demo.log 文件中\n\n\n(none)\n指定目录\nlogs/log_woniu\n输出到当前项目所在磁盘根路径下的/logs/log_woniu目录中的 spring.log 文件中\n\n\n指定文件名\n指定目录\n\n当两个同时指定时,采用的是logging.file.name 指定。推荐使用logging.file.name 设置即可，因为它可自定义文件名\n\n\nlogging:  file:    name: demo.log#    path: logs/log_woniu\n\n修改日志输出格式logging:  file:    name: demo.log  pattern:    console: &#x27;%clr(%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n)&#x27;    file: &#x27;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&#x27;#    path: logs/log_woniu\n\n\n注意：如上，yml文件中首尾加上单引号可解决识别不了%的问题，properties不需要加\n\n分析日志底层实现    &lt;dependency&gt;         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;/dependency&gt; spring-boot-starter-web 中引入了 spring-boot-starter 启动器     &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.3.1.RELEASE&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;spring-boot-starter 中引入了 spring-boot-starter-logging 日志启动器     &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;      &lt;version&gt;2.3.1.RELEASE&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;spring-boot-starter-logging 日志启动器 采用的是 logback 日志框架     &lt;dependency&gt;      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;\n\n\n总结：SpringBoot中默认日志启动器为 spring-boot-starter-logging ，默认采用的是 logback 日志框架\n\n\n在 spring-boot-2.3.1.RELEASE.jar! \\org\\springframework\\boot\\logging\\logback\\base.xml \n\n自定义日志配置自定义Logback日志配置\n\n在类路径下，存放对应日志框架的自定义配置文件即可；SpringBoot就不会使用它默认的日志配置文件了\n\n\n\n\nLogging System\nCustomization\n\n\n\nLogback\nlogback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy\n\n\nLog4j2\nlog4j2-spring.xml or log4j2.xml\n\n\nJDK (Java Util Logging)\nlogging.properties\n\n\n\nlogback.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot; scan=&quot;false&quot; scanPeriod=&quot;60 seconds&quot;&gt;    &lt;property name=&quot;LOG_HOME&quot; value=&quot;./logs/logback&quot;/&gt;    &lt;property name=&quot;appName&quot; value=&quot;woniu-logDemo&quot;/&gt;    &lt;!-- 定义控制台输出 --&gt;    &lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; - [%thread] - %-5level - %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;appender name=&quot;appLogAppender&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 指定日志文件的名称 --&gt;        &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt;            &lt;MaxHistory&gt;30&lt;/MaxHistory&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;        &lt;/rollingPolicy&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;!-- 日志输出级别 --&gt;    &lt;logger name=&quot;org.springframework&quot; level=&quot;debug&quot;  additivity=&quot;false&quot;/&gt;    &lt;logger name=&quot;com.woniu.logdemo&quot; level=&quot;debug&quot;/&gt;    &lt;root level=&quot;INFO&quot;&gt;        &lt;appender-ref ref=&quot;stdout&quot;/&gt;        &lt;appender-ref ref=&quot;appLogAppender&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;\n\n更换为log4j2日志实现修改pom依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;&lt;!-- 去掉springboot默认配置 --&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;!-- 引入log4j2依赖 --&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration monitorInterval=&quot;5&quot;&gt;    &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;    &lt;!--变量配置--&gt;    &lt;Properties&gt;        &lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt;        &lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt;        &lt;property name=&quot;LOG_PATTERN&quot; value=&quot;%date&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot; /&gt;        &lt;!-- 定义日志存储的路径 --&gt;        &lt;property name=&quot;FILE_PATH&quot; value=&quot;./logs/log4j2&quot; /&gt;        &lt;property name=&quot;FILE_NAME&quot; value=&quot;woniu-log4j2-demo&quot; /&gt;    &lt;/Properties&gt;    &lt;appenders&gt;        &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!--输出日志的格式--&gt;            &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt;            &lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;        &lt;/console&gt;        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;        &lt;File name=&quot;Filelog&quot; fileName=&quot;$&#123;FILE_PATH&#125;/test.log&quot; append=&quot;false&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt;        &lt;/File&gt;        &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;        &lt;RollingFile name=&quot;RollingFileInfo&quot; fileName=&quot;$&#123;FILE_PATH&#125;/info.log&quot; filePattern=&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;info&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt;            &lt;Policies&gt;                &lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;            &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt;        &lt;/RollingFile&gt;        &lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;        &lt;RollingFile name=&quot;RollingFileWarn&quot; fileName=&quot;$&#123;FILE_PATH&#125;/warn.log&quot; filePattern=&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt;            &lt;Policies&gt;                &lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;            &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt;        &lt;/RollingFile&gt;        &lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;        &lt;RollingFile name=&quot;RollingFileError&quot; fileName=&quot;$&#123;FILE_PATH&#125;/error.log&quot; filePattern=&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout pattern=&quot;$&#123;LOG_PATTERN&#125;&quot;/&gt;            &lt;Policies&gt;                &lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;10MB&quot;/&gt;            &lt;/Policies&gt;            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;            &lt;DefaultRolloverStrategy max=&quot;15&quot;/&gt;        &lt;/RollingFile&gt;    &lt;/appenders&gt;    &lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;    &lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;    &lt;loggers&gt;        &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;        &lt;logger name=&quot;org.mybatis&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/logger&gt;        &lt;!--监控系统信息--&gt;        &lt;!--若是additivity设为false，则 子Logger 只会在自己的appender里输出，而不会在 父Logger 的appender里输出。--&gt;        &lt;Logger name=&quot;org.springframework&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/Logger&gt;        &lt;root level=&quot;info&quot;&gt;            &lt;appender-ref ref=&quot;Console&quot;/&gt;            &lt;appender-ref ref=&quot;Filelog&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileWarn&quot;/&gt;            &lt;appender-ref ref=&quot;RollingFileError&quot;/&gt;        &lt;/root&gt;    &lt;/loggers&gt;&lt;/configuration&gt;\n\n补充\n若日志配置文件名字随意取得，需要在springboot配置文件yml中指明：\n\nlogging:  file:    name: demo.log  pattern:    console: &#x27;%clr(%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n)&#x27;    file: &#x27;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-5level &gt;&gt;&gt; %logger&#123;50&#125; &gt;&gt;&gt; %msg%n&#x27;#    path: logs/log_woniu  config: classpath:logconfig.xml\n\n\n","tags":["蜗牛学院笔记","springboot","日志"]},{"title":"springboot概括","url":"/2022/07/11/springboot%E6%A6%82%E6%8B%AC/","content":"简述SpringBoot就是Spring\n因为SSM整合：\n1、很多样板式的配置。\n2、添加jar包需要繁琐的记忆。\nSpringBoot帮我们解决以下问题：\n1、减少配置，只做变化的配置\n2、使用场景启动器（mybatis），不用添加jar包\n3、避免jar包版本冲突。\n4、SpringBoot帮我们管理添加了注解的Bean。\n5、自动配置。\nSpringBoot入门案例1、新建Spring项目​    选择SpringBoot的版本。\n​    添加一个web场景启动器\n​    spring-boot-starter-web\n2、新建Controllerpackage com.woniu.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123;    @RequestMapping(&quot;test&quot;)    public String test()&#123;        System.out.println(&quot;UserController.test&quot;);        return null;    &#125;&#125;\n\n为什么SpringBoot可以简化开发1、pom.xml父项目\n​    spring-boot-starter-parent\n​    spring-boot-dependencies\n​    版本仲裁中心\n​    定义子项目添加jar包的版本。\n场景启动器\n​    批量添加一个场景的jar包\n2、启动类@SpringBootApplication\n​    @SpringBootConfiguration\n​            当前的启动类\n​            \n​    @EnableAutoConfiguration\n​        @AutoConfigurationPackage\n​                完成自己编写的类的Spring管理。\n​        @Import({AutoConfigurationImportSelector.class})\n​                完成Spring和SpringMVCxml配置的内容，自动配置\nSpringBoot常用配置yaml是对象结构化的描述，会对描述进行归类。\nserver:  port: 8082spring:  datasource:    driver-class-name:    url:    username:    password:  mvc:    view:      prefix:      suffix: \n\n\n\n\n\n配置文件类型及位置SpringBoot中可以使用application.properties，也可以使用application.yml。\n配置文件可以放在项目根目录、根目录下的config目录、resouce根目录、resource\\config目录\n项目根目录下的config目录 =&gt;项目根目录=&gt;resource\\config目录=&gt;resouce根目录\n加载配置文件中的数据a、通过注解@ConfigurationProperties读取配置文件1、编写yml或者properties文件定义一些属性\ndata-source:  url: jdbc:mysql:///demo  username: root  password: 123\n\n\n\n2、编写一个封装类读取配置文件的信息该类需要被Spring容器管理\n类中的属性与配置文件的属性一致\n在类上添加注解@ConfigurationProperties(prefix=”属性的前缀”)\npackage com.woniu.controller;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = &quot;data-source&quot;)public class Data &#123;    private String url;    private String username;    private String password;    public String getUrl() &#123;        return url;    &#125;    public void setUrl(String url) &#123;        this.url = url;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    @Override    public String toString() &#123;        return &quot;Data&#123;&quot; +                &quot;url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; +                &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +                &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\nb、通过@Value读取配置文件1、先声明yml或者propertiesdata-source.url=abcdata-source.username=rootdata-source.password=root\n\n2、声明对应的封装类在属性上添加@Value\n通过${属性前缀.属性}获取属性的值放到被注解的封装类属性中。\npackage com.woniu.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Componentpublic class Data2 &#123;    @Value(&quot;$&#123;data-source.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;data-source.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;data-source.password&#125;&quot;)    private String password;    public String getUrl() &#123;        return url;    &#125;    public void setUrl(String url) &#123;        this.url = url;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    @Override    public String toString() &#123;        return &quot;Data&#123;&quot; +                &quot;url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; +                &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +                &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n如果配置文件的名字不是默认application，需要在类上添加注解，指定配置文件的位置\n@PropertySource(“classpath:a.properties”)\nSpringBoot热部署1、添加依赖&lt;!--devtools热部署--&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;           &lt;optional&gt;true&lt;/optional&gt;           &lt;scope&gt;true&lt;/scope&gt;       &lt;/dependency&gt;\n\n2、在application.yml中配置重启#配置热部署,如果src/main/java有改变，则重启服务器spring:  devtools:    restart:      enabled: true      additional-paths: src/main/java\n\n3、需要在idea中配置File-Settings-Compiler-Build Project automatically  当修改配置文件，自动重启\n\nctrl + shift + alt + / ,选择Registry,勾上 Compiler autoMake allow when app running\nSpringBoot集成Mybatis1、添加依赖&lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.38&lt;/version&gt;        &lt;/dependency&gt;\n\n2、添加配置spring:  datasource:    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://localhost:3306/demo?characterEncoding=utf8    username: root    password: woniu\n\n3、使用注解扫描dao在主程序类上添加注解@MapperScan(basePackages = &quot;com.woniu.dao&quot;)\n\n4、使用Controller直接访问dao，将数据转成json返回给浏览器\n","tags":["蜗牛学院笔记","springboot"]},{"title":"springboot集成nacos","url":"/2022/05/15/springboot%E9%9B%86%E6%88%90nacos/","content":""},{"title":"springmvc概括","url":"/2022/07/02/springmvc%E6%A6%82%E6%8B%AC/","content":"SpringMVCSpringMVC概述使用SpringMVC替换Servlet\nServlet的问题：\n1、需要判断调用哪个方法。（逻辑需要自己编写）\n2、需要获得request的数据，并且需要手动封装，还要进行类型转换。\n3、跳转和转发数据的代码太繁琐。\n4、通过ajax请求的对象，需要通过fastjson进行转换，并使用相应对象的输出流写出。\n以上问题SpringMVC都给出了解决方案。\n1、添加依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n2、在web.xml中配置前端控制器&lt;!--     前端控制器  --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;         &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;!--      /表示拦截了除了jsp之外所有的请求    --&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;\n\n\n\n3、编写SpringMVC的配置文件（结构和Spring配置文件一致）&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--        映射器  ：找到类中的方法    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;/bean&gt;    &lt;!--        适配器  ：执行类中的方法    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot; &gt;&lt;/bean&gt;    &lt;!--        视图解析器 ：返回所需的文件后缀（jsp,html）    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置Controller    --&gt;    &lt;bean id=&quot;/user&quot; class=&quot;com.woniu.controller.UserController&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\n4、编写Controllerpackage com.woniu.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;/** * @Author: Panda * @Date: 2021/4/23 14:35 * @Description: */public class UserController implements Controller &#123;    @Override    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;        System.out.println(&quot;UserController.handleRequest&quot;);        return null;    &#125;&#125;\n\n\n\n5、通过浏览器访问Controller\nSpringMVC的工作机制\nDispatcherServlet&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--        映射器        BeanNameUrlHandlerMapping        在浏览器中发送/user        通过/user在Spring容器中找到id对应的实例        SimpleUrlHandlerMapping        声明一个映射关系        Properties    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;        &lt;property name=&quot;mappings&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;/user&quot;&gt;userController&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--        适配器        SimpleControllerHandlerAdapter        可以执行实现了Controller接口的控制器        HttpRequestHandlerAdapter        可以执行实现了HttpRequestHandler接口的控制器    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot; &gt;&lt;/bean&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot; &gt;&lt;/bean&gt;    &lt;!--        视图解析器        prefix 从webapp根目录指定        suffix 是后缀    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置Controller    --&gt;    &lt;bean id=&quot;userController&quot; class=&quot;com.woniu.controller.UserController&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\nController的实现使用注解配置Controller\npackage com.woniu.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;/** * @Author: Panda * @Date: 2021/4/23 16:34 * @Description: */@Controllerpublic class UserController3 &#123;    @RequestMapping(&quot;list&quot;)    public ModelAndView list()&#123;        System.out.println(&quot;UserController3.save&quot;);        ModelAndView mav = new ModelAndView();        mav.setViewName(&quot;list&quot;);  //    /list.jsp        User user = new User();        user.setUname(&quot;leon&quot;);        user.setUpwd(&quot;123&quot;);        //request.setAttribute();        mav.addObject(&quot;user&quot;,user);        return  mav;    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--        RequestMappingHandlerMapping        找到注解RequestMapping的值userSave，找到了要执行的方法         &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;&lt;/bean&gt;         &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;&lt;/bean&gt;        &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;可以替换上面两个配置，不仅仅如此    --&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--        视图解析器        prefix 从webapp根目录指定        suffix 是后缀    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\nModelAndView类package com.woniu.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;/** * @Author: Panda * @Date: 2021/4/23 16:34 * @Description: */@Controllerpublic class UserController3 &#123;    @RequestMapping(&quot;list&quot;)    public ModelAndView list()&#123;        System.out.println(&quot;UserController3.save&quot;);        ModelAndView mav = new ModelAndView();        mav.setViewName(&quot;list&quot;);  //    /list.jsp        User user = new User();        user.setUname(&quot;leon&quot;);        user.setUpwd(&quot;123&quot;);        //request.setAttribute();        mav.addObject(&quot;user&quot;,user);        return  mav;    &#125;    @RequestMapping(&quot;list2&quot;)    public ModelAndView list2()&#123;        System.out.println(&quot;UserController3.delete&quot;);        ModelAndView mav = new ModelAndView();        mav.setViewName(&quot;list&quot;);  //    /list.jsp        List&lt;User&gt; list = new ArrayList&lt;&gt;();        User user = new User();        user.setUname(&quot;leon&quot;);        user.setUpwd(&quot;123&quot;);        User user2 = new User();        user2.setUname(&quot;jack&quot;);        user2.setUpwd(&quot;111&quot;);        list.add(user);        list.add(user2);        //request.setAttribute(); 名字默认为类型与泛型的组合 userList        mav.addObject(list);        return  mav;    &#125;    @RequestMapping(&quot;list3&quot;)    public String list3(Model model)&#123;        System.out.println(&quot;UserController3.save&quot;);        List&lt;User&gt; list = new ArrayList&lt;&gt;();        User user = new User();        user.setUname(&quot;leon&quot;);        user.setUpwd(&quot;123&quot;);        User user2 = new User();        user2.setUname(&quot;andy&quot;);        user2.setUpwd(&quot;111&quot;);        list.add(user);        list.add(user2);        model.addAttribute(list);        return  &quot;list&quot;; // /list.jsp    &#125;    @RequestMapping(&quot;list4&quot;)    public String list4()&#123;        return  &quot;redirect:list.jsp&quot;;    &#125;&#125;\n\n\n\n视图解析器概述将Controller的返回值进行解析，到浏览器。\n在SpringMVC中也有很多视图解析器\n\n这时通过视图解析器解析handler返回的值（逻辑视图，转发数据）\nInternalResourceViewResolver会将逻辑视图与prefix和suffix组合成物理视图名，如果逻辑视图返回值中包含redirect:,则进行重定向操作，如果是forward：或者没有前缀，则转发操作。\n\n编写一个视图\npackage com.woniu.controller.a_view;import org.springframework.web.servlet.View;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Map;/** * @Author: Panda * @Date: 2021/4/26 09:42 * @Description: */public class MyView implements View &#123;    private String viewUrl;    public MyView()&#123;    &#125;    public MyView(String viewUrl)&#123;        this.viewUrl = viewUrl;    &#125;    @Override    public String getContentType() &#123;        return null;    &#125;    @Override    public void render(Map&lt;String, ?&gt; map, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        if(viewUrl.startsWith(&quot;redirect:&quot;)) &#123;            httpServletResponse.sendRedirect(viewUrl.split(&quot;:&quot;)[1]);        &#125;else&#123;            for (Map.Entry&lt;String, ?&gt; entry : map.entrySet()) &#123;                httpServletRequest.setAttribute(entry.getKey(), entry.getValue());            &#125;            httpServletRequest.getRequestDispatcher(viewUrl).forward(httpServletRequest, httpServletResponse);        &#125;    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.a_view&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--\t\tBeanNameViewResolver是当前项目的中视图解析器\t\tMyView声明了跳转的方式和数据转发\t--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\npackage com.woniu.controller.a_view;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;/** * @Author: Panda * @Date: 2021/4/23 14:35 * @Description: */@Controllerpublic class UserController&#123;    @RequestMapping(&quot;save&quot;)    public ModelAndView save()&#123;        System.out.println(&quot;UserController.save&quot;);        ModelAndView mav = new ModelAndView();        mav.setView(new MyView(&quot;redirect:abc.jsp&quot;));        mav.addObject(&quot;a&quot;,&quot;123&quot;);        return mav;    &#125;&#125;\n\n\n\n请求映射1、RequestMapping可以声明在类和方法上RequestMapping\n可以声明在类上，如果要访问方法，需要将类的RequestMapping的值与方法上的RequestMapping的值组合访问。\nhttp://localhost:8080/项目名称/类上注解/方法上注解\n\n\n为了防止直接通过浏览器访问jsp页面，将所有页面放到WEB-INF下。只能通过控制器跳转。在视图解析器中的前缀添加WEB-INF。\n\n2、可以根据不同的请求方式，来控制哪种请求可以访问@Controller@RequestMapping(&quot;user&quot;)  // /user/savepublic class UserController &#123;    //method = RequestMethod.POST只有页面通过post传参，才可以访问到这个方法    @RequestMapping(value = &quot;save&quot;,method = RequestMethod.POST)    public String save()&#123;        System.out.println(&quot;UserController.save123&quot;);        return &quot;abc&quot;;    &#125;&#125;\n\n\n浏览器地址栏访问都是Get请求。\n\n3、在RequestMapping中添加params//页面需要传递params中声明的参数，且值必须相等，这时才可以访问该方法@RequestMapping(value = &quot;login&quot;,params = &#123;&quot;token=asdfarwerqwer&quot;&#125;)public String login(String uname,String upwd)&#123;    System.out.println(&quot;UserController.login:&quot;+uname+&quot;:&quot;+upwd);    return &quot;abc&quot;;&#125;\n\n4、在RequestMapping中添加headers//可以在RequestMapping中声明headers,获得页面传递的请求头，从请求头中获得对应的信息，如果该信息相等，允许访问该方法   @RequestMapping(value = &quot;list&quot;,headers = &quot;host=localhost:8080&quot;)  //headers = &quot;host=localhost:8080&quot;只允许本机访问。   public String list()&#123;       System.out.println(&quot;UserController.list&quot;);       return &quot;abc&quot;;   &#125;\n\n5、在RequestMapping中添加占位符@RequestMapping(&quot;login2/&#123;upwd&#125;/&#123;uname&#125;&quot;)//需要使用注解public String login2(@PathVariable(&quot;upwd&quot;) String p,@PathVariable(&quot;uname&quot;) String n)&#123;    System.out.println(&quot;UserController.login2:&quot;+n+&quot;:&quot;+p);    return &quot;abc&quot;;&#125;\n\n\n\n控制器方法入参1、基本数据类型的自动转化2、自动封装数据package com.woniu.controller.c_param;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import java.util.List;/** * @Author: Panda * @Date: 2021/4/23 14:35 * @Description: */@Controllerpublic class UserController &#123;    /**     * 在SpringMVC的Controller中不再需要request.getParameter(),直接在方法的参数中声明即可，要求参数名与表单控件的name一致     * 如果非要不一致，则需要添加注解@RequestParam(&quot;表单的name值&quot;)     * @param name     * @param password     * @return     */    @RequestMapping(&quot;save1&quot;)    public String save1(String name,@RequestParam(&quot;pwd&quot;) String password)&#123;        System.out.println(&quot;UserController.save1:&quot;+name+&quot;:&quot;+password);        return null;    &#125;    //SpringMVC的Controller，可以对数据进行自动转换    @RequestMapping(&quot;save2&quot;)    public String save2(float age)&#123;        System.out.println(&quot;UserController.save2:&quot;+age);  //输出出生年份        return null;    &#125;    //可以将表单的数据自动封装成对象(参数中指定的类型)    @RequestMapping(&quot;save3&quot;)    public String save3(User user)&#123;        System.out.println(&quot;UserController.save3:&quot;+user);  //输出出生年份        return null;    &#125;    //复选框的值可以直接获得为字符串数据,整型数组,如果需要List&lt;Integer&gt;类型,则需要添加注解@RequestParam    @RequestMapping(&quot;save4&quot;)    public String save4(@RequestParam List&lt;Integer&gt; ids)&#123;        System.out.println(&quot;UserController.save4:&quot;+ids.get(0));  //输出出生年份        return null;    &#125;&#125;\n\n&lt;%--  Created by IntelliJ IDEA.  User: Panda  Date: 2021/4/23  Time: 16:48  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;false&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;传递参数到Controller&lt;/h3&gt;   &lt;form action=&quot;save1&quot; method=&quot;post&quot;&gt;       &lt;input name=&quot;name&quot;&gt;       &lt;input name=&quot;pwd&quot;&gt;       &lt;button&gt;submit&lt;/button&gt;   &lt;/form&gt;    &lt;hr&gt;    &lt;h3&gt;传递整型数据&lt;/h3&gt;    &lt;form action=&quot;save2&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;age&quot;&gt;        &lt;button&gt;submit&lt;/button&gt;    &lt;/form&gt;    &lt;hr&gt;    &lt;h3&gt;传递对象数据&lt;/h3&gt;    &lt;form action=&quot;save3&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;uname&quot;&gt;        &lt;input name=&quot;age&quot;&gt;        &lt;button&gt;submit&lt;/button&gt;    &lt;/form&gt;&lt;hr&gt;    &lt;h3&gt;模拟数据自动封装&lt;/h3&gt;    &lt;form action=&quot;userServlet&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;uname&quot;&gt;        &lt;input name=&quot;age&quot;&gt;        &lt;button&gt;submit&lt;/button&gt;    &lt;/form&gt;    &lt;hr&gt;    &lt;h3&gt;传递复选框数据&lt;/h3&gt;    &lt;form action=&quot;save4&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;1&quot;&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;2&quot;&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;3&quot;&gt;        &lt;button&gt;submit&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n模拟自动封装代码\npackage com.woniu.controller.c_param;import java.lang.reflect.Field;import java.util.Map;/** * @Author: Panda * @Date: 2021/4/26 14:30 * @Description: */public class Tools &#123;    public static Object map2Object(Map&lt;String, String[]&gt; parameterMap, Class&lt;?&gt; userClass) &#123;        try &#123;            Object object = userClass.newInstance();            for(Map.Entry&lt;String,String[]&gt; entry:parameterMap.entrySet())&#123;                String key = entry.getKey();        //uname  age                String[] value = entry.getValue();  //admin  25                    Field field = userClass.getDeclaredField(key); //uname                    field.setAccessible(true);                    if(field.getType()==String.class)&#123;                        field.set(object,value[0]);                    &#125;else if(field.getType()==int.class||field.getType()==Integer.class)&#123;                        field.set(object,Integer.parseInt(value[0]));                    &#125;            &#125;            return object;        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n\n\n时间类型参数SpringMVC中默认识别日期格式为yyyy/MM/dd\n其他格式需要自己编写转换类\npackage com.woniu.controller.d_convert;import org.springframework.core.convert.converter.Converter;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @Author: Panda * @Date: 2021/4/26 15:18 * @Description: */public class DateConverter implements Converter&lt;String, Date&gt; &#123;    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);    @Override    public Date convert(String s) &#123;        Date date = null;        try &#123;            date = simpleDateFormat.parse(s);        &#125; catch (ParseException e) &#123;            try &#123;                date = simpleDateFormat2.parse(s);            &#125; catch (ParseException parseException) &#123;                parseException.printStackTrace();            &#125;        &#125;        return date;    &#125;&#125;\n\n将转换类配置到SpringMVC框架中\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.d_convert&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;        &lt;property name=&quot;converters&quot;&gt;            &lt;set&gt;                &lt;bean class=&quot;com.woniu.controller.d_convert.DateConverter&quot;&gt;&lt;/bean&gt;            &lt;/set&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n使用ServletAPIHttpServletRequest\nHttpServletResponse\nHttpSession\nServletContext\nHttpServletRequest，HttpServletResponse，HttpSession对象都可以从方法参数中获取\n@RequestMapping(&quot;login&quot;)public String login(String uname, HttpServletRequest req, HttpServletResponse resp, HttpSession session)&#123;     System.out.println(&quot;UserController.req:&quot;+req);     System.out.println(&quot;UserController.resp:&quot;+resp);     System.out.println(&quot;UserController.session:&quot;+session);     System.out.println(&quot;UserController.application:&quot;+session.getServletContext());     return null;&#125;\n\n\n\nSpringMVC数据校验正则表达式\n​    电话号码格式\n​    邮箱格式\n​    身份证格式等等\n前端数据校验\n后端数据校验\n1、添加依赖&lt;dependency&gt;      &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;      &lt;version&gt;6.0.20.Final&lt;/version&gt;    &lt;/dependency&gt;\n\n2、定义校验规则在封装类上定义校验规则，JSR303\npackage com.woniu.controller.e_validator;import javax.validation.constraints.NotBlank;/** * @Author: Panda * @Date: 2021/4/23 16:46 * @Description: */public class User &#123;    //null &quot;&quot;    @NotBlank(message = &quot;uname 不能为空!&quot;)    private String uname;    private String upwd;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;uname=&#x27;&quot; + uname + &#x27;\\&#x27;&#x27; +                &quot;, upwd=&#x27;&quot; + upwd + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public String getUname() &#123;        return uname;    &#125;    public void setUname(String uname) &#123;        this.uname = uname;    &#125;    public String getUpwd() &#123;        return upwd;    &#125;    public void setUpwd(String upwd) &#123;        this.upwd = upwd;    &#125;&#125;\n\n3、对需要校验的数据添加注解@Validatedpackage com.woniu.controller.e_validator;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.Errors;import org.springframework.validation.FieldError;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.Date;import java.util.List;/** * @Author: Panda * @Date: 2021/4/26 10:40 * @Description: */@Controllerpublic class UserController &#123;    @RequestMapping(&quot;save&quot;)   public String save(@Validated User user, Errors errors)&#123;        //获得表单传递值校验的错误信息        List&lt;FieldError&gt; fieldErrors = errors.getFieldErrors();        for(FieldError fieldError:fieldErrors)&#123;            System.out.println(fieldError.getField()+&quot;:&quot;+fieldError.getDefaultMessage());        &#125;        return null;   &#125;&#125;\n\n4、在SpringMVC中注册校验器&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.e_validator&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven validator=&quot;validator&quot;&gt;&lt;/mvc:annotation-driven&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;        &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\nSpringMVC集成JSON1、添加依赖将对象或者集合转换成json\n&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.11.4&lt;/version&gt;&lt;/dependency&gt;\n\n2、在方法上添加注解@ResponseBody@RequestMapping(&quot;list&quot;)   @ResponseBody  //返回的对象交给jackson-databind进行转json并输出的操作   public List&lt;User&gt; list(HttpServletResponse response)&#123;       System.out.println(&quot;UserController.list&quot;);       User user = new User();       user.setUname(&quot;admin&quot;);       user.setUpwd(&quot;123&quot;);       User user2 = new User();       user2.setUname(&quot;aaa&quot;);       user2.setUpwd(&quot;1213&quot;);       List&lt;User&gt; userList = new ArrayList&lt;&gt;();       userList.add(user);       userList.add(user2);       return userList;   &#125;\n\n\n\n1、要求页面传递数据格式为jsondata:JSON.stringify(jsonStr)\n\n2、在Controller方法上添加注解@RequestBodypublic String save(@RequestBody User user)\n\n3、因为默认按照键值对解析数据需要将请求类型改为application/json\ncontentType:&quot;application/json&quot;\n\n\n\n\n可以使用POSTMAN进行测试。\n\nRESTful概念REST（英文：Representational State Transfer，简称REST）\n表述性状态转移; 表现状态传输;\n描述了一个架构样式的网络系统，比如 web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，Roy Fielding是 HTTP 规范的主要编写者之一。\n在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。值得注意的是REST并没有一个明确的标准，而更像是一种设计的风格。 \n特点RESTFUL特点包括：\n1、每一个URI代表1种资源；\n2、客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；\n3、通过操作资源的表现形式来操作资源；\n4、资源的表现形式是XML或者HTML；\n5、客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。\nRESTful资源设计规则URIURI 表示资源，资源一般对应服务器端领域模型中的实体类。\nURI规范不用大写；用中杠-不用下杠_；参数列表要encode；URI中的名词表示资源集合，使用复数形式。\n资源集合 vs 单个资源URI表示资源的两种方式：资源集合、单个资源。\n资源集合：\n/zoos //所有动物园/zoos/1/animals //id为1的动物园中的所有动物\n单个资源：\n/zoos/1 //id为1的动物园/zoos/1;2;3 //id为1，2，3的动物园\n避免层级过深的URI/在url中表达层级，用于按实体关联关系进行对象导航，一般根据id导航。\n过深的导航容易导致url膨胀，不易维护，如 GET /zoos/1/areas/3/animals/4，尽量使用查询参数代替路径中的实体导航，如GET /animals?zoo=1&amp;area=3；\n对Composite资源的访问服务器端的组合实体必须在uri中通过父实体的id导航访问。\n组合实体不是first-class的实体，它的生命周期完全依赖父实体，无法独立存在，在实现上通常是对数据库表中某些列的抽象，不直接对应表，也无id。一个常见的例子是 User — Address，Address是对User表中zipCode/country/city三个字段的简单抽象，无法独立于User存在。必须通过User索引到Address：GET /user/1/addresses\n\nRequestHTTP方法通过标准HTTP方法对资源CRUD：\n\nGET：查询\nGET /zoosGET /zoos/1GET /zoos/1/employees\nPOST：创建单个资源。POST一般向“资源集合”型uri发起\nPOST /animals  //新增动物POST /zoos/1/employees //为id为1的动物园雇佣员工\nPUT：更新单个资源（全量），客户端提供完整的更新后的资源。与之对应的是 PATCH，PATCH 负责部分更新，客户端提供要更新的那些字段。PUT/PATCH一般向“单个资源”型uri发起\nPUT /animals/1PUT /zoos/1\nDELETE：删除\nDELETE /zoos/1/employees/2DELETE /zoos/1/employees/2;4;5DELETE /zoos/1/animals  //删除id为1的动物园内的所有动物\npackage com.woniu.controller.g_rest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletResponse;import java.util.ArrayList;import java.util.List;/** * @Author: Panda * @Date: 2021/4/26 10:40 * @Description: */@RestController@RequestMapping(&quot;users&quot;)public class UserController &#123;    //get请求都是做查询操作    //使用get请求http://localhost:8080/projectname/users    @GetMapping    public String findAll()&#123;        System.out.println(&quot;UserController.findAll&quot;);        return &quot;a&quot;;    &#125;    //使用get请求http://localhost:8080/projectname/users/1    @GetMapping(value = &quot;&#123;id&#125;&quot;)    public String findOne(@PathVariable(&quot;id&quot;) Integer uid)&#123;        System.out.println(&quot;UserController.findOne:&quot;+uid);        return null;    &#125;    //post请求做新增操作    @PostMapping    public String save(User user)&#123;        System.out.println(&quot;UserController.save:&quot;+user);        return null;    &#125;    //put请求做修改操作    @PutMapping    public String update(User user)&#123;        System.out.println(&quot;UserController.update:&quot;+user);        return null;    &#125;    //delete请求做删除操作    @DeleteMapping(value = &quot;&#123;id&#125;&quot;)    public String delete(@PathVariable(&quot;id&quot;) Integer uid)&#123;        System.out.println(&quot;UserController.delete:&quot;+uid);        return null;    &#125;&#125;\n\n&lt;%--  Created by IntelliJ IDEA.  User: Panda  Date: 2021/4/23  Time: 16:48  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;false&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form  action=&quot;users&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;uname&quot;&gt;        &lt;input name=&quot;upwd&quot; &gt;        &lt;button&gt;save&lt;/button&gt;    &lt;/form&gt;    &lt;form  action=&quot;users&quot; method=&quot;post&quot;&gt;        &lt;!--            如果要做put请求:            1.需要添加隐藏域,声明put请求            2.使用一个过滤器读取隐藏域信息,完成put请求         --&gt;        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt;        &lt;input name=&quot;uname&quot;&gt;        &lt;input name=&quot;upwd&quot;&gt;        &lt;button&gt;update&lt;/button&gt;    &lt;/form&gt;    &lt;form  action=&quot;users/1002&quot; method=&quot;post&quot;&gt;        &lt;!--            如果要做put请求:            1.需要添加隐藏域,声明put请求            2.使用一个过滤器读取隐藏域信息,完成put请求         --&gt;        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt;        &lt;button&gt;delete&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--    RESTful风格中过滤请求方式(put,delete)  --&gt;  &lt;filter&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--     前端控制器  --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:g_rest/springmvc-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;!--      /表示拦截了除了jsp之外所有的请求    --&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n\n\n处理静态资源1）采用&lt;mvc:default-servlet-handler /&gt;在springMVC-servlet.xml中配置&lt;mvc:default-servlet-handler /&gt;后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，它会像一个检查员，对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。\n一般Web应用服务器默认的Servlet名称是”default”，因此DefaultServletHttpRequestHandler可以找到它。如果你所有的Web应用服务器的默认Servlet名称不是”default”，则需要通过default-servlet-name属性显示指定：\n&lt;mvc:default-servlet-handler default-servlet-name=”所使用的Web服务器默认使用的Servlet名称” /&gt;\n2）采用&lt;mvc:resources /&gt;&lt;mvc:default-servlet-handler /&gt;将静态资源的处理经由Spring MVC框架交回Web应用服务器处理。而&lt;mvc:resources /&gt;更进一步，由Spring MVC框架自己处理静态资源，并添加一些有用的附加值功能。\n首先，&lt;mvc:resources /&gt;允许静态资源放在任何地方，如WEB-INF目录下、类路径下等，你甚至可以将JavaScript等静态文件打到JAR包中。通过location属性指定静态资源的位置，由于location属性是Resources类型，因此可以使用诸如”classpath:”等的资源前缀指定资源位置。传统Web容器的静态资源只能放在Web容器的根路径下，&lt;mvc:resources /&gt;完全打破了这个限制。\n其次，&lt;mvc:resources /&gt;依据当前著名的Page Speed、YSlow等浏览器优化原则对静态资源提供优化。你可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。在输出静态资源时，会根据配置设置好响应报文头的Expires 和 Cache-Control值。\n在接收到静态资源的获取请求时，会检查请求头的Last-Modified值，如果静态资源没有发生变化，则直接返回303相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.g_rest&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--        配置web服务器的默认Servlet来处理静态资源    --&gt;    &lt;!--&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;--&gt;    &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;&gt;&lt;/mvc:resources&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\nSpringMVC拦截器1.编写一个拦截器package com.woniu.controller.h_interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @Author: Panda * @Date: 2021/4/27 14:03 * @Description: */public class LoginInterceptor implements HandlerInterceptor &#123;    /**     * 在handle执行之前     * @param httpServletRequest     * @param httpServletResponse     * @param o     * @return     * @throws Exception     */    @Override    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;        System.out.println(&quot;LoginInterceptor.preHandle&quot;);        //如果return true则放行        return true;    &#125;    /**     * 在handle执行之后     * @param httpServletRequest     * @param httpServletResponse     * @param o     * @param modelAndView     * @throws Exception     */    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;LoginInterceptor.postHandle&quot;);    &#125;    /**     * 在视图解析之后     * @param httpServletRequest     * @param httpServletResponse     * @param o     * @param e     * @throws Exception     */    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;        System.out.println(&quot;LoginInterceptor.afterCompletion&quot;);    &#125;&#125;\n\n2、配置拦截器&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.h_interceptor&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--        配置web服务器的默认Servlet来处理静态资源    --&gt;    &lt;!--&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;--&gt;    &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;&gt;&lt;/mvc:resources&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置拦截器栈    --&gt;    &lt;mvc:interceptors&gt;        &lt;!--            配置拦截器        --&gt;        &lt;mvc:interceptor&gt;            &lt;!--                配置拦截规则            --&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;mvc:exclude-mapping path=&quot;/login&quot;/&gt;            &lt;!--                拦截器对象            --&gt;            &lt;bean class=&quot;com.woniu.controller.h_interceptor.LoginInterceptor&quot;&gt;&lt;/bean&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;&lt;/beans&gt;\n\n\n\nSpringMVC文件上传1、表单&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;uploadFile&quot; /&gt;    &lt;button&gt;upload&lt;/button&gt;&lt;/form&gt;\n\n2、添加依赖&lt;dependency&gt;  &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;\n\n3、上传的操作package com.woniu.controller.i_upload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.util.UUID;/** * @Author: Panda * @Date: 2021/4/27 14:23 * @Description: */@Controllerpublic class UploadController &#123;    @RequestMapping(&quot;upload&quot;)    public String upload(MultipartFile photo, HttpServletRequest request)&#123;        //声明一个指定目录,用来存放上传的文件        String realPath = request.getServletContext().getRealPath(&quot;/upload&quot;);        System.out.println(&quot;UploadController.upload:&quot;+realPath);        File dir = new File(realPath);        if(!dir.exists())&#123;            dir.mkdirs();        &#125;        //每个上传的文件名不重复UUID, 当前时间的毫秒数        String fileName = photo.getOriginalFilename();  //getName获取的是控件的名字        String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); //1.jpg  .jpg        fileName = UUID.randomUUID()+suffix;        try &#123;            photo.transferTo(new File(dir,fileName));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n4、上传解析器&lt;!-- 解析器必须添加id，否则会导致上传不成功 --&gt;    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;maxUploadSize&quot; value=&quot;20000000&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;\n\n\n\nSpringMVC异常处理1、编写异常处理类package com.woniu.controller.j_exception;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @Author: Panda * @Date: 2021/4/27 15:22 * @Description: */@ControllerAdvicepublic class ExceptionHandlerDemo implements HandlerExceptionResolver &#123;    @ExceptionHandler    @Override    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;        System.out.println(&quot;ExceptionHandlerDemo.resolveException:&quot;+o.getClass());        ModelAndView modelAndView = new ModelAndView();        modelAndView.setViewName(&quot;error&quot;);        modelAndView.addObject(&quot;message&quot;,e.getMessage());        return modelAndView;    &#125;&#125;\n\n\n\n2、编写异常展示页面&lt;%--  Created by IntelliJ IDEA.  User: Panda  Date: 2021/4/23  Time: 16:48  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;false&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   $&#123;message&#125;&lt;/body&gt;&lt;/html&gt;\n\n3、编写Controller生成异常package com.woniu.controller.j_exception;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;/** * @Author: Panda * @Date: 2021/4/27 15:21 * @Description: */@Controllerpublic class UserController &#123;    @RequestMapping(&quot;test/&#123;num&#125;&quot;)    public String test(@PathVariable(&quot;num&quot;) Integer num)&#123;        System.out.println(&quot;UserController.test:&quot;+(10/num));        return null;    &#125;&#125;\n\n\n\nSSM框架整合1、添加依赖Mybatis\n&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.38&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.23&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;\n\nSpringMVC\n&lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;        &lt;/dependency&gt;\n\nSpring对orm的支持\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;    &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\nMybatis和Spring的关联\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt;\n\n其他配置\n        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.12.3&lt;/version&gt;        &lt;/dependency&gt;&lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;            &lt;version&gt;6.2.0.Final&lt;/version&gt;        &lt;/dependency&gt;\n\n\n\n2、在web.xml中配置配置SpringMVC的前端控制器\n配置隐藏方法过滤器\n配置编码过滤器\n配置Spring的监听器\n配置Spring的配置文件位置\n&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;filter&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n\n\n3、Spring配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!--        扫描所有带注解的类    --&gt;    &lt;context:component-scan base-package=&quot;com.woniu&quot; &gt;        &lt;!-- 排除Conroller注解 --&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;/context:component-scan&gt;    &lt;!--        数据源    --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;woniu&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        SqlSessionFactory    --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        扫描所有mapper    --&gt;    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.woniu.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        事务管理器    --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        声明式事务    --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt;\n\n\n\n4、SpringMVC的配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--        扫描所有的Controller    --&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n5、生成Mybatis的代码6、编写Service和Controller","tags":["蜗牛学院笔记","SpringMVC"]},{"title":"spring框架","url":"/2022/06/05/spring%E6%A1%86%E6%9E%B6/","content":"Spring框架介绍Spring是一个轻量级的IoC和AOP的框架\nIoC控制反转\nAOP面向切面编程\nSpring的功能image-20210310101742629\n优点：1）方便解耦，简化开发Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给 Spring 管理。2）方便集成各种优秀框架Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如 Struts2、Hibernate、MyBatis等）的直接支持。3）降低 Java EE API 的使用难度Spring 对 Java EE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些API 应用的难度大大降低。4）方便程序的测试Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。5）AOP 编程的支持Spring 提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。6）声明式事务的支持只需要通过配置就可以完成对事务的管理，而无须手动编程。  \n接口和Spring是完美搭配\n以前\npublic interface UserDAO&#123;\tvoid save();&#125;public class UserDAOImpl implements UserDAO&#123;\tpublic void save()&#123;\t\t....\t&#125;&#125;public class UserServiceImpl implements UserService&#123;    private UserDAO userDAO;    public void reg()&#123;        userDAO.save();        ....    &#125;&#125;--------------------------------------------------------------    public class UserDAOJDBCImpl implements UserDAO&#123;\tpublic void save()&#123;\t\t....\t&#125;&#125;public class UserServiceImpl implements UserService&#123;    private UserDAO userDAO;    public void reg()&#123;        userDAO.save();        ....    &#125;&#125;我们在UserServiceImpl中不再实例化DAO对象从Spring容器中获得\n\n\n\n\n\n搭建Spring环境1、添加依赖&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\n2、编写Beanpackage com.woniu.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * @Author: Panda * @Date: 2021/4/20 11:38 * @Description: */@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    private String uname;    private String upwd;&#125;\n\n3、编写配置文件先将模板在idea中生成\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        com.woniu.User user = new com.woniu.User();        &lt;bean&gt;声明实例化对象的信息        id对象的名称        class对象的类型    --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.woniu.pojo.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n4、测试获取user对象package com.woniu.test;import com.woniu.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @Author: Panda * @Date: 2021/4/20 11:48 * @Description: */public class AppTest &#123;    @Test    public void test()&#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app.xml&quot;);        User user = (User) applicationContext.getBean(&quot;user&quot;);        user.setUname(&quot;admin&quot;);        user.setUpwd(&quot;123&quot;);        System.out.println(&quot;AppTest.test&quot;+user);    &#125;&#125;\n\n\n\nIoC容器介绍BeanFactory在没有获取容器中实例时，不实例化对应的对象\nBeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;app.xml&quot;));BeanFactory beanFactory1 = new XmlBeanFactory(new FileSystemResource(&quot;d:/app.xml&quot;));\n\n\n\nApplicationContextApplicationContext applicationContext2 = new FileSystemXmlApplicationContext(&quot;d:/app.xml&quot;);ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app.xml&quot;);ApplicationContext applicationContext3 = new AnnotationConfigApplicationContext(JavaConfig.class);\n\n容器生成时，就会实例化配置文件中声明的对象\nApplicationContext从BeanFactory派生出来的\nApplicationContext增加了以下功能\n\n国际化（MessageSource）\n\n访问资源，如URL和文件（ResourceLoader）\n\n载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  \n\n消息发送、响应机制（ApplicationEventPublisher）\n\nAOP（拦截器）\n\n\nBean的概念Spring中Bean就是一个类的实例\n&lt;bean id=&quot;&quot; class=&quot;&quot; /&gt;通过构造器完成类的实例化\n\nBean的生成方式有三种：\n1、构造器生成\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        Bean的生成方式        1、构造器生成        com.woniu.pojo.User必须有为空的构造器    --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.woniu.pojo.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n@Test    public void testConstrutor()&#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app2.xml&quot;);        User user = (User) applicationContext.getBean(&quot;user&quot;);        System.out.println(user);    &#125;\n\n2、静态工厂\npackage com.woniu.util;import com.woniu.pojo.User;/** * @Author: Panda * @Date: 2021/4/20 15:22 * @Description: */public class UserFactory &#123;    public static User getUser()&#123;        return new User();    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        2、静态工厂        User user = UserFactory.getUser();    --&gt;    &lt;bean id=&quot;user2&quot; class=&quot;com.woniu.util.UserFactory&quot; factory-method=&quot;getUser&quot;&gt;&lt;/bean&gt;  &lt;/beans&gt;\n\n3、实例工厂\npackage com.woniu.util;import com.woniu.pojo.User;/** * @Author: Panda * @Date: 2021/4/20 15:22 * @Description: */public class UserFactory2 &#123;    public User getUser()&#123;        return new User();    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        3、实例工厂        UserFactory userFactory = new UserFactory();        User user = userFactory.getUser();    --&gt;    &lt;bean id=&quot;userFactory&quot; class=&quot;com.woniu.util.UserFactory2&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;user3&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;getUser&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\nbean的作用域范围scope有如下五个取值：\nsingleton：单例的（默认的），使用singleton定义的Bean是单例的，每次调用getBean都是调用的同一个对象。只要IoC容器一创建就会创建Bean的实例。prototype：多例的，每次通过Spring IoC容器获取prototype定义的Bean时，容器都将创建一个新的Bean实例。创建时不会实例该Bean，只有调用getBean方法时，才会实例化。request：作用于web的请求范围，在每一次HTTP请求时，容器会返回Bean的同一个实例，对不同的HTTP请求则会产生一个新的Bean，而且该Bean仅在当前HTTP Request内有效。session：作用于web的会话范围，在一次HTTP Session中，容器会返回该Bean的同一个实例，对不同的HTTP请求则会产生一个新的Bean，而且该Bean仅在当前HTTP Session内有效。global-session：作用于集群环境的会话范围（全局会话范围），在一个全局的HTTP Session中，容器返回Bean的同一个实例。当不是集群环境时，它就是session。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        Bean的作用范围        prototype   原型  每次获取产生一个新的实例        singleton   单例  每次获取都是同一个实例        request     以下三个属性是在web应用中使用        session        gobal-session    --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.woniu.pojo.User&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n@Testpublic void testScope()&#123;    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app3.xml&quot;);    //从容器中两次获得相同的id，判断两个实例是否相等，相等为单例，否则为多例    User user = (User) applicationContext.getBean(&quot;user&quot;);    User user2 = (User) applicationContext.getBean(&quot;user&quot;);    System.out.println(user==user2);&#125;\n\n\n\n依赖注入概述Setter注入package com.woniu.service.impl;import com.woniu.dao.UserDAO;import com.woniu.service.UserService;/** * @Author: Panda * @Date: 2021/4/20 15:53 * @Description: */public class UserServiceImpl implements UserService &#123;    private UserDAO userDAO;    public UserServiceImpl()&#123;    &#125;\t//setter注入    public void setUserDAO(UserDAO userDAO)&#123;        this.userDAO = userDAO;    &#125;    @Override    public void save() &#123;        userDAO.save();        System.out.println(&quot;UserServiceImpl.save&quot;);    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        DI  依赖注入        UserDAO userDAO = new UserDAOImpl();        UserService userService = new UserServiceImpl();        这时需要通过setter或者构造器注入        1、setter注入    --&gt;    &lt;bean id=&quot;userDAO&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot;&gt;        &lt;!-- 调用UserServiceImpl中的setUserDAO方法 --&gt;        &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n构造器注入package com.woniu.service.impl;import com.woniu.dao.UserDAO;import com.woniu.service.UserService;/** * @Author: Panda * @Date: 2021/4/20 15:53 * @Description: */public class UserServiceImpl implements UserService &#123;    private UserDAO userDAO;    public UserServiceImpl(UserDAO userDAO)&#123;        this.userDAO = userDAO;    &#125;    @Override    public void save() &#123;        userDAO.save();        System.out.println(&quot;UserServiceImpl.save&quot;);    &#125;&#125;\n\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;       &lt;!--        2、构造器注入    --&gt;    &lt;bean id=&quot;userDAO2&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService2&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot;&gt;        &lt;!-- 调用UserServiceImpl中的有参构造器 --&gt;        &lt;constructor-arg name=&quot;userDAO&quot; ref=&quot;userDAO2&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;   &lt;/beans&gt;\n\n\n\n命名空间&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       //添加下面两个命名空间       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;       &lt;!--        命名空间注入        本质还是setter和构造器注入，只是换了种方式    --&gt;    &lt;bean id=&quot;userDAO3&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService3&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot; c:userDAO-ref=&quot;userDAO3&quot; p:userDAO-ref=&quot;userDAO3&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\n自动装配&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--       自动装配       byName 按照名字装配，要求bean的id于servcie中声明的对象一致       byType 按照类型装配，要求容器中该类型只能有一个实例    --&gt;    &lt;bean id=&quot;userDAO&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\nFactoryBeanSpring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该FactoryBean的getObject方法所返回的对象。创建出来的对象是否属于单例由isSingleton中的返回决定。\n一般情况下，Spring通过反射机制利用的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式\n以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。\npackage com.woniu.util;import com.woniu.dao.impl.UserDAOImpl;import com.woniu.service.UserService;import com.woniu.service.impl.UserServiceImpl;import org.springframework.beans.factory.FactoryBean;/** * @Author: Panda * @Date: 2021/4/20 17:01 * @Description: */public class UserServiceFactoryBean implements FactoryBean&lt;UserService&gt; &#123;    /**     * &lt;bean id=&quot;roleDAO&quot; class=&quot;com.woniu.dao.impl.RoleDAOImpl&quot;&gt;     *     &lt;/bean&gt;     *     &lt;bean id=&quot;userDAO&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;     *     &lt;bean id=&quot;userService&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot;&gt;     *         &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;&gt;&lt;/property&gt;     *         &lt;property name=&quot;roleDAO&quot; ref=&quot;roleDAO&quot;&gt;&lt;/property&gt;     *     &lt;/bean&gt;     * @return     * @throws Exception    \t通过FactoryBean返回指定类型的对象     */    @Override    public UserService getObject() throws Exception &#123;    \t//编写复杂的组装逻辑        UserServiceImpl userService = new UserServiceImpl();        userService.setUserDAO(new UserDAOImpl());        return userService;    &#125;\t//当前对象的类型    @Override    public Class&lt;?&gt; getObjectType() &#123;        return null;    &#125;\t//返回的对象是否为单例    @Override    public boolean isSingleton() &#123;        return true;    &#125;&#125;\n\n\n\nSpring常用注解@Component\n​    @Controller \n​    @Service\n​    @Repository\n在配置文件中添加命名空间context，还需添加格式文件\n扫描指定包下所有的类，找到有以上注解的类，并添加到Spring容器中进行管理&lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt;\n\n\n注意：\n1、需要注入的对象，在属性上添加注解@Autowire或者@Resource\n2、所有bean的id默认为类名首字母小写。否则需要在注解中声明实例的id。\n\n","tags":["spring","蜗牛学院笔记"]},{"title":"ssh远程连接","url":"/2022/03/31/ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","content":" SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd,负责实时监听客户端的请求(IP 22端口)，包括公共秘钥等交换等信息。\nssh服务端由2部分组成： openssh(提供ssh服务)    openssl(提供加密的程序)\nssh的客户端可以用 XSHELL，Securecrt, Mobaxterm等工具进行连接\n一些常用的ssh命令#指定用户登录ssh root@ip地址      #修改端口登录ssh root -p 8080 ip地址 ssh  -Y root@host        #可以图形化操作(比如打开firefox) #重启sshd服务service sshd restart#退出连接exit\n一些常用的ssh配置命令#复制SSH密钥到目标主机，开启无密码SSH登录ssh-copy-id root@hos     #如果还没有密钥，请使用ssh-keygen命令生成。# 清除公钥ssh-keygen -R 10.36.xx.xx\n\nssh传输文件命令scp -r 【本地要上传文件地址】  [用户名]@[ip地址]：远程地址#-r代表上传的是文件夹以及文件夹里所有的东西\n\n\n\n\n\n相关博客：小a玖拾柒xxq_2010\n","categories":["centos/linux","ssh"],"tags":["centos/linux","ssh"]},{"title":"vue第一篇-语法","url":"/2022/04/19/vue%E7%AC%AC%E4%B8%80%E7%AF%87-%E8%AF%AD%E6%B3%95/","content":"ES6基础语法let（1） 作用:与var类似, 用于声明变量（2） 特点:在块作用域内有效不能重复声明不会预处理, 不存在提升（3） 应用:循环遍历加监听使用let取代var是趋势\nconsole.log(a);&#123;\tvar a =3;&#125;\n\n\n\nconst（1） 作用:定义一个常量（2） 特点:不能修改其它特点同let（3） 应用:保存不用改变的数据\n字符串模板字符串必须用 `` 包含，变量用${xxx}\nfor-ofvar arr = [&#x27;nick&#x27;,&#x27;andy&#x27;,&#x27;mike&#x27;,&#x27;james&#x27;];for(var item of arr)&#123;\t    console.log(item);&#125;\n\nvar arr = [    &#123; name:&#x27;nick&#x27;, age:18 &#125;,    &#123; name:&#x27;andy&#x27;, age:24 &#125;,    &#123; name:&#x27;mike&#x27;, age:26 &#125;,    &#123; name:&#x27;james&#x27;, age:34 &#125;];for(var item of arr)&#123;\t    console.log(item.name,item.age);&#125;\n\n与for in 区别区别①：for of无法循环遍历对象\nvar userMsg = &#123;    0: &#x27;nick&#x27;,    1: &#x27;andy&#x27;,    2: &#x27;mike&#x27;,\t    3: &#x27;james&#x27;&#125;; for(var key in userMsg)&#123;    console.log(key, userMsg[key]);\t&#125;console.log(&#x27;-----------分割线-----------&#x27;);for(var item of userMsg)&#123;\t    console.log(item);&#125;\n\n区别②：遍历输出结果不同\nvar arr = [&#x27;nick&#x27;,&#x27;andy&#x27;,&#x27;mike&#x27;,&#x27;james&#x27;];for(var key in arr)&#123;    console.log(key);\t&#125;console.log(&#x27;-----------分割线-----------&#x27;);for(var item of arr)&#123;\t    console.log(item);&#125;\n\n\n\n类声明在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。\nclass 的本质是 function。\n它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。\n\n语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。\n\n// 匿名类let Example = class &#123;    constructor(a) &#123;        this.a = a;    &#125;&#125;// 命名类let Example = class Example &#123;    constructor(a) &#123;        this.a = a;    &#125;&#125;\n\n可以在类中声明属性、构造器、方法class C&#123;\tname;\tconstructor(name)&#123;\t\tthis.name = name;\t&#125;\tshow()&#123;\t\treturn this.name;\t&#125;&#125;let c = new C(&quot;andy&quot;);console.log(c.show());\n\n\n\n\n\n实例化class 的实例化必须通过 new 关键字。\nclass Example &#123;    constructor(a, b) &#123;        this.a = a;        this.b = b;        console.log(&#x27;Example&#x27;);    &#125;    sum() &#123;        return this.a + this.b;    &#125;&#125;let exam1 = new Example(2, 1);let exam2 = new Example(3, 1);console.log(exam1._proto_ == exam2._proto_); // true exam1._proto_.sub = function() &#123;    return this.a - this.b;&#125;console.log(exam1.sub()); // 1console.log(exam2.sub()); // 2\n\n\n\n属性静态属性静态属性：class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。class Example &#123;// 新提案    static a = 2;&#125;// 目前可行写法Example.b = 2;实例属性实例属性：定义在实例对象（ this ）上的属性。class Example &#123;    a = 2;    constructor () &#123;        console.log(this.a);    &#125;&#125;name 属性返回跟在 class 后的类名(存在时)。let Example=class Exam &#123;    constructor(a) &#123;        this.a = a;    &#125;&#125;console.log(Example.name); // Exam let Example=class &#123;    constructor(a) &#123;        this.a = a;    &#125;&#125;console.log(Example.name); // Example\n\n\n\n方法使用静态方法\nclass Example&#123;    static sum(a, b) &#123;        console.log(a+b);    &#125;&#125;Example.sum(1, 2); // 3\n\n原型方法\nclass Example &#123;    sum(a, b) &#123;        console.log(a + b);    &#125;&#125;let exam = new Example();exam.sum(1, 2); // 3\n\n实例方法\nclass Example &#123;    constructor() &#123;        this.sum = (a, b) =&gt; &#123;            console.log(a + b);        &#125;    &#125;&#125;\n\n箭头函数\nES6 允许使用“箭头”（=&gt;）定义函数。\n场景：用于替换匿名函数\n基本用法//匿名函数    div.onclick=function()&#123;        console.log(&quot;你好&quot;)    &#125;    //箭头函数    div.onclick=()=&gt;&#123;        console.log(&quot;你好&quot;)    &#125;\n\nvar fn=(a)=&gt;&#123;        console.log(&quot;abc&quot;);    &#125;    //等价于：    var fn=a=&gt;&#123;        console.log(&quot;abc&quot;);    &#125;\n\nvar p=&#123;        age:18,        //es6中对象方法的箭头函数表示形式        run:()=&gt;&#123;            setTimeout(()=&gt;&#123;                //this:window                console.log(this);//this是window            &#125;,100)        &#125;,        travel:function()&#123;            //this:p            setTimeout(()=&gt;&#123;                console.log(this);//this是p            &#125;,100)        &#125;,        //推荐使用的方式：es6中对象方法的简写形式        say()&#123;            console.log(&quot;say方法中的this：&quot;,this);            setTimeout(()=&gt;&#123;                console.log(&quot;say内部的延迟函数：&quot;,this);//this是p            &#125;,100)        &#125;,    &#125;    p.run();    p.travel();    p.say();\n\n\n\n\n箭头函数和普通匿名函数有哪些不同？\n　　1.函数体内的this对象，就是定义所在的对象，而不是使用所在的对象\n　　2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误\n　　3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n　　4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n​        5.generator函数现在经常用async替代\n\n模块概述ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。\nES6 的模块化分为导出（export） 与导入（import）两个模块。\n特点ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 **use strict;**。\n模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。\n每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。\n每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。\nexport 与 import基本用法模块导入导出各种类型的变量，如字符串，数值，函数，类。\n\n导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 \n不仅能导出声明还能导出引用（例如函数）。\nexport 命令可以出现在模块的任何位置，但必需处于模块顶层。\nimport 命令会提升到整个模块的头部，首先执行。\n\n/*-----export [test.js]-----*/let myName = &quot;Tom&quot;;let myAge = 20;let myfn = function()&#123;    return &quot;My name is&quot; + myName + &quot;! I&#x27;m &#x27;&quot; + myAge + &quot;years old.&quot;&#125;let myClass =  class myClass &#123;    static a = &quot;yeah!&quot;;&#125;export &#123; myName, myAge, myfn, myClass &#125; /*-----import [xxx.js]-----*/import &#123; myName, myAge, myfn, myClass &#125; from &quot;./test.js&quot;;console.log(myfn());// My name is Tom! I&#x27;m 20 years old.console.log(myAge);// 20console.log(myName);// Tomconsole.log(myClass.a );// yeah!\n\n建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。\n函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。\n&lt;script type=&quot;module&quot;&gt;    //没有在模块中 Cannot use import statement outside a module    //解决方案：type=&quot;module&quot;    import &#123;ename,age,method,clazz&#125; from &#x27;./export.js&#x27;;    console.log(ename);    console.log(age);    method();    new clazz();    //类名为A，但是A类赋给了clazz，所以实例化时使用clazz()进行构造。    //跨域 Access to script at &#x27;file:///D:/es6/export.js&#x27; from origin &#x27;null&#x27; has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https.    //因为访问的本地文件，所以产生跨域问题    //通过服务器地址访问&lt;/script&gt;\n\n\n\nas 的用法export 命令导出的接口名称，须和模块内部的变量有一一对应关系。\n导入的变量名，须和导出的接口名称相同，即顺序可以不一致。\n/*-----export [test.js]-----*/let myName = &quot;Tom&quot;;export &#123; myName as exportName &#125; /*-----import [xxx.js]-----*/import &#123; exportName &#125; from &quot;./test.js&quot;;console.log(exportName);// Tom使用 as 重新定义导出的接口名称，隐藏模块内部的变量/*-----export [test1.js]-----*/let myName = &quot;Tom&quot;;export &#123; myName &#125;/*-----export [test2.js]-----*/let myName = &quot;Jerry&quot;;export &#123; myName &#125;/*-----import [xxx.js]-----*/import &#123; myName as name1 &#125; from &quot;./test1.js&quot;;import &#123; myName as name2 &#125; from &quot;./test2.js&quot;;console.log(name1);// Tomconsole.log(name2);// Jerry\n\n不同模块导出接口名称命名重复， 使用 as 重新定义变量名。\nimport 命令的特点只读属性：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。\nimport &#123;a&#125; from &quot;./xxx.js&quot;a = &#123;&#125;; // error import &#123;a&#125; from &quot;./xxx.js&quot;a.foo = &quot;hello&quot;; // a = &#123; foo : &#x27;hello&#x27; &#125;\n\n单例模式：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。\nimport &#123; a &#125; &quot;./xxx.js&quot;;import &#123; a &#125; &quot;./xxx.js&quot;;// 相当于 import &#123; a &#125; &quot;./xxx.js&quot;; import &#123; a &#125; from &quot;./xxx.js&quot;;import &#123; b &#125; from &quot;./xxx.js&quot;;// 相当于 import &#123; a, b &#125; from &quot;./xxx.js&quot;;\n\n静态执行特性：import 是静态执行，所以不能使用表达式和变量。\nimport &#123; &quot;f&quot; + &quot;oo&quot; &#125; from &quot;methods&quot;;// errorlet module = &quot;methods&quot;;import &#123; foo &#125; from module;// errorif (true) &#123;  import &#123; foo &#125; from &quot;method1&quot;;&#125; else &#123;  import &#123; foo &#125; from &quot;method2&quot;;&#125;// error\n\n\n\nexport default 命令\n在一个文件或模块中，export、import 可以有多个，export default 仅有一个。\nexport default 中的 default 是对应的导出接口变量。\n通过 export 方式导出，在导入时要加{ }，export default 则不需要。\nexport default 向外暴露的成员，可以使用任意变量来接收。\n\nvar a = &quot;My name is Tom!&quot;;export default a; // 仅有一个export default var c = &quot;error&quot;; // error，default 已经是对应的导出变量，不能跟着变量声明语句 import b from &quot;./xxx.js&quot;; // 不需要加&#123;&#125;， 使用任意变量接收\n\n\n\nPromise概述是异步编程的一种解决方案。\n从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\nPromise 状态状态的特点Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。\nPromise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。\nconst p1 = new Promise(function(resolve,reject)&#123;    resolve(&#x27;success1&#x27;);    resolve(&#x27;success2&#x27;);&#125;); const p2 = new Promise(function(resolve,reject)&#123;      resolve(&#x27;success3&#x27;);     reject(&#x27;reject&#x27;);&#125;);p1.then(function(value)&#123;      console.log(value); // success1&#125;);p2.then(function(value)&#123;     console.log(value); // success3&#125;);\n\n\n\n状态的缺点无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。\n如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。\n当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\nthen 方法then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。\nthen 方法的特点在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。\nconst p = new Promise(function(resolve,reject)&#123;  resolve(&#x27;success&#x27;);&#125;); p.then(function(value)&#123;  console.log(value);&#125;); console.log(&#x27;first&#x27;);// first// success\n\n通过 .then 形式添加的回调函数，不论什么时候，都会被调用。\n通过多次调用\n.then\n，可以添加多个回调函数，它们会按照插入顺序并且独立运行。\nconst p = new Promise(function(resolve,reject)&#123;  resolve(1);&#125;).then(function(value)&#123; // 第一个then // 1  console.log(value);  return value * 2;&#125;).then(function(value)&#123; // 第二个then // 2  console.log(value);&#125;).then(function(value)&#123; // 第三个then // undefined  console.log(value);  return Promise.resolve(&#x27;resolve&#x27;); &#125;).then(function(value)&#123; // 第四个then // resolve  console.log(value);  return Promise.reject(&#x27;reject&#x27;); &#125;).then(function(value)&#123; // 第五个then //reject:reject  console.log(&#x27;resolve:&#x27; + value);&#125;, function(err) &#123;  console.log(&#x27;reject:&#x27; + err);&#125;);\n\nthen 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。\nthen 方法注意点简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。\n注意总是返回或终止 Promise 链。\nconst p1 = new Promise(function(resolve,reject)&#123;  resolve(1);&#125;).then(function(result) &#123;  p2(result).then(newResult =&gt; p3(newResult));&#125;).then(() =&gt; p4())\n\n创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。\n大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 .catch(error =&gt; console.log(error));\n例子\nvar getJSON = function(url) &#123;    var promise = new Promise(function(resolve, reject) &#123;        var client = new XMLHttpRequest();        client.open(&quot;GET&quot;, url);        client.onreadystatechange = handler;        client.responseType = &quot;json&quot;;        client.setRequesHeader(&quot;Accept&quot;, &quot;application/json&quot;);        client.send();                function handler() &#123;            if (this.readyState !== 4) &#123;                return;            &#125;            if (this.status === 200) &#123;                resolve(this.response);            &#125; else &#123;                reject(new Error(this.statusText));            &#125;        &#125;;    &#125;);    return promise;&#125;;// 调用getJSONgetJSON(&quot;/posts.json&quot;).then(function(json) &#123;    console.log(&#x27;Contents: &#x27; + json);&#125;, function(error) &#123;    console.error(&#x27;出错了&#x27;, error);&#125;);// 注: 用工厂模式,在getJSON函数里面首先创建了一个Promise实例,然后利用创建Ajax请求，最后返回该实例.调用时直接使用getJSON//  (url)即可// promise实例中的resolve和 reject方法,来自于调用时候的 .then里面的2个参数,第一个参数对应resolve,第二个参数对应reject\n\n\n\n\n\nVue基础Vue简介Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。 [6] 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。\n尤雨溪，前端框架Vue.js的作者，HTML5版Clear的打造人，独立开源开发者。曾就职于Google Creative Labs和Meteor Development Group。由于工作中大量接触开源的JavaScript项目，最后自己也走上了开源之路，现全职开发和维护Vue.js。\n1、简化dom操作\n2、前后端分离的开发\n3、数据双向绑定\nvscode\nnodeJS: http://nodejs.cn/download/vsstudio: https://code.visualstudio.com/在文件夹中 cmd code . 则直接打开当前工程。安装 auto rename tag插件。安装code runner插件。安装open in brower插件。安装live server插件。vetur 写vue必备插件Vue 2 Snippets 写vue必备插件axios插件VueHelper vscode插件，vue，vue-router和vuex的代码提示Path Intellisense 路径自动补全Auto Close Tag 自动闭合标签Beautify 格式化文件,保证正确的缩进HTML CSS Support CSS提示插件JavaScript (ES6) code snippets es6代码提示插件VSCode Great Icons 给文件夹增加图标的插件  \nMVVM框架\nmodel-view-viewmodel\nVue快速起步1、添加vue的js文件&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n\n2、声明挂载点（操作的dom对象）&lt;div id=&quot;app&quot;&gt;    &#123;&#123;name&#125;&#125;\t&lt;!-- 差值表达式，输出vue中的数据 --&gt;&lt;/div&gt;\n\n3、声明vue对象let vue = new Vue(&#123;        el:&quot;#app&quot;,\t//绑定挂载点        data:&#123;            name:&quot;关羽&quot;\t//声明属性（数据）        &#125;    &#125;);\n\n\n\n基础指令1、v-text    innerText  text()2、v-html  innerHTML html()3、v-on    事件    @4、v-bind  属性绑定    :&lt;div id=&quot;app&quot;&gt;    &lt;p v-text=&quot;message&quot;&gt;&lt;/p&gt;    &lt;span v-html=&quot;message2&quot;&gt;&lt;/span&gt;    &lt;button v-on:click=&quot;abc()&quot;&gt;btn&lt;/button&gt;    &lt;font v-bind:color=&quot;c&quot;&gt;ok&lt;/font&gt;    &lt;input v-bind:value=&quot;val&quot; &gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;hello vue world!!!&quot;,            message2:&quot;&lt;font color=&#x27;red&#x27;&gt;no&lt;/font&gt;&quot;,            c:&quot;red&quot;,            val:&quot;hello&quot;        &#125;,        methods: &#123;            abc()&#123;                alert(123);            &#125;        &#125;    &#125;);&lt;/script&gt;\n\n做了一个数量加减\n&lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;jian()&quot;&gt;-&lt;/button&gt;&lt;input size=&quot;3&quot; :value=&quot;count&quot;&gt;&lt;button @click=&quot;jia()&quot;&gt;+&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            count:0        &#125;,        methods: &#123;           jian()&#123;                this.count--;           &#125;,           jia()&#123;                this.count++;           &#125;        &#125;    &#125;);&lt;/script&gt;\n\n\n\n事件修饰符1、stop当页面出现事件冒泡，而业务需要各自触发，在底层事件中添加修饰符stop，当该事件执行后，不再进行冒泡。\n&lt;div id=&quot;app&quot;&gt;    &lt;div v-on:click=&quot;a()&quot; style=&quot;width: 600px; height: 600px; background-color: antiquewhite;&quot;&gt;        &lt;div v-on:click.stop=&quot;b()&quot;  style=&quot;width: 400px; height: 400px; background-color:blue;&quot;&gt;            &lt;button type=&quot;button&quot; v-on:click.stop=&quot;c()&quot;&gt;事件冒泡&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        methods: &#123;            a()&#123;                alert(&quot;a&quot;);            &#125;,            b()&#123;                alert(&quot;b&quot;);            &#125;,            c()&#123;                alert(&quot;c&quot;);            &#125;        &#125;    &#125;);&lt;/script&gt;\n\n2、prevent当触发事件的事件源有默认功能，通过prevent取消默认功能。\n&lt;div id=&quot;app&quot;&gt;    &lt;a @click=&quot;a()&quot; href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;    &lt;form action=&quot;index.html&quot;&gt;        &lt;button @click.prevent=&quot;a&quot;&gt;submit&lt;/button&gt;    &lt;/form&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        methods: &#123;           a()&#123;               alert(&quot;a&quot;);           &#125;        &#125;    &#125;);&lt;/script&gt;\n\n3、capture当有事件冒泡，被capture描述的事件会放在第一位执行，余下的冒泡继续执行\n&lt;div id=&quot;app&quot;&gt;    &lt;div v-on:click=&quot;a()&quot; style=&quot;width: 600px; height: 600px; background-color: antiquewhite;&quot;&gt;        &lt;div v-on:click.capture=&quot;b()&quot;  style=&quot;width: 400px; height: 400px; background-color:blue;&quot;&gt;            &lt;button type=&quot;button&quot; v-on:click=&quot;c()&quot;&gt;事件冒泡&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        methods: &#123;            a()&#123;                alert(&quot;a&quot;);            &#125;,            b()&#123;                alert(&quot;b&quot;);            &#125;,            c()&#123;                alert(&quot;c&quot;);            &#125;        &#125;    &#125;);&lt;/script&gt;\n\n4、once该事件执行一次\n&lt;div id=&quot;app&quot;&gt;    &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.once=&quot;a()&quot;&gt;百度&lt;/a&gt;    &lt;button @click.once=&quot;a()&quot;&gt;once&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        methods: &#123;            a()&#123;                alert(&quot;a&quot;);            &#125;        &#125;    &#125;);&lt;/script&gt;\n\n\n\n\n","tags":["vue2","es6"]},{"title":"vue第二篇-相关延伸","url":"/2022/07/19/vue%E7%AC%AC%E4%BA%8C%E7%AF%87-%E7%9B%B8%E5%85%B3%E5%BB%B6%E4%BC%B8/","content":"v-model双向绑定对Vue对象中数据进行修改，则所有展示该数据的位置都进行变化。\n&lt;div id=&quot;app&quot;&gt;    &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt;    &lt;input v-model=&quot;name&quot;&gt;    &lt;select v-model=&quot;name&quot;&gt;        &lt;option&gt;张无忌&lt;/option&gt;        &lt;option&gt;张三丰&lt;/option&gt;        &lt;option&gt;张翠山&lt;/option&gt;    &lt;/select&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            name:&quot;张三丰&quot;        &#125;    &#125;);&lt;/script&gt;\n\n\n\nVue绑定元素的class属性1、class添加方式&lt;div id=&quot;app&quot;&gt;    &lt;button @click=&quot;red()&quot;&gt;red&lt;/button&gt;    &lt;button @click=&quot;green()&quot;&gt;green&lt;/button&gt;    &lt;button @click=&quot;blue()&quot;&gt;blue&lt;/button&gt;    &lt;div id=&quot;div1&quot; style=&quot;width: 400px; height: 400px;&quot; v-bind:class=&quot;clazz&quot;&gt;    &lt;/div&gt;&lt;/div&gt;&lt;style&gt;    .red&#123;        background-color: red;    &#125;    .green&#123;        background-color: green;    &#125;    .blue&#123;        background-color: blue;    &#125;&lt;/style&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            clazz:&quot;red&quot;        &#125;,        methods: &#123;            red()&#123;                this.clazz = &quot;red&quot;;            &#125;,            green()&#123;                this.clazz = &quot;green&quot;;            &#125;,            blue()&#123;                this.clazz = &quot;blue&quot;;            &#125;        &#125;            &#125;);&lt;/script&gt;\n\n通过boolean值解决class是否添加\n&lt;div id=&quot;app&quot;&gt;    &lt;div id=&quot;div1&quot; style=&quot;width: 400px; height: 400px;&quot; :class=&quot;clazz&quot;&gt;    &lt;/div&gt;&lt;/div&gt;ji&lt;style&gt;    .border&#123;        border: 10px solid red;    &#125;    &lt;/style&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            clazz:&#123;&quot;border&quot;:false&#125;        &#125;            &#125;);&lt;/script&gt;\n\nclass值可以是多个，按照数据结构放置\n&lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;radio&quot; @click=&quot;border()&quot;&gt;加边框    &lt;input type=&quot;radio&quot; @click=&quot;bg()&quot;&gt;加背景    &lt;div id=&quot;div1&quot; style=&quot;width: 400px; height: 400px;&quot; :class=&quot;clazz&quot;&gt;    &lt;/div&gt;&lt;/div&gt;ji&lt;style&gt;    .border&#123;        border: 10px solid red;    &#125;    .bg&#123;        background-color: rosybrown;    &#125;&lt;/style&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            clazz:[]        &#125;,        methods: &#123;            border()&#123;                this.clazz.push(&quot;border&quot;);            &#125;,            bg()&#123;                this.clazz.push(&quot;bg&quot;);            &#125;        &#125;            &#125;);&lt;/script&gt;\n\n\n可以通过三目运算添加class\n\n2、style直接在:style中编写样式json结构\n可以在data中声明样式的变量，这个变量也可以是多个，用数组保存\n&lt;div id=&quot;app&quot;&gt;    &lt;!--         style属性添加内容时结构是width:400px        :style添加结构是&#123;width:&#x27;400px&#x27;&#125;    --&gt;        &lt;div id=&quot;div1&quot; :style=&quot;&#123;width:&#x27;400px&#x27;,height:&#x27;400px&#x27;,backgroundColor:&#x27;red&#x27;&#125;&quot;&gt;    &lt;/div&gt;    &lt;div id=&quot;div2&quot; :style=&quot;styleObj&quot;&gt;    &lt;/div&gt;    &lt;div id=&quot;div2&quot; :style=&quot;[styleObj,styleObj2]&quot;&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            styleObj:&#123;width:&#x27;400px&#x27;,height:&#x27;400px&#x27;,backgroundColor:&#x27;blue&#x27;&#125;,            styleObj2:&#123;border:&#x27;10px solid green&#x27;&#125;        &#125;            &#125;);&lt;/script&gt;\n\n\n\nv-for1、数组循环2、对象循环3、对象数组循环&lt;div id=&quot;app&quot;&gt;    &lt;ul&gt;        &lt;!--             1、循环数组时:            in前面可以加单参，就是值            in前面可以加双参，第一个是值，第二个是下标        --&gt;        &lt;li v-for=&quot;wujiang,index in wujiangs&quot;&gt;&#123;&#123;index+1&#125;&#125;,&#123;&#123;wujiang&#125;&#125;&lt;/li&gt;            &lt;/ul&gt;    &lt;!--             2、循环对象            第一个是值            第二个是属性            第三个是下标     --&gt;     &lt;p v-for=&quot;x,y,z,i in wujiang1&quot;&gt;&#123;&#123;x&#125;&#125;---&#123;&#123;y&#125;&#125;-----&#123;&#123;z&#125;&#125;&lt;/p&gt;     &lt;!--          3、循环对象数组     --&gt;     &lt;ul v-for=&quot;x in wujiangs2&quot;&gt;        &lt;li v-for=&quot;a in x&quot;&gt;            &#123;&#123;a&#125;&#125;        &lt;/li&gt;     &lt;/ul&gt;     &lt;!--          数据展示样例     --&gt;     &lt;table&gt;         &lt;tr&gt;             &lt;th&gt;编号&lt;/th&gt;             &lt;th&gt;姓名&lt;/th&gt;             &lt;th&gt;武器&lt;/th&gt;         &lt;/tr&gt;         &lt;tr v-for=&quot;wj,index in wujiangs2&quot;&gt;             &lt;th&gt;&#123;&#123;index+1&#125;&#125;&lt;/th&gt;             &lt;th v-text=&quot;wj.name&quot;&gt;&lt;/th&gt;             &lt;th v-text=&quot;wj.weapon&quot;&gt;&lt;/th&gt;         &lt;/tr&gt;     &lt;/table&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            wujiangs:[&#x27;黄忠&#x27;,&#x27;小乔&#x27;,&#x27;盾山&#x27;],            wujiang1:&#123;                name:&#x27;小乔&#x27;,                weapon:&#x27;扇子&#x27;            &#125;,            wujiangs2:[                &#123;                    name:&#x27;小乔&#x27;,                    weapon:&#x27;扇子&#x27;                &#125;,                &#123;                    name:&#x27;黄忠&#x27;,                    weapon:&#x27;大炮&#x27;                &#125;,            ]        &#125;            &#125;);&lt;/script&gt;\n\n\n\nv-if、v-showv-if和v-show都可以控制页面元素的显示与不显示\nv-if对于不显示的元素，不生成。\nv-show对于不显示的元素，生成并设置样式不可显\n如果该元素一直不显示就使用v-if\n如果该元素会根据状况一会显示一会不显示，则使用v-show\n&lt;div id=&quot;app&quot;&gt;    &lt;button v-if=&quot;permission.indexOf(&#x27;delete&#x27;)!=-1&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;           permission:&quot;update,add&quot;        &#125;            &#125;);&lt;/script&gt;\n\n\n\nVue进阶Vue全局过滤器可以跨Vue使用，字符串格式化、日期格式化、金额格式化等等。\n声明全局过滤器\n//全局过滤器   //生成过滤器，通过静态方法filter，第一个参是过滤器名称，第二个是过滤器功能（函数）   Vue.filter(&quot;dateFormat&quot;, function(value)&#123;       let year = value.getFullYear();       let month = value.getMonth()+1;       let date = value.getDate();       return `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125;`;   &#125;);\n\n使用过滤器\n&lt;div id=&quot;app&quot;&gt;    &#123;&#123;birth|dateFormat&#125;&#125;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt;    &#123;&#123;birth|dateFormat&#125;&#125;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    //全局过滤器    //生成过滤器，通过静态方法filter，第一个参是过滤器名称，第二个是过滤器功能（函数）    Vue.filter(&quot;dateFormat&quot;, function(value)&#123;        let year = value.getFullYear();        let month = value.getMonth()+1;        let date = value.getDate();        return `$&#123;year&#125;-$&#123;month&#125;-$&#123;date&#125;`;    &#125;);    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;           birth:new Date()        &#125;            &#125;);    let vue2 = new Vue(&#123;        el:&quot;#app2&quot;,        data:&#123;           birth:new Date()        &#125;            &#125;);&lt;/script&gt;\n\n\n\nVue私有过滤器在Vue对象中声明的过滤器，只能在当前Vue对象中使用，不能跨Vue使用。\n&lt;div id=&quot;app&quot;&gt;    &#123;&#123;salary|numFormat&#125;&#125;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt;    &#123;&#123;comm|numFormat&#125;&#125;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;        let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;           salary:30000  //30,000        &#125;,        filters: &#123;            &quot;numFormat&quot;:function(value)&#123;                value+=&quot;&quot;;                console.log(value.length);                let start = value.length-3;                console.log(start);                let front = value.substring(0,start);                console.log(&quot;front:&quot;+front);                let back = value.substring(start);                return `$&#123;front&#125;,$&#123;back&#125;`;            &#125;        &#125;            &#125;);    let vue2 = new Vue(&#123;        el:&quot;#app2&quot;,        data:&#123;           comm:5300  //5,300        &#125;            &#125;);&lt;/script&gt;\n\n\n\n按键修饰符获得键盘事件\n不需要在事件处理中判断点的是哪个键\n直接使用按键修饰符即可。\n@keyup.enter=&quot;add()&quot;   //在输入框中添加该事件及按键修饰符等同于点按钮\n\n\n\n&lt;div id=&quot;app&quot;&gt;    &lt;form&gt;        uname&lt;input name=&quot;uname&quot; id=&quot;uname&quot; v-model=&quot;user.uname&quot;&gt;        upwd&lt;input name=&quot;upwd&quot; id=&quot;upwd&quot; v-model=&quot;user.upwd&quot; @keyup.enter=&quot;add()&quot;&gt;        &lt;button type=&quot;button&quot; @click=&quot;add()&quot;&gt;add&lt;/button&gt;    &lt;/form&gt;    &lt;table width=&quot;600&quot; border=&quot;1&quot;&gt;        &lt;tr&gt;            &lt;th&gt;编号&lt;/th&gt;            &lt;th&gt;用户名&lt;/th&gt;            &lt;th&gt;密码&lt;/th&gt;        &lt;/tr&gt;        &lt;tr v-for=&quot;user,index in userList&quot;&gt;            &lt;th&gt;&#123;&#123;index+1&#125;&#125;&lt;/th&gt;            &lt;th&gt;&#123;&#123;user.uname&#125;&#125;&lt;/th&gt;            &lt;th&gt;&#123;&#123;user.upwd&#125;&#125;&lt;/th&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            user:&#123;                uname:&quot;&quot;,                upwd:&quot;&quot;            &#125;,           userList:[               &#123;&quot;uname&quot;:&quot;admin&quot;,&quot;upwd&quot;:&quot;123&quot;&#125;,                &#123;&quot;uname&quot;:&quot;andy&quot;,&quot;upwd&quot;:&quot;456&quot;&#125;           ]        &#125;,        methods: &#123;            add()&#123;                this.userList.push(this.user);            &#125;        &#125;            &#125;);&lt;/script&gt;\n\n\n\nVue自定义指令v-text、v-html\n当前需要新的指令完成一定的功能\n例如：将焦点直接设置某个控件上\n全局自定义指令和局部自定义指令\n&lt;div id=&quot;app&quot;&gt;    &lt;input name=&quot;n1&quot; &gt;    &lt;input name=&quot;n2&quot; v-focus &gt;    &lt;input name=&quot;n3&quot; &gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt;    &lt;input name=&quot;n1&quot; &gt;    &lt;input name=&quot;n2&quot; &gt;    &lt;input name=&quot;n3&quot; v-focus &gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    //定义全局的自定义指令    //    // Vue.directive(&quot;focus&quot;,&#123;    //    inserted:function(dom)&#123;    //        dom.style.backgroundColor=&#x27;red&#x27;;    //         dom.focus();    //    &#125;     // &#125;);    let vue = new Vue(&#123;        el:&quot;#app&quot;,        directives: &#123;            &quot;focus&quot;:&#123;                inserted:function(dom)&#123;                    dom.style.backgroundColor=&quot;green&quot;;                    dom.focus();                &#125;            &#125;        &#125;            &#125;);    let vue2 = new Vue(&#123;        el:&quot;#app2&quot;            &#125;);&lt;/script&gt;\n\n\n\n\n\nVue组件的生命周期\n\n1、初始化数据beforeCreate() //这时Vue还没有初始化数据，没有el、data等等，只有默认事件和vue生命周期\ncreated()  //data、methods都已经初始化了，这时还没有el\n2、挂载beforeMount()  //获得el，但是el的数据没有添加上\nmounted()    //将数据与模板整合。\n3、修改数据beforeUpdate()    //修改数据之前方法\nupdated()    //修改数据之后的方法\n4、销毁this.$destroy();\n完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。\n触发 beforeDestroy 和 destroyed 的钩子。\nbeforeDestroy()  //销毁之前，还可以使用vue的数据\ndestroy();    //销毁之后，所有vue数据不可用。\n&lt;div id=&quot;app&quot;&gt;   &#123;&#123;message&#125;&#125;   &lt;input v-bind:value=&quot;message&quot;&gt;   &lt;button @click=&quot;message=&#x27;数据修改了&#x27;&quot;&gt;修改message数据&lt;/button&gt;   &lt;button @click=&quot;clear()&quot;&gt;clear&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;       let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;            message:&quot;hello vue life!!&quot;        &#125;,        methods: &#123;          clear()&#123;              this.$destroy();          &#125;          &#125;,        //编写钩子函数 在创建、挂载、修改、销毁4个点分别2个钩子函数        beforeCreate () &#123;            console.log(this.$el);            console.log(this.$data);            console.log(this.message);        &#125;,        created () &#123;            console.log(this.$el);            console.log(this.$data);            console.log(this.message);        &#125;,        beforeMount () &#123;            console.log(this.$el);            console.log(this.$data);            console.log(this.message);        &#125;,        mounted () &#123;            console.log(this.$el);            console.log(this.$data);            console.log(this.message);        &#125;,        //this.$el的数据已经解析        beforeUpdate () &#123;            console.log(this.$el);            let div = document.getElementById(&quot;app&quot;);            console.log(div.innerHTML);            console.log(this.message);        &#125;,        updated () &#123;            console.log(this.$el);            let div = document.getElementById(&quot;app&quot;);            console.log(div.innerHTML);            console.log(this.message);        &#125;,                //虽然这里的数据还可以看到，但是所有功能已经不存在了。        beforeDestroy () &#123;            console.log(&quot;------------------&quot;);            console.log(this.$el);            let div = document.getElementById(&quot;app&quot;);            console.log(div.innerHTML);            console.log(this.message);        &#125;,        destroyed () &#123;            console.log(this.$el);            let div = document.getElementById(&quot;app&quot;);            console.log(div.innerHTML);            console.log(this.message);          &#125;                    &#125;);&lt;/script&gt;\n\n\n\nComputed和Watch1、computed计算列结构类似于方法\ncomputed: &#123;            result:function()&#123;                return parseInt(this.num1)+parseInt(this.num2);            &#125;        &#125;\n\n在需要展示的地方，放置计算列的名称\n当计算列中的属性值发生变化，则重新计算并加载到页面\n2、watch&lt;div id=&quot;app&quot;&gt;    &lt;input v-model=&quot;age&quot; &gt;    &#123;&#123;age&#125;&#125;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    let vue = new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;           age:0        &#125;,        watch: &#123;            age(newVal,oldVal)&#123;                this.age = newVal.replace(/[^\\d]/g,&#x27;&#x27;);            &#125;        &#125;            &#125;);&lt;/script&gt;\n\n\n\n","tags":["vue2"]},{"title":"xml技术","url":"/2022/05/19/xml%E6%8A%80%E6%9C%AF/","content":"xml概括xml是可扩展标记语言(Extensive Markup Language)。\n可扩展所谓的可扩展其实是相对于html来说的因为html中的标签都是固定的，提前都定义好每个标签代表什么意思，我们自己是不可以瞎写的而xml可以扩展，也就是说可以瞎写，随便写\n&lt;yuema&gt;&lt;/yuema&gt;\n\n标记语言代码是由标签组成的由一对尖括号&lt;&gt;组成的\nxml和html区别1.html的标签都是预定义的                    xml的标签都是自定义的        \n2.html是非常不严谨的，也就说我们很难把它给写错了        xml是非常严谨的，也就说我们很难把它给写对了\n3.html是用来也写页面，展示数据        xml是用来当做配置文件的，存储数据\nxml作用当做配置文件来使用\nxml作为配置文件和properties配置文件的区别properties配置文件：    主要用于单项配置\njdbc.properties：\tdriver=com.mysql.jdbc.Driver\turl=jdbc:mysql://localhost:3306/db1\tusername=root\tpassword=root\t\t\t\t\tdriver=com.oracle.jdbc.Driver\turl=jdbc:oracle://localhost:3306/db1\tusername=root\tpassword=123\nxml配置文件：    主要用于多项配置\njdbc.xml：\t&lt;databases&gt;\t\t&lt;database id=&quot;mysql&quot;&gt;\t\t\t&lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;\t\t\t&lt;url&gt;jdbc:mysql://localhost:3306/db1&lt;/url&gt;\t\t\t&lt;username&gt;root&lt;/username&gt;\t\t\t&lt;password&gt;root&lt;/password&gt;\t\t&lt;/database&gt;\t\t&lt;database id=&quot;oracle&quot;&gt;\t\t\t&lt;driver&gt;com.oracle.jdbc.Driver&lt;/driver&gt;\t\t\t&lt;url&gt;jdbc:oracle://localhost:3306/db2&lt;/url&gt;\t\t\t&lt;username&gt;root&lt;/username&gt;\t\t\t&lt;password&gt;123&lt;/password&gt;\t\t&lt;/database&gt;\t&lt;/databases&gt;\n案例#1.创建一个文本文件，后缀名该为xml#2.在xml文件中写以下内容：\t&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\t&lt;students&gt;\t\t&lt;student id=&quot;9527&quot;&gt;\t\t\t&lt;name&gt;tom&lt;/name&gt;\t\t\t&lt;age&gt;18&lt;/age&gt;\t\t&lt;/student&gt;\t\t&lt;student id=&quot;9528&quot;&gt;\t\t\t&lt;name&gt;jerry&lt;/name&gt;\t\t\t&lt;age&gt;19&lt;/age&gt;\t\t&lt;/student&gt;\t&lt;/students&gt;\t\t\t#3.通过浏览器打开，查看是否编写成功\n\n语法1.xml文件要以.xml为后缀名2.xml文件的第一行要写文档声明        注意：version属性是必须写的    version属性：版本号    encoding属性：告诉浏览器用什么编码方式打开该配置文件\n3.xml文件中有且只能有一个根标签4.xml文件中的标签中的属性要由单引号或者双引号括起来5.xml文件中标签的嵌套\n&lt;aaa&gt;\t&lt;bbb&gt;&lt;/bbb&gt;&lt;/aaa&gt;&lt;aaa&gt;\t&lt;bbb/&gt;&lt;/aaa&gt;\t&lt;aaa&gt;&lt;bbb&gt;&lt;/aaa&gt;&lt;/bbb&gt;\n6.xml文件中的标签名是严格区分大小写的    html：            xml：        \n7.xml文件中的标签名的命名规则：    1.标签名可以由数字，字母和一些字符组成    2.标签名的首字母不能是数字和标点符号    3.标签名中不能有空格\n8.CDATA区域格式：\n\t\t&lt;![CDATA[\t内容]]&gt;\n\n例子：\n&lt;![CDATA[\t&lt;bbb&gt;约吗&lt;/bbb&gt;\t&lt;ccc&gt;在吗&lt;/ccc&gt;\t&lt;bbb&gt;约吗&lt;/bbb&gt;\t&lt;ccc&gt;在吗&lt;/ccc&gt;\t&lt;bbb&gt;约吗&lt;/bbb&gt;\t&lt;ccc&gt;在吗&lt;/ccc&gt;]]&gt;\n约束约束的分类1.dtd约束    提供dtd约束文档2.schema约束    提供xsd约束文档\n约束区别1.schema约束比dtd约束难2.schema约束比dtd约束好\n推荐使用schema约束\ndtd约束1.创建xml配置文件2.写xml文档声明3.在xml配置文件中引入已经提供好的dtd约束文档4.根据dtd约束文档来写xml配置文件中的标签\n方式一：\t\t\t\t\t\t&lt;!DOCTYPE 根标签 [约束文档的内容]&gt;\t\t\t\t\t\t\t\t\t\t\t\t例子：\t\t\t\t\t\t\t&lt;?xml version=&quot;1.0&quot;?&gt;\t\t\t\t\t\t\t&lt;!DOCTYPE note [\t\t\t\t\t\t\t  &lt;!ELEMENT note (to,from,heading,body)&gt;\t\t\t\t\t\t\t  &lt;!ELEMENT to      (#PCDATA)&gt;\t\t\t\t\t\t\t  &lt;!ELEMENT from    (#PCDATA)&gt;\t\t\t\t\t\t\t  &lt;!ELEMENT heading (#PCDATA)&gt;\t\t\t\t\t\t\t  &lt;!ELEMENT body    (#PCDATA)&gt;\t\t\t\t\t\t\t]&gt;\t\t\t\t\t\t\t&lt;note&gt;\t\t\t\t\t\t\t  &lt;to&gt;George&lt;/to&gt;\t\t\t\t\t\t\t  &lt;from&gt;John&lt;/from&gt;\t\t\t\t\t\t\t  &lt;heading&gt;Reminder&lt;/heading&gt;\t\t\t\t\t\t\t  &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;\t\t\t\t\t\t\t&lt;/note&gt;\t\t\t\t\t\t\t\t\t\t\t\t方式二：\t\t\t\t\t\t&lt;!DOCTYPE 根标签 SYSTEM &quot;约束文档的文件名&quot;&gt;\t\t\t\t\t\t\t\t\t\t\t\t例子：\t\t\t\t\t\t\t&lt;?xml version=&quot;1.0&quot;?&gt;\t\t\t\t\t\t\t&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;\t\t\t\t\t\t\t&lt;note&gt;\t\t\t\t\t\t\t\t&lt;to&gt;George&lt;/to&gt;\t\t\t\t\t\t\t\t&lt;from&gt;John&lt;/from&gt;\t\t\t\t\t\t\t\t&lt;heading&gt;Reminder&lt;/heading&gt;\t\t\t\t\t\t\t\t&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;\t\t\t\t\t\t\t&lt;/note&gt; \t\t\t\t\t\t\t\t\t\t\t\t方式三：\t\t\t\t\t\t引入网络端的某个约束文档\t\t\t\t\t\t\t\t\t\t\t\t&lt;!DOCTYPE 根标签 PUBLIC &quot;约束文档的文件名&quot; &quot;约束文档的URL&quot;&gt;\nschema约束其实schema约束文档，自身也是一个xml文件1.创建xml配置文件2.写xml文档声明3.在xml配置文件中引入已经提供好的schema约束文档引入步骤：    1.找到根标签    2.引入默认的名称空间        xmlns=”约束文档中targetNamespace的值”    3.关联schema的约束文档        schemaLocation=”默认名称空间的值 + 约束文档的名字”    4.引入schemaLocation的名称空间        xmlns:xsi=”xmlns:xs的值 + -instance”    5.在schemaLocation前面加上xsi:\n4.根据schema约束文档来写xml配置文件中的标签\n","tags":["蜗牛学院笔记","xml"]},{"title":"二进制运算技巧","url":"/2022/10/19/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/","content":"最低位的移除与获取\n移除：n &amp; (n - 1)\n\n获取：n &amp; (-n)\n\n\n","tags":["二进制"]},{"title":"从pdf中提取内容","url":"/2022/03/02/%E4%BB%8Epdf%E4%B8%AD%E6%8F%90%E5%8F%96%E5%86%85%E5%AE%B9/","content":"使用Fitz正则化代码如下import pdfplumberimport osimport fitzimport reimport timepdf_path=r&#x27;f://1.pdf&#x27;text_path=r&#x27;f://2.txt&#x27;word_path=r&#x27;f://3.docx&#x27;pic_path=r&#x27;f://picture&#x27;#提取文字#文本t0=time.process_time()with pdfplumber.open(pdf_path) as pdf:    for page in pdf.pages:        content=page.extract_text()        with open(text_path,&#x27;a&#x27;,encoding=&#x27;utf-8&#x27;) as text:            text.write(content)t1=time.process_time()print(f&#x27;text提取完成，用时：&#123;t1-t0&#125;&#x27;)#提取图片t0=time.process_time()if not os.path.exists(pic_path):    os.makedirs(pic_path)pdf=fitz.open(pdf_path)ob_num=pdf.xref_length()print(f&#x27;Object数量：&#123;ob_num&#125;&#x27;)#匹配正则表达式checkXO = r&quot;/Type(?= */XObject)&quot;checkIM = r&quot;/Subtype(?= */Image)&quot;imgcount=0for index in range(1,ob_num):    text=pdf.xref_object(index)    isXObject=re.search(checkXO,text)    isImage=re.search(checkIM,text)    if not isXObject or not isImage:        continue    imgcount+=1    #匹配图片    pix=fitz.Pixmap(pdf,index)    pic_name=f&quot;img_&#123;imgcount&#125;.png&quot;    new_name = os.path.join(pic_path, pic_name)    #控制像素，不能过大，否则ValueError: unsupported colorspace for &#x27;png&#x27;    if pix.n&lt;3:        pix.save(new_name)    else:        pix0=fitz.Pixmap(fitz.csRGB,pix)        pix0.save(new_name)        pix0=None    pix=Noneprint(f&#x27;图片数量：&#123;imgcount&#125;&#x27;)t1=time.process_time()print(f&#x27;图片提取完成，用时：&#123;t1-t0&#125;&#x27;)","categories":["python"],"tags":["python","pdf","提取"]},{"title":"使用docker部署redis","url":"/2022/04/21/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2redis/","content":"先拉取redis镜像docker pull redis\n\n创建挂载目录mkdir -p xxx/redis/confmkdir -p xxx/redis/data\n\n构建容器docker run -d -it --name jeecg_redis -p 6379:6379 -v /xxx/redis/conf/redis.conf:/etc/redis/redis.conf -v /xxx/redis/data:/data redis# 注意下redis.conf是个目录，不用提前创建文件\n\n重启容器和redis修改挂载的redis.conf后一定记得重启容器，不能只重启redis服务\ndocker id restart# 进入容器重启redis服务docker exec -it id bashe","tags":["docker","centos/linux","redis"]},{"title":"会话技术","url":"/2022/07/21/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/","content":"会话技术会话概念概念就是你与我之间的对话，一次会话，一次对话，在一次对话中，会聊很多句在一次会话中，会有多次请求和多次响应。当其中一方断开的时候，会话结束\n作用在多次请求和响应之间可以实现数据的共享\nCookie定位：客户端的会话技术\ncookie的入门小案例ServletDemo1：\t//方式一(原始写法)：\tresponse.setHeader(&quot;set-cookie&quot;, &quot;name=jerry&quot;);\t\t//方式二：\t//创建cookie对象\tCookie cookie = new Cookie(&quot;name&quot;, &quot;tom&quot;);\t\t//添加cookie，设置cookie的响应信息\tresponse.addCookie(cookie);ServletDemo2：\t//获取cookie\tCookie[] cookies = request.getCookies();\tSystem.out.println(cookies);\tfor (Cookie cookie : cookies) &#123;\t\tString name = cookie.getName();\t\tString value = cookie.getValue();\t\tSystem.out.println(name + &quot;...&quot; + value);\t&#125;\n知识点：    1.cookie能不能写多个\n        可以携带多个cookie\n        \n        如果多个cookie的名称相同的话，会怎么样呢？\n            会被覆盖\n    \n    2.cookie的value值可不可以存储中文\n        如果使用的是创建Cookie对象的方式，value值为中文是不会出现乱码问题的\n        如果使用的是原始方式设置cookie，value值为中文就会出现中文乱码\n            如何解决呢？\n                对中文进行URL编码和URL解码\n    \n    3.cookie的生命周期\n        cookie默认的生命周期：当浏览器关闭，缓存释放，cookie消失\n    \n        怎么样能够让即使浏览器关了，cookie也不消失呢(延长cookie生命时长)？\n            设置cookie对象中的setMaxAge()方法，单位是秒，如果指定了秒值，那cookie就不会存储在浏览器的缓存中，\n            而是存储到了本地磁盘，但是时间一到，本地磁盘中的数据也会消失。\n            \n            如果秒值设置为负数，就是cookie的默认生命周期\n            如果秒值设置为0，响应回浏览器之后，cookiez立即消失\n    \n    4.cookie的携带范围\n        默认情况下，如果我们没有设置cookie的携带范围，那携带范围就是当前的整个项目\n        \n        我们能不能通过自己设置去控制携带范围？\n            可以\n            设置cookie对象中的setPath()方法\n            \n            //设置携带范围\n            //cookie.setPath(&quot;/day59&quot;);//默认设置\n            //cookie.setPath(&quot;/day59/servletDemo9&quot;);//访问具体的某一个资源才会携带cookie\n            //cookie.setPath(&quot;/&quot;);//只要是当前服务器所部署的项目，访问里面所有的资源都会携带cookie\n            \n\nSession定位：服务器端的会话技术    session是一个域对象：        session域对象的范围是一次会话的范围\nsetAttribute(String key, Object value)getAttribute(String key)removeAttribute(String key)\nsession的入门小案例？ServletDemo01:\t//获取session对象\tHttpSession session = request.getSession();\t\t//向session域中存储数据\tsession.setAttribute(&quot;name&quot;, &quot;tom&quot;);ServletDemo02:\t//获取session对象\tHttpSession session = request.getSession();\t\t//从session域中获取数据\tObject value = session.getAttribute(&quot;name&quot;);\tSystem.out.println(value);\n知识点    1.如果浏览器关闭，服务器没有关闭，会有什么情况发生呢？\n        因为浏览器关闭，缓存消失，缓存中的JSESSIONID=id也就随之消失了，\n        当打开浏览器再次访问服务器中的资源的时候，是不会携带cookie的，\n        就获取不到session对象，只能重新创建新的session对象，响应的时候会携带set-cookie。\n        \n        如果希望下次浏览器访问同一个资源，依然会携带cookie:JSESSIONID=ID的话，该怎么办？\n            //手动创建cookie，并且将底层自己创建的cookie给覆盖掉\n            Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId());\n            //设置生存时长\n            cookie.setMaxAge(60);\n            //响应回去\n            response.addCookie(cookie);\n\n    2.如果服务器关闭，浏览器不关闭，会有什么情况发生呢？\n        服务器的非正常关闭：\n            session对象就会从内存中消失\n            \n            再一次开启开启服务器，通过浏览器访问服务器中的资源，虽然会携带cookie的请求头，但是由于服务器\n            已经没有了session对象，会重新创建一个新的session对象，然后回设置响应头set-cookie:......\n        \n        服务器的正常关闭：\n            session对象就会从内存中消失\n            \n            但是在消失之前就会进行钝化(就是将session对象存储到了本地磁盘),\n            然后再一次开启服务器，会进行活化(激活，就是将sessio对象从本地磁盘还原到服务器的内存中)，\n            通过浏览器访问服务器中的资源，会携带cookie的请求头，然后服务器就匹配到了，就能够获取到数据\n        序列化操作？\n            将对象以流的形式存储到本地磁盘\n            \n        反序列化操作？\n            将本地磁盘中的数据还原成内存中的对象\n            \n    3.session在什么情况下会销毁？\n        1.服务器关闭\n        2.session自杀\n            session.invalidate();\n        3.设置session的存活时长\n            默认存活时长，30分钟\n            &lt;session-config&gt;\n                &lt;session-timeout&gt;30&lt;/session-timeout&gt;\n            &lt;/session-config&gt;    \n\n","tags":["Cookie","Session","会话技术"]},{"title":"博客上传报错汇总","url":"/2022/01/02/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E6%8A%A5%E9%94%99/","content":"hexo d报错原因：问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。\n解决办法：删除.deploy_git文件夹;\n输入git config --global core.autocrlf false\n然后，依次执行：\nhexo cleanhexo ghexo d","categories":["计算机","博客"],"tags":["博客","随笔"]},{"title":"各类数据结构实现","url":"/2022/09/13/%E5%90%84%E7%B1%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/","content":"稀疏数组1.概念介绍当一个数据中大部分为同一个值时，可以使用稀疏数组来保护该数组。\n2.数理方法1.记录数组一共有几行几列，有多少个不同的值\n2.把具有不同值的元素的行列及值记录在一个小规模数组上，从而缩小程序规模\n\n3.代码实现package com.atguigu.sparsearray;public class SparseArray &#123;\tpublic static void main(String[] args) &#123;\t\t// 创建一个原始的二维数组 11*11\t\t// 0: 表示没有棋子  1表示黑子 2表示篮子\t\tint chessArr1[][] = new int[11][11];\t\tchessArr1[1][2] = 1;\t\tchessArr1[2][3] = 2;\t\tchessArr1[4][5] = 2;\t\t// 输出原始的二维数组\t\tSystem.out.println(&quot;Ô­Ê¼µÄ¶þÎ¬Êý×é~~&quot;);\t\tfor (int[] row : chessArr1) &#123;\t\t\tfor (int data : row) &#123;\t\t\t\tSystem.out.printf(&quot;%d\\t&quot;, data);\t\t\t&#125;\t\t\tSystem.out.println();\t\t&#125;\t\t// 将二维数组转化为稀疏数组\t\t// 1. 先遍历二维数组  得到非0数据个数\t\tint sum = 0;\t\tfor (int i = 0; i &lt; 11; i++) &#123;\t\t\tfor (int j = 0; j &lt; 11; j++) &#123;\t\t\t\tif (chessArr1[i][j] != 0) &#123;\t\t\t\t\tsum++;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t// 2.创建对应稀疏数组个数\t\tint sparseArr[][] = new int[sum + 1][3];\t\t// 给稀疏数组赋值\t\tsparseArr[0][0] = 11;\t\tsparseArr[0][1] = 11;\t\tsparseArr[0][2] = sum;\t\t\t\t// 遍历二维数组 将非0的值存放到sparseARR中\t\tint count = 0; //count 用于记录几个非零数据\t\tfor (int i = 0; i &lt; 11; i++) &#123;\t\t\tfor (int j = 0; j &lt; 11; j++) &#123;\t\t\t\tif (chessArr1[i][j] != 0) &#123;\t\t\t\t\tcount++;\t\t\t\t\tsparseArr[count][0] = i;\t\t\t\t\tsparseArr[count][1] = j;\t\t\t\t\tsparseArr[count][2] = chessArr1[i][j];\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\t\t\t// 输出稀疏数组的形式\t\tSystem.out.println();\t\tSystem.out.println(&quot;µÃµ½Ï¡ÊèÊý×éÎª~~~~&quot;);\t\tfor (int i = 0; i &lt; sparseArr.length; i++) &#123;\t\t\tSystem.out.printf(&quot;%d\\t%d\\t%d\\t\\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);\t\t&#125;\t\tSystem.out.println();\t\t\t\t//将稀疏数组恢复成原始的二维数组\t\t/*\t\t *  1. 先读稀疏数组的第一行，根据第一行数据，创建原始的二维数组\t\t\t2. 在读取稀疏数组后面几行数据，并赋给原始的二维数组即可\t\t */\t\t\t\t//1.先读稀疏数组的第一行，根据第一行数据，创建原始的二维数组\t\t\t\tint chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];\t\t\t\t//2. 在读取稀疏数组后面几行数据，并赋给原始的二维数组即可\t\t\t\tfor(int i = 1; i &lt; sparseArr.length; i++) &#123;\t\t\tchessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\t\t&#125;\t\t\t\t// 输出恢复后的二维数组\t\tSystem.out.println();\t\tSystem.out.println(&quot;»Ö¸´ºóµÄ¶þÎ¬Êý×é&quot;);\t\t\t\tfor (int[] row : chessArr2) &#123;\t\t\tfor (int data : row) &#123;\t\t\t\tSystem.out.printf(&quot;%d\\t&quot;, data);\t\t\t&#125;\t\t\tSystem.out.println();\t\t&#125;\t&#125;&#125;\n\n\n\n\n\n队列","tags":["数据结构"]},{"title":"opencv图像灰度处理","url":"/2022/01/02/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86/","content":"灰度处理imread()函数import cv2img0=cv2.imread(&#x27;image0.jpg&#x27;,0)img1=cv2.imread(&#x27;image0.jpg&#x27;,1)print(img0.shape)print(img1.shape)\n\ncvtColor()函数import cv2img=cv2.imread(&#x27;image0.jpg&#x27;,1)dst=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  #颜色空间转换    1 data   2BGR gra\n\nR=G=B=grey 取平均值import cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeheight=imgInfo[0]width=imgInfo[1]#RGB  R=G=B=gray--------------取平均值dst=np.zeros((height,width,3),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r)=img[i,j]        gray=(int(b)+int(g)+int(r))/3             #uint进行相加时容易溢出，所以先取整数再转换回来        dst[i,j]=np.uint8(gray)cv2.imshow(&#x27;dst&#x27;,dst)cv2.waitKey(0)\n\n神奇的心理学公式gray=r0.299+g0.587+b*0.114\nimport cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeheight=imgInfo[0]width=imgInfo[1]#RGB  R=G=B=gray--------------取平均值dst=np.zeros((height,width,3),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r)=img[i,j]        b=int(b)        g=int(g)        r=int(r)        gray=r*0.299+g*0.587+b*0.114            #uint进行相加时容易溢出，所以先取整数再转换回来        dst[i,j]=np.uint8(gray)\n\n算法优化定点运算&gt;浮点运算&gt;移位运算\n#gray=r*0.299+g*0.587+b*0.114#gray=(r*1+g*2+b*1)/4      #浮点转换为定点运算gray=(r+(g&lt;&lt;1)+b)&gt;&gt;2       #定点运算转换为移位运算\n","categories":["机器学习","opencv"],"tags":["机器学习","opencv","计算机视觉"]},{"title":"天气与电力预测","url":"/2022/09/11/%E5%A4%A9%E6%B0%94%E4%B8%8E%E7%94%B5%E5%8A%9B%E9%A2%84%E6%B5%8B/","content":""},{"title":"在centos终端下启动应用程序","url":"/2022/04/11/%E5%9C%A8centos%E7%BB%88%E7%AB%AF%E4%B8%8B%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","content":"虚拟机下运行ide好饭好烦，于是我尝试建立软链接在终端直接启动。\n建立软链接ln -s /[可执行文件路径] /usr/bin/[应用程序名]\n\n更新hash表rehash（更新hash表）ls -al /usr/bin|grep pycharm(可以通过此命令来查询hash表是否更新成功)\n\n终端启动","tags":["centos"]},{"title":"对bert模型的新认知","url":"/2022/09/05/%E5%AF%B9bert%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%96%B0%E8%AE%A4%E7%9F%A5/","content":"bert结构输入表示当输入为单个文本时，Bert输入的第一个序列是特殊类别次元“”(classfication)、不同语句连接时使用分隔词元“”（separate）。\n三个embding层\nToken Embeddingstoken embedding 层是要将各个词转换成固定维度的向量。在BERT中，每个词会被转换成768维的向量表示。输入文本在送入token embeddings 层之前要先进行tokenization处理。此外，两个特殊的token会被插入到tokenization的结果的开头 ([CLS])和结尾 ([SEP]) 。它们视为后面的分类任务和划分句子对服务的。\nSegment Embeddingssegment embeddings用于区分一个句子对中的两个句子，使bert可以判断两端文本是否相似。他只有两种向量表示，前一个向量是把0赋给第一个句子中的各个token, 后一个向量是把1赋给第二个句子中的各个token。如果输入仅仅只有一个句子，那么它的segment embedding就是全0。\nPosition Embeddingsbert模型无法编码文本的顺序性，所以需要位置编码。\n合成合成基本是相加起来，bert本质是transform模型的一个变种，只不过修改了Encoder层。与TransformerEncoder不同，BERTEncoder使用片段嵌入和可学习的位置嵌入。\n\n如图，BERT选择Transformer编码器作为其双向架构。在Transformer编码器中常见是，位置嵌入被加入到输入序列的每个位置。然而，与原始的Transformer编码器不同，BERT使用可学习的位置嵌入。BERT输入序列的嵌入是词元嵌入、片段嵌入和位置嵌入的和。\n但也有其他许多方式。如苏神这篇文章里的![https://kexue.fm/archives/8130]。\n掩蔽语言模型（Masked Language Modeling）语言模型使用左侧的上下文预测词元。为了双向编码上下文以表示每个词元，BERT随机掩蔽词元并使用来自双向上下文的词元以自监督的方式预测掩蔽词元。此任务称为掩蔽语言模型。\n在这个预训练任务中，将随机选择15%的词元作为预测的掩蔽词元。要预测一个掩蔽词元而不使用标签作弊，一个简单的方法是总是用一个特殊的“”替换输入序列中的词元。然而，人造特殊词元“”不会出现在微调中。为了避免预训练和微调之间的这种不匹配，如果为预测而屏蔽词元（例如，在“this movie is great”中选择掩蔽和预测“great”），则在输入中将其替换为：\n\n80%时间为特殊的““词元（例如，“this movie is great”变为“this movie is”；\n10%时间为随机词元（例如，“this movie is great”变为“this movie is drink”）；\n10%时间内为不变的标签词元（例如，“this movie is great”变为“this movie is great”）。\n\n下一句预测（Next Sentence Prediction）尽管掩蔽语言建模能够编码双向上下文来表示单词，但它不能显式地建模文本对之间的逻辑关系。为了帮助理解两个文本序列之间的关系，BERT在预训练中考虑了一个二元分类任务——下一句预测。在为预训练生成句子对时，有一半的时间它们确实是标签为“真”的连续句子；在另一半的时间里，第二个句子是从语料库中随机抽取的，标记为“假”。\nBert的代码实现代码结构#@saveclass BERTEncoder(nn.Module):    &quot;&quot;&quot;BERT编码器&quot;&quot;&quot;    def __init__(self, vocab_size, num_hiddens, norm_shape, ffn_num_input,                 ffn_num_hiddens, num_heads, num_layers, dropout,                 max_len=1000, key_size=768, query_size=768, value_size=768,                 **kwargs):        super(BERTEncoder, self).__init__(**kwargs)        self.token_embedding = nn.Embedding(vocab_size, num_hiddens)        self.segment_embedding = nn.Embedding(2, num_hiddens)        self.blks = nn.Sequential()        for i in range(num_layers):            self.blks.add_module(f&quot;&#123;i&#125;&quot;, d2l.EncoderBlock(                key_size, query_size, value_size, num_hiddens, norm_shape,                ffn_num_input, ffn_num_hiddens, num_heads, dropout, True))        # 在BERT中，位置嵌入是可学习的，因此我们创建一个足够长的位置嵌入参数        self.pos_embedding = nn.Parameter(torch.randn(1, max_len,                                                      num_hiddens))    def forward(self, tokens, segments, valid_lens):        # 在以下代码段中，X的形状保持不变：（批量大小，最大序列长度，num_hiddens）        X = self.token_embedding(tokens) + self.segment_embedding(segments)        X = X + self.pos_embedding.data[:, :X.shape[1], :]        for blk in self.blks:            X = blk(X, valid_lens)        return Xvocab_size, num_hiddens, ffn_num_hiddens, num_heads = 10000, 768, 1024, 4norm_shape, ffn_num_input, num_layers, dropout = [768], 768, 2, 0.2encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape, ffn_num_input,                      ffn_num_hiddens, num_heads, num_layers, dropout)       #@saveclass MaskLM(nn.Module):    &quot;&quot;&quot;BERT的掩蔽语言模型任务&quot;&quot;&quot;    def __init__(self, vocab_size, num_hiddens, num_inputs=768, **kwargs):        super(MaskLM, self).__init__(**kwargs)        self.mlp = nn.Sequential(nn.Linear(num_inputs, num_hiddens),                                 nn.ReLU(),                                 nn.LayerNorm(num_hiddens),                                 nn.Linear(num_hiddens, vocab_size))    def forward(self, X, pred_positions):        num_pred_positions = pred_positions.shape[1]        pred_positions = pred_positions.reshape(-1)        batch_size = X.shape[0]        batch_idx = torch.arange(0, batch_size)        # 假设batch_size=2，num_pred_positions=3        # 那么batch_idx是np.array（[0,0,0,1,1,1]）        batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions)        masked_X = X[batch_idx, pred_positions]        masked_X = masked_X.reshape((batch_size, num_pred_positions, -1))        mlm_Y_hat = self.mlp(masked_X)        return mlm_Y_hat        class NextSentencePred(nn.Module):    &quot;&quot;&quot;BERT的下一句预测任务&quot;&quot;&quot;    def __init__(self, num_inputs, **kwargs):        super(NextSentencePred, self).__init__(**kwargs)        self.output = nn.Linear(num_inputs, 2)    def forward(self, X):        # X的形状：(batchsize,num_hiddens)        return self.output(X)            # 整合代码class BERTModel(nn.Module):    &quot;&quot;&quot;BERT模型&quot;&quot;&quot;    def __init__(self, vocab_size, num_hiddens, norm_shape, ffn_num_input,                 ffn_num_hiddens, num_heads, num_layers, dropout,                 max_len=1000, key_size=768, query_size=768, value_size=768,                 hid_in_features=768, mlm_in_features=768,                 nsp_in_features=768):        super(BERTModel, self).__init__()        self.encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape,                    ffn_num_input, ffn_num_hiddens, num_heads, num_layers,                    dropout, max_len=max_len, key_size=key_size,                    query_size=query_size, value_size=value_size)        self.hidden = nn.Sequential(nn.Linear(hid_in_features, num_hiddens),                                    nn.Tanh())        self.mlm = MaskLM(vocab_size, num_hiddens, mlm_in_features)        self.nsp = NextSentencePred(nsp_in_features)    def forward(self, tokens, segments, valid_lens=None,                pred_positions=None):        encoded_X = self.encoder(tokens, segments, valid_lens)        if pred_positions is not None:            mlm_Y_hat = self.mlm(encoded_X, pred_positions)        else:            mlm_Y_hat = None        # 用于下一句预测的多层感知机分类器的隐藏层，0是“&lt;cls&gt;”标记的索引        nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, 0, :]))        return encoded_X, mlm_Y_hat, nsp_Y_hat\n\n\n\nbert预训练import torchfrom torch import nnfrom d2l import torch as d2lbatch_size, max_len = 512, 64train_iter, vocab = d2l.load_data_wiki(batch_size, max_len)net = d2l.BERTModel(len(vocab), num_hiddens=128, norm_shape=[128],                    ffn_num_input=128, ffn_num_hiddens=256, num_heads=2,                    num_layers=2, dropout=0.2, key_size=128, query_size=128,                    value_size=128, hid_in_features=128, mlm_in_features=128,                    nsp_in_features=128)devices = d2l.try_all_gpus()loss = nn.CrossEntropyLoss()#@savedef _get_batch_loss_bert(net, loss, vocab_size, tokens_X,                         segments_X, valid_lens_x,                         pred_positions_X, mlm_weights_X,                         mlm_Y, nsp_y):    # 前向传播    _, mlm_Y_hat, nsp_Y_hat = net(tokens_X, segments_X,                                  valid_lens_x.reshape(-1),                                  pred_positions_X)    # 计算遮蔽语言模型损失    mlm_l = loss(mlm_Y_hat.reshape(-1, vocab_size), mlm_Y.reshape(-1)) *\\    mlm_weights_X.reshape(-1, 1)    mlm_l = mlm_l.sum() / (mlm_weights_X.sum() + 1e-8)    # 计算下一句子预测任务的损失    nsp_l = loss(nsp_Y_hat, nsp_y)    l = mlm_l + nsp_l    return mlm_l, nsp_l, l    def train_bert(train_iter, net, loss, vocab_size, devices, num_steps):    net = nn.DataParallel(net, device_ids=devices).to(devices[0])    trainer = torch.optim.Adam(net.parameters(), lr=0.01)    step, timer = 0, d2l.Timer()    animator = d2l.Animator(xlabel=&#x27;step&#x27;, ylabel=&#x27;loss&#x27;,                            xlim=[1, num_steps], legend=[&#x27;mlm&#x27;, &#x27;nsp&#x27;])    # 遮蔽语言模型损失的和，下一句预测任务损失的和，句子对的数量，计数    metric = d2l.Accumulator(4)    num_steps_reached = False    while step &lt; num_steps and not num_steps_reached:        for tokens_X, segments_X, valid_lens_x, pred_positions_X,\\            mlm_weights_X, mlm_Y, nsp_y in train_iter:            tokens_X = tokens_X.to(devices[0])            segments_X = segments_X.to(devices[0])            valid_lens_x = valid_lens_x.to(devices[0])            pred_positions_X = pred_positions_X.to(devices[0])            mlm_weights_X = mlm_weights_X.to(devices[0])            mlm_Y, nsp_y = mlm_Y.to(devices[0]), nsp_y.to(devices[0])            trainer.zero_grad()            timer.start()            mlm_l, nsp_l, l = _get_batch_loss_bert(                net, loss, vocab_size, tokens_X, segments_X, valid_lens_x,                pred_positions_X, mlm_weights_X, mlm_Y, nsp_y)            l.backward()            trainer.step()            metric.add(mlm_l, nsp_l, tokens_X.shape[0], 1)            timer.stop()            animator.add(step + 1,                         (metric[0] / metric[3], metric[1] / metric[3]))            step += 1            if step == num_steps:                num_steps_reached = True                break    print(f&#x27;MLM loss &#123;metric[0] / metric[3]:.3f&#125;, &#x27;          f&#x27;NSP loss &#123;metric[1] / metric[3]:.3f&#125;&#x27;)    print(f&#x27;&#123;metric[2] / timer.sum():.1f&#125; sentence pairs/sec on &#x27;          f&#x27;&#123;str(devices)&#125;&#x27;)                    def get_bert_encoding(net, tokens_a, tokens_b=None):    tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b)    token_ids = torch.tensor(vocab[tokens], device=devices[0]).unsqueeze(0)    segments = torch.tensor(segments, device=devices[0]).unsqueeze(0)    valid_len = torch.tensor(len(tokens), device=devices[0]).unsqueeze(0)    encoded_X, _, _ = net(token_ids, segments, valid_len)    return encoded_X    \n\ntokens_a = [&#x27;a&#x27;, &#x27;crane&#x27;, &#x27;is&#x27;, &#x27;flying&#x27;]encoded_text = get_bert_encoding(net, tokens_a)# 词元：&#x27;&lt;cls&gt;&#x27;,&#x27;a&#x27;,&#x27;crane&#x27;,&#x27;is&#x27;,&#x27;flying&#x27;,&#x27;&lt;sep&gt;&#x27;encoded_text_cls = encoded_text[:, 0, :]encoded_text_crane = encoded_text[:, 2, :]encoded_text.shape, encoded_text_cls.shape, encoded_text_crane[0][:3]\n\ntokens_a, tokens_b = [&#x27;a&#x27;, &#x27;crane&#x27;, &#x27;driver&#x27;, &#x27;came&#x27;], [&#x27;he&#x27;, &#x27;just&#x27;, &#x27;left&#x27;]encoded_pair = get_bert_encoding(net, tokens_a, tokens_b)# 词元：&#x27;&lt;cls&gt;&#x27;,&#x27;a&#x27;,&#x27;crane&#x27;,&#x27;driver&#x27;,&#x27;came&#x27;,&#x27;&lt;sep&gt;&#x27;,&#x27;he&#x27;,&#x27;just&#x27;,# &#x27;left&#x27;,&#x27;&lt;sep&gt;&#x27;encoded_pair_cls = encoded_pair[:, 0, :]encoded_pair_crane = encoded_pair[:, 2, :]encoded_pair.shape, encoded_pair_cls.shape, encoded_pair_crane[0][:3]\n\n\n\nbert微调实现不同功能几类不同的Chinese-bertGoogle的bert-base-chinese![https://github.com/google-research/bert]\n讯飞的新全词系列bert![https://github.com/ymcui/Chinese-BERT-wwm]\n谷歌官方发布的BERT-base-Chinese中文是以字为粒度进行切分，没有考虑到传统NLP中的中文分词（CWS）。 我们将全词Mask的方法应用在了中文中，使用了中文维基百科（包括简体和繁体）进行训练，并且使用了哈工大LTP作为分词工具，即对组成同一个词的汉字全部进行Mask。\n参考：![14.10. 预训练BERT — 动手学深度学习 2.0.0-beta1 documentation (d2l.ai)]\n![BERT微调_哔哩哔哩_bilibili]\n![https://www.zhihu.com/question/510738704/answer/2305000399]\n","tags":["NLP","bert"]},{"title":"将虚拟机ip端口号映射到主机","url":"/2022/10/13/%E5%B0%86%E8%99%9A%E6%8B%9F%E6%9C%BAip%E7%AB%AF%E5%8F%A3%E5%8F%B7%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%BB%E6%9C%BA/","content":"1.查看虚拟机ipifconfig\n\n\n2.虚拟网络设置2.1虚拟机 -&gt; 编辑 -&gt; 虚拟网络编辑器 -&gt;更改设置2.2NAT设置\n2.3添加将刚才查到的ip和想映射的端口添加。\n\n注意：提前开放防火墙对应端口，或者直接关闭防火墙\n","tags":["ip","虚拟机"]},{"title":"归一化与标准化","url":"/2022/01/19/%E5%BD%92%E4%B8%80%E5%8C%96%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96/","content":"数据的归一化与标准化对数据归一化与标准化的理解数据通过标准化处理，对机器学习中很多算法会产生很好的优化效果。如果数据未标准化，在数据集（例如银行统计的个人年收入）中会对算法产生不同影响。\n归一化的目的1.提升模型的收敛速度2.提升模型的精度3.防止模型梯度爆炸\n归一化方法sklearn–minmax_scale()函数官方文档：[https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html?highlight=minmax_scale#sklearn.preprocessing.minmax_scale]\n","categories":["机器学习","数据处理"],"tags":["深度学习","机器学习","sklearn","数据处理"]},{"title":"对非平衡数据进行处理","url":"/2022/01/30/%E5%AF%B9%E9%9D%9E%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%A2%B3%E7%90%86/","content":"对非平衡数据进行处理详解[https://blog.csdn.net/weixin_43329700/article/details/107325026]\n非平衡数据定义数据比例差距过大，多数类远远大于少数类。比如预测癌症患者模型中，健康比例远大于百分之99，使模型训练机器不精准。\n处理方法from imblearn.combine import SMOTETomekst=SMOTETomek()x_train_st,y_train_st=st.fit_resample(X_train,y_train)print(X_train.shape)print(x_train_st.shape)            #增加了少数类样本\n新增少数类样本SMOTE函数过采样删除不符合要求的多数类样本TOMEK","categories":["机器学习","数据处理"],"tags":["深度学习","机器学习","数据处理","非平衡数据处理"]},{"title":"报错汇总-ide依赖","url":"/2022/06/04/%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB-ide%E4%BE%9D%E8%B5%96/","content":"\ndependency报这个错Element ‘dependency’ cannot have character [children], because the type’s content type is element-only.原因：空格中有其他元素解决：前面空格挨个删除再加上\n\n","tags":["报错汇总","maven"]},{"title":"报错汇总-数据库关键字","url":"/2022/06/04/%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/","content":"今天写mybaits一直显示语法错误，找了半天  测试了半天。最后发现竟是我将order作为一个表名，而order是数据库的一个关键字。所以要加反引号（就是键盘1左边那个）上图报错前\n修改后\n","tags":["数据库","报错汇总"]},{"title":"注解要点","url":"/2022/05/19/%E6%B3%A8%E8%A7%A3%E8%A6%81%E7%82%B9/","content":"注解概括注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。\n注解作用注释：用来解释说明的，给程序员看的\n注解：用来解释说明的，给程序看的\n\n1.编写文档：通过代码里标识的注解生成文档【生成文档doc文档】2.代码分析：通过代码里标识的注解对代码进行分析【使用反射】3.编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】注解的书写位置@注解名字public Tools &#123;&#125;------------------@注解名字public Tools &#123;\t@注解名字\tpublic void show() &#123;\t\t&#125;&#125;------------------class Tools &#123;\t@注解名字\tprivate int age;&#125;------------------class Tools &#123;\tpublic void show(@注解名字 int i, @注解名字 int j) &#123;\t\t&#125;&#125;\n\n注解的分类预定义注解人家已经起好名字的注解，人家提供的，我们直接使用的\n   @Override：作用是用来检查方法是否是重写方法@Deprecated：作用是用来标记方法是否已经过时@SuppressWarnings：作用是用来压制警告\t注意：一般都会给参数设置为all，用来压制所有的警告\n自定义注解自己写的注解，自己起的名字\n注解的定义格式元注解\t修饰符 @interface 注解名字 &#123;\t\t\t\t\t&#125;\t\t\t\t例子：\tpublic @interface MyAnno &#123; \t\t\t\t\t\t&#125;\n注解的本质注解的本质就是一个接口，只不过该接口默认继承了Annotation接口\npublic interface MyAnno1 extends java.lang.annotation.Annotation &#123;\t\t\t&#125;\n注解的属性因为接口中有很多抽象方法，在接口中定义的方法就称为抽象方法，在注解中定义的抽象方法就称为属性。数据的数据类型：基本数据类型、String、枚举、注解、以上几种数据类型对应的数组类型\n\tpublic @interface MyAnno &#123;\t\t数据类型 属性名();\t&#125;\t\t\t\t\t举例子：\tpublic @interface MyAnno &#123;\t\tString aaa();\t&#125;属性的使用\t//@MyAnno2(aaa=12)\t//@MyAnno2(bbb=&quot;abc&quot;)\t//@MyAnno2(ccc=MyEnum.M1)\t//@MyAnno2(ddd=@MyAnno1)\t//@MyAnno2(eee=&quot;aaa&quot;)\t//@MyAnno2(eee= &#123;&quot;aaa&quot;&#125;)\t@MyAnno2(eee= &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;)\tclass C &#123;\t\t\t\t\t\t\t&#125;数据类型： public @interface MyAnno2 &#123;\t\tint aaa();\t\tString bbb();\t\tMyEnum ccc();\t\tMyAnno1 ddd();\t\tString[] eee();\t\t\t\t\t\t&#125;\n注解属性需要注意的问题我们在使用注解的时候需要注意哪些问题？    1.如果一个注解中存在多个属性的时候，我们在使用需要给这些属性都要赋值，属性      与属性之间要用逗号隔开    2.我们可以注解中的属性设置默认值(default)，一旦设置了默认值，我们在使用      属性的时候，就不需要给该属性赋值了，当然也可以赋值    3.注解中有一个非常特殊的属性名，叫做value，一旦我们起的属性名字叫做value,      我们在使用注解给该属性赋值的时候，其实是不需要写属性名的，前提条件是该      注解有且只有一个属性\n元注解用来标注注解的注解就称为元注解\n*@Target：约束被该注解所标注的注解的书写范围\tElementType.TYPE：如果设置这个属性值，被标注的注解只能放在类的上面\tElementType.FIELD：如果设置这个属性值，被标注的注解只能放在属性的上面\tElementType.METHOD：如果设置这个属性值，被标注的注解只能放在方法的上面\t\t\t\t\t\t*@Retention：设置被该注解所标注的注解的声明时长\tRetentionPolicy.SOURCE：存活在源文件期间，编译之后就消失了\tRetentionPolicy.CLASS：存活在源文件期间和字节码文件期间，运行之后就消失了\tRetentionPolicy.RUNTIME：存活在源文件期间和字节码文件期间和运行期间\t\t\t\t\t@Documented：被该注解所标注的注解能够存在于帮助文档中@Inherited：被该注解所标注的注解能够被子类继承\n\n注解的解析通过反射技术，来获取注解中的属性的值\n注意：想要对注解进行解析，前提条件@Retention(RetentionPolicy.RUNTIME)\n获取类上面的注解的属性值public class Demo01 &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//使用反射技术获取类上面的注解的属性值：tom,18\t\t\t\t//获取字节码文件对象\t\tClass clazz = Class.forName(&quot;com.annotation.A&quot;);\t\t\t\t//获取类上面的注解对象\t\t//Annotation annotation = clazz.getAnnotation(MyAnno1.class);\t\tMyAnno1 myanno = (MyAnno1)clazz.getAnnotation(MyAnno1.class);\t\t\t\tSystem.out.println(myanno);\t\t\t\t//获取name和age的属性值\t\tString name = myanno.name();\t\tint age = myanno.age();\t\tSystem.out.println(name + &quot;...&quot; + age);\t&#125;&#125;@MyAnno1(name=&quot;tom&quot;, age=18)class A &#123;\t&#125;\n获取方法上面的注解的属性值public class Demo02 &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//获取字节码文件对象\t\tClass clazz = Class.forName(&quot;com.annotation.B&quot;);\t\t\t\t\t\t\t//获取show方法对象\t\tMethod method = clazz.getMethod(&quot;show&quot;);\t\t\t\t\t\t\t//获取方法上的注解对象\t\tMyAnno1 myAnno1 = method.getAnnotation(MyAnno1.class);\t\t\t\t\t\t\t//获取name和age属性值\t\tString name = myAnno1.name();\t\tint age = myAnno1.age();\t\tSystem.out.println(name + &quot;...&quot; + age);\t&#125;&#125;class B &#123;\t@MyAnno1(name=&quot;jerry&quot;,age=19)\tpublic void show() &#123;\t\t\t\t\t\t&#125;&#125;\n\n获取属性上面的注解的属性值public class Demo03 &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//获取字节码文件对象\t\tClass clazz = Class.forName(&quot;com.annotation.C&quot;);\t\t\t\t\t\t\t//获取name属性对象\t\tField field = clazz.getDeclaredField(&quot;name&quot;);\t\t\t\t\t\t\t//获取name属性上的注解对象\t\tMyAnno1 myAnno1 = field.getAnnotation(MyAnno1.class);\t\t\t\t\t\t\t//获取name和age属性值\t\tString name = myAnno1.name();\t\tint age = myAnno1.age();\t\tSystem.out.println(name + &quot;...&quot; + age);\t&#125;&#125;class C &#123;\t@MyAnno1(name=&quot;rose&quot;,age=20)\tprivate String name;&#125;","tags":["蜗牛学院笔记","javaee","注解"]},{"title":"数据库连接池","url":"/2022/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","content":"概念可以存储数据库连接对象的池子，就说了就是一个容器，里面装了几个数据库连接对象连接池：提供了一种池子思想，数据库连接池，线程池…\n作用使用数据库连接池，避免了重复的来回创建Connection对象，然后等着它消亡，然后再用，再重新创建，用完了再消亡。因为数据库连接池提供一个池子，里面已经提前准备好了一些连接对象，如果我们用直接从池子中取，用完再归还即可。节省时间，节约资源。\n自定义数据库连接池public class MySimpleConnectionPool &#123;\tprivate static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;(); \t\tstatic &#123;\t\ttry &#123;\t\t\tfor(int i = 1; i &lt;= 5; i++) &#123;\t\t\t\t//获取数据库连接对象\t\t\t\tConnection conn = JdbcUtils.getConnection();\t\t\t\t//将连接对象放入到pool里\t\t\t\tpool.add(conn);\t\t\t&#125;\t\t&#125; catch(Exception e) &#123;\t\t\tSystem.out.println(&quot;数据库连接池初始化失败~&quot;);\t\t&#125;\t&#125;\t\t\t//2.提供获取数据库连接对象的方法public static synchronized Connection getConnection() &#123;\tif(pool.size() &gt; 0) &#123;\t\treturn pool.removeFirst();\t&#125;\t\tthrow new RuntimeException(&quot;对不起，池子中啥都没有了~&quot;);&#125;//3.提供归还数据库连接对象的方法public static void close(Connection conn) &#123;\tpool.addLast(conn);&#125;\n第三方数据库连接池原理SUN公司提供了一个数据库连接池的接口：DataSource获取数据库连接对象：getConnection()归还数据库连接对象：close()    注意：如果Connection对象是通过DriverManager.getConnection()获取到的话，调用close()就是释源          如果Connection对象是通过数据库连接池获取到的话，调用close()就是归还\nC3P01.使用配置文件的版本：使用步骤：\t1.导入jar包\t\tc3p0-0.9.5.2.jar\t\tmchange-commons-java-0.2.12.jar\t\t2.拷贝配置文件\t\tc3p0-config.xml\t\t3.创建数据库连接池对象\t\tDataSource dataSource = new ComboPooledDataSource();\t\t\t\t\t\t4.获取数据库连接对象\t\tConnection conn = dataSource.getConnection();\t\t\t\t\t\t5.归还数据库连接对象\t\tconn.close();\n2.不使用配置文件的版本：使用步骤：\t1.导入jar包\t\tc3p0-0.9.5.2.jar\t\tmchange-commons-java-0.2.12.jar\t\t\t\t\t\t2.创建数据库连接池对象\t\tComboPooledDataSource dataSource = new ComboPooledDataSource();\t\t\t\t\t\t3.配置各个参数\t\tdataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);\t\tdataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/db6&quot;);\t\tdataSource.setUser(&quot;root&quot;);\t\tdataSource.setPassword(&quot;123&quot;);\t\t\t\t\t\t\t4.获取数据库连接对象\t\tConnection conn = dataSource.getConnection();\t\t\t\t\t\t5.归还数据库连接对象\t\tconn.close();\n\nDruid(德鲁伊)1.使用配置文件的版本：1.导入jar包\tdruid-1.0.9.jar2.拷贝配置文件\tdruid.properties\t\t\t\t\t3.创建数据库连接池对象\tProperties p = new Properties();\tp.load(Demo01.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));\tDataSource dataSource = DruidDataSourceFactory.createDataSource(p);\t\t\t\t\t4.获取数据库连接对象\tConnection conn = dataSource.getConnection();\t\t\t\t\t5.归还数据库连接对象\tconn.close();\n2.不使用配置文件的版本：1.导入jar包\tdruid-1.0.9.jar\t\t\t\t\t2.创建数据库连接池对象\tDruidDataSource dataSource = new DruidDataSource();\t\t\t\t\t\t3.配置参数信息\tdataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);\tdataSource.setUrl(&quot;jdbc:mysql://localhost:3306/db6&quot;);\tdataSource.setUsername(&quot;root&quot;);\tdataSource.setPassword(&quot;123&quot;);\t\t\t\t\t4.获取数据库连接对象\tConnection conn = dataSource.getConnection();\t\t\t\t\t5.归还数据库连接对象\tconn.close();","tags":["蜗牛学院笔记","数据库连接池","C3P0","Druid"]},{"title":"消息队列概括","url":"/2022/09/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E6%8B%AC/","content":"1.消息队列概念先开其英语，Message Queue，很直白的缩写，即消息和队列。他和队列一样是一种先进先出的数据结构。\n它可以简单理解为：想把传输的数据放在队列中\n相关概念：\n\n生产者：把数据放到消息队列里\n从消息队列里面取出数据叫做消费者\n\n2.优势2.1解耦2.2异步2.3削峰/限流3.相关问题3.1高可用3.2数据丢失问题3.3.push和pull4.相关技术4.1rabbitmq","tags":["消息队列"]},{"title":"网络编程要点","url":"/2022/05/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A6%81%E7%82%B9/","content":"网络编程概念什么是网络编程通过我们写好的程序，可以实现数据在网络端进行传输。也叫做Socket编程，也叫做套接字编程。\n网络编程三要素    1.IP地址\n    2.端口\n    3.协议\n\nIP地址P地址代表计算机的唯一标识\nIP地址查看？\nipconfigipconfig -all\n测试两台计算机的网络是否互通？\nping IP地址\n\n端口端口号代表应用程序的唯一标识\n所谓的端口，就好像是门牌号一样，客户端可以通过ip地址找到对应的服务器端，但是服务器端是有很多端的，每个应用程序对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。为了对端口进行区分，将每个端口进行了编号，这就是端口号\n端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535\n查看端口号所对应的PID(进程id)？\nnetstat -ano\n\n协议    协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。\n    如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。\n    \n    为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），\n    它最终体现为在网络上传输的数据包的格式\n\n    本篇所讲的协议：TCP UDP\n\nInetAddress类此类表示互联网协议ip地址\n常见的构造方法 ————用不了            \n#\t\t常见的成员方法\t\t\tpublic static InetAddress getByName(String host)：可以通过主机名或者IP地址，\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t获取的是InetAddress对象\t\t\t\t/*\t\t\t\t\tclass InetAddress &#123;\t\t\t\t\t\tprivate InetAddress() &#123;\t\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\tpublic static InetAddress getByName(String name) &#123;\t\t\t\t\t\t\tif(当前的环境是IPV4) &#123;\t\t\t\t\t\t\t\treturn new Ipv4Address();\t\t\t\t\t\t\t&#125; else if(当前的环境是IPV6) &#123;\t\t\t\t\t\t\t\treturn new Ipv6Address();\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tclass Ipv4Address extends InetAddress &#123;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tclass Ipv6Address extends InetAddress &#123;\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tclass Demo &#123;\t\t\t\t\t\tmain() &#123;\t\t\t\t\t\t\tInetAddress ia = InetAddress.getByName(&quot;&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t*/\t\t\t\t\t\t\tpublic String getHostName()：获取此 IP 地址的主机名\t\t\tpublic String getHostAddress()：返回 IP 地址字符串（以文本表现形式）\n\nUDP协议下的数据的传输UDP协议的特点​        1.面向无连接​        2.传输的速度相对较快​        3.传输的数据不安全，容易丢失\n发送端1.创建Socket对象DatagramSocket ds = new DatagramSocket();2.产生一个数据String data = &quot;约吗&quot;;3.创建数据报包对象，将数据封装到里面DatagramPacket dp = new DatagramPacket(data.getBytes(), data.getBytes().length, \tInetAddress.getByName(&quot;192.168.8.170&quot;), 10086);4.发送数据报包对象ds.send(dp);5.关闭Socket对象ds.close();\n接收端1.创建Socket对象DatagramSocket ds = new DatagramSocket(10086);2.创建数据报包对象byte[] bys = new byte[1024];DatagramPacket dp = new DatagramPacket(bys, bys.length);3.接收数据报包对象ds.receive(dp);4.解析String ip = dp.getAddress().getHostAddress();String data = new String(dp.getData(), 0, dp.getLength());System.out.println(ip + &quot;...&quot; + data);5.关闭Socket对象ds.close();\nTCP协议下的数据的传输TCP协议的特点    1.面向有连接\n        3次握手(建立连接)：\n            1.发送端 对 接收端 说： 你瞅啥？\n            2.接收端 对 发送端 说： 瞅你咋地？\n            3.发送端 对 接收端 说： 来，咱们聊一聊？\n        \n        4次挥手(断开连接)：\n            1.发送端 对 接收端 说： 我们分手吧！\n            2.接收端 对 发送端 说： 好的，我知道了！\n            3.接收端 对 发送端 说： 你真的要分手吗？不再想一想吗？\n            4.发送端 对 接收端 说： 确定，我百分百要分手！\n    \n    2.传输的速度相对较慢\n    3.传输的数据安全\n\n发送端1.创建Socket对象Socket s = new Socket(&quot;192.168.8.170&quot;, 10086);2.产生一个数据String data = &quot;约吗&quot;;3.获取管道输出流对象OutputStream os = s.getOutputStream();4.写出数据os.write(data.getBytes());5.释放资源s.close();\n接收端    \t\t1.创建Socket对象ServerSocket ss = new ServerSocket(10086);2.监听连接Socket s = ss.accept();3.获取管道输入流对象InputStream is = s.getInputStream();4.读取数据byte[] bys = new byte[1024];int len = is.read(bys);String data = new String(bys, 0, len);System.out.println(data);5.释放资源s.close();ss.close();","tags":["javaee","蜗牛学苑笔记"]},{"title":"虚拟机下解压报错","url":"/2022/04/16/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E8%A7%A3%E5%8E%8B%E6%8A%A5%E9%94%99/","content":"三天，报错了整整三天。后来发现竟然是没完全装上vmtools导致传输文件受损。\n先看官方文档不想解释文档\n坑1点这个里面的安装vmtools然后之前的我天真的以为就结束了，其实并没有。这个vmtools只安装一半，只能实现全屏和复制粘贴功能。往下看\n坑2点那个新弹出来的镜像，找vmtools(本来以为没有，结果自己找了好久)。然后按照文档步骤。\n坑3注意注意注意！！ 最后配置的时候一路按yes/no ，如果是路径的时候摁回车(不要按别的)。\n然后你就能安心的用共享文件夹，但是直接拖屏幕传输还是会有文件损失(不知道怎么解决)\n共享文件夹位置#默认这里cd /mnt/hgfs","tags":["centos/lingux","报错"]},{"title":"贷款违规行为预测实例","url":"/2022/01/16/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E8%A1%8C%E4%B8%BA%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B/","content":"","categories":["机器学习","数据处理"],"tags":["深度学习","机器学习","sklearn","数据处理"]},{"title":"配分函数","url":"/2022/09/01/%E9%85%8D%E5%88%86%E5%87%BD%E6%95%B0/","content":""},{"title":"记录——学习开源项目book_shop","url":"/2022/04/27/%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEbook-shop/","content":"先运行项目MybatisPlusConfig中发现有报错，有导入的包爆红。登录mybaits官网发现是插件主体过时，将PaginationInterceptor替换为最新的MybatisPlusInterceptor即可。然后发现官网没有及时更新开发文档\n#setUseDeprecatedExecutor已经过时了，所以ConfigurationCustomizer这段应该删掉@Configuration@MapperScan(&quot;scan.your.mapper.package&quot;)public class MybatisPlusConfig &#123;    /**     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)     */    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.Mysql));   #H2修改为Mysql        return interceptor;    &#125;    @Bean    public ConfigurationCustomizer configurationCustomizer() &#123;        return configuration -&gt; configuration.setUseDeprecatedExecutor(false);    &#125;&#125;\n\n\n\n发现项目的依赖有问题根据mybait-plus官网的配置要求spring-boot的项目依赖应该为\n&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;\n可项目采用的依赖是spring项目里的\n&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;\n然后我神奇的发现导入最新springboot的项目依赖会一直无法解析，折腾了很久没有办法。采用旧版本\n&lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;\n然后项目就能基本运行了\n大致看下application.yml文件配置如下\n服务器配置\n数据库配置（记得修改成本地）\nmybatis plus配置\n\n项目结构\n实体类entity实体类有Address Book Cart Order User等,如图\n打开Book实体# @Data 相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。# @TableName 表名注解，标识实体类对应的表# @EqualsAndHashCode#1. 此注解会生成equals(Object other) 和 hashCode()方法。#2. 它默认使用非静态，非瞬态的属性#3. 可通过参数exclude排除一些属性#4. 可通过参数of指定仅使用哪些属性#5. 它默认仅使用该类中定义的属性且不调用父类的方法#6. 可通过callSuper=true解决上一点问题。让其生成的方法中调用父类的方法。# @TableId(type = IdType.AUTO)  id自增@Data@TableName(value = &quot;bs_book&quot;)                   @EqualsAndHashCode(callSuper = false)public class Book extends Model&lt;Book&gt; &#123;    @TableId(type = IdType.AUTO)    private Integer id;    private String isbn;    private String name;    private String author;    private String publisher;    private Date publishDate;    private double oldPrice;    private double newPrice;    private String authorLoc;                           private Suit suit;                              #这    private Category category;                      #注意这里两个自定义的类    private String info;    private String imgUrl;&#125;\n\n接口层 mapper业务层 service","tags":["mysql","maven","Javeee","Mybait-plus"]}]
[{"title":"Kneighborsclassifier中参数说明","url":"/2022/03/21/Kneighborsclassifier%E4%B8%AD%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/","content":"官方文档：[https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html?highlight=kneighborsclassifier#sklearn.neighbors.KNeighborsClassifier]\nAPI–sklearn.neighbors.KNeighborsClassifie参数如下class sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, *, weights=&#x27;uniform&#x27;, algorithm=&#x27;auto&#x27;, leaf_size=30, p=2, metric=&#x27;minkowski&#x27;, metric_params=None, n_jobs=None)[source]\nn_neighborsint, default=5:临近参数所搜寻数量，默认为5。\nweights{‘uniform’, ‘distance’} or callable, default=’uniform’:‘uniform’ :默认每个neighborhood权重相等，一般默认为此设置。\n‘distance’:以距离为指标\n[callable] :由用户定义，可以接受数组的功能，返回一个包含相同形状的权重数组。\nalgorithm{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, default=’auto’：快速搜索算法，默认是auto\nball_tree ：使用ball_tree算法\nkd_tree   ：使用kd_tree算法\nbrute     ：使用brute-force搜索\nauto      ：根据传递给fit的值，自动尝试最合适的算法。\nleaf_sizeint, default=30：树的大小，传给BallTree或者KDTree算法，将影响构造和查询的速度以及存储的内存。最佳值取决于问题性质(一般默认是30，可以在其值不大的范围内调试看看效果。)\np: int, default=2对于Minkowski metric很重要的参数。\np=1:manhattan_distance (l1)p=2:euclidean_distance (l2)metric: str or callable, default=’minkowski’p：p=1是曼哈顿距离，p=2的欧氏距离。\nmetric_params:dict, default=None距离公式的其他关键参数，默认为None。\nn_jobs:int, default=None：n_jobsint, default=None并行处理。默认为1，临近点搜索。如果为-1，表示CPU的所有cores都并行工作。\n方法：fit(X, y)：拟合训练数据集\npredict(X)，predict_proba(X)：输出预测，输出预测为每个类的概率\n例子：&gt;&gt;&gt; X = [[0], [1], [2], [3]]&gt;&gt;&gt; y = [0, 0, 1, 1]&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier&gt;&gt;&gt; neigh = KNeighborsClassifier(n_neighbors=3)&gt;&gt;&gt; neigh.fit(X, y)KNeighborsClassifier(...)&gt;&gt;&gt; print(neigh.predict([[1.1]]))                #输出预测[0]&gt;&gt;&gt; print(neigh.predict_proba([[0.9]]))          #输出预测为每个类的概率[[0.666... 0.333...]]\nkneighbors([X, n_neighbors, return_distance])例子：&gt;&gt;&gt; samples = [[0., 0., 0.], [0., .5, 0.], [1., 1., .5]]&gt;&gt;&gt; from sklearn.neighbors import NearestNeighbors&gt;&gt;&gt; neigh = NearestNeighbors(n_neighbors=1)&gt;&gt;&gt; neigh.fit(samples)NearestNeighbors(n_neighbors=1)&gt;&gt;&gt; print(neigh.kneighbors([[1., 1., 1.]]))array([[0.5]]), array([[2]])\n\nkneighbors_graph([X, n_neighbors, mode])&gt;&gt;&gt; X = [[0], [3], [1]]&gt;&gt;&gt; from sklearn.neighbors import NearestNeighbors&gt;&gt;&gt; neigh = NearestNeighbors(n_neighbors=2)&gt;&gt;&gt; neigh.fit(X)NearestNeighbors(n_neighbors=2)&gt;&gt;&gt; A = neigh.kneighbors_graph(X)&gt;&gt;&gt; A.toarray()array([[1., 0., 1.],       [0., 1., 1.],       [1., 0., 1.]])","categories":["机器学习","KNN"],"tags":["机器学习","KNN","参数说明","sklearn"]},{"title":"API--MaxPoling1D","url":"/2022/01/26/API%E2%80%94%E2%80%94MaxPoling1D%E8%AF%A6%E8%A7%A3/","content":"官方文档：[https://www.tensorflow.org/api_docs/python/tf/keras/layers/MaxPool1D]\nAPI–MaxPoling1DAPI说明该函数会创建一层池化层，通过在大小为pool_size的空间窗口上取最大值，对输入进行处理。窗口每次的移动步数为strides。\n使用“valid”padding选项时，结果输出的形状为：output_shape=（input_shape-pool_size+1）/strips使用“SAME”填充选项时得到的输出形状是：output_shape = input_shape / strides\n参数说明tf.keras.layers.MaxPool1D(    pool_size=2, strides=None, padding=&#x27;valid&#x27;,    data_format=&#x27;channels_last&#x27;, **kwargs)\npool_size  :空间窗口大小strides    :窗口移动步长padding    :窗口覆盖模式当使用“valid”padding时：   不会对矩阵外部填充\nx = tf.constant([1., 2., 3., 4., 5.])x = tf.reshape(x, [1, 5, 1])max_pool_1d = tf.keras.layers.MaxPooling1D(pool_size=2,   strides=1, padding=&#x27;valid&#x27;)max_pool_1d(x)\n当使用“SAME”padding时：   对矩阵外部填充0\nx = tf.constant([1., 2., 3., 4., 5.])x = tf.reshape(x, [1, 5, 1])max_pool_1d = tf.keras.layers.MaxPooling1D(pool_size=2,   strides=1, padding=&#x27;same&#x27;)max_pool_1d(x)\ndata_format  :数据形式Input shape:\nIf data_format=&#x27;channels_last&#x27;: 3D tensor with shape (batch_size, steps, features).If data_format=&#x27;channels_first&#x27;: 3D tensor with shape (batch_size, features, steps).\n\nOutput shape:\nIf data_format=&#x27;channels_last&#x27;: 3D tensor with shape (batch_size, downsampled_steps, features).If data_format=&#x27;channels_first&#x27;: 3D tensor with shape (batch_size, features, downsampled_steps).","categories":["机器学习","卷积神经网络"],"tags":["机器学习","深度学习","卷积神经网络","layers","池化层- 计算机"]},{"title":"Flutter-界面报错-No-MediaQuery-widget-ancestor-found","url":"/2022/03/14/Flutter-%E7%95%8C%E9%9D%A2%E6%8A%A5%E9%94%99-No-MediaQuery-widget-ancestor-found/","content":"Flutter 界面报错 ( No MediaQuery widget ancestor found. | Scaffold widgets require a MediaQuery )报错如下（红屏）\n错误代码：\n// @dart=2.9import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_app/page/welcome.dart&#x27;;void main() &#123;   runApp(Welcome());&#125;\n\n分析修改忘了未跳转后页面添加一层 MaterialApp解决如下import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_app/page/welcome.dart&#x27;;void main() =&gt; runApp(MaterialApp(      title: &#x27;导航演示1&#x27;,      home: Welcome(),    ));\n","categories":["计算机","Flutter","错误记录"],"tags":["Flutter","错误记录"]},{"title":"My first blog","url":"/2022/01/01/My%20first%20blog/","content":"今天是2022年元旦节，我开心的发布了第一篇文章，希望给自己一个新的开始。新的一年，祝你心情好，身体好，一切顺心！","categories":["生活随笔"],"tags":["生活"]},{"title":"Hello World","url":"/2021/12/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"root用户启动firefox报错","url":"/2022/03/29/root%E7%94%A8%E6%88%B7%E5%90%AF%E5%8A%A8firefox%E6%8A%A5%E9%94%99/","content":"今天遇见了个很神奇的报错centos中admin账户可以打开火狐浏览器，而权限更高的root不可以\n报错如下：\n解决方案cd /run/user/1000# 然后修改权限就行了chown -R root ./\n\n然后就解决了，可能会警告，但是最后发现可以打开了。\n"},{"title":"opencv图像变换","url":"/2022/01/11/opencv%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2/","content":"图片处理图片处理四个步骤 1.load 2.info 3.resize 4.check\n共同代码：\nimport cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeprint(imgInfo)height=imgInfo[0]width=imgInfo[1]mode=imgInfo[2]        #颜色\n图片缩放将长高等比例缩小\ndstHeight=int(height*0.5)           #等比例缩小dstWidth=int(width*0.5)dst=cv2.resize(img,(dstHeight,dstWidth))\n图片剪切dst=img[100:200,0:300]            #从多少像素切到多少像素\n\n图片移位使用warpAffine()函数移位matShift=np.float32([[1,0,100],[0,1,200]])         #2*3dst=cv2.warpAffine(img,matShift,(height,width))      #1-data  2-mat  3-info\nwarpAffine变换矩阵实现图像移位\nvoid cv::warpAffine     (   InputArray      src,        OutputArray     dst,        InputArray      M,        Size    dsize,        int     flags = INTER_LINEAR,        int     borderMode = BORDER_CONSTANT,        const Scalar &amp;      borderValue = Scalar()     )\n参数解释：. src: 输入图像. dst: 输出图像，尺寸由dsize指定，图像类型与原图像一致. M: 2X3的变换矩阵. dsize: 指定图像输出尺寸. flags: 插值算法标识符，有默认值INTER_LINEAR，如果插值算法为WARP_INVERSE_MAP, \nfor循环移动像素移位dst = np.zeros(img.shape,np.uint8)height = imgInfo[0]width = imgInfo[1]for i in range(0,height):    for j in range(0,width-100):        dst[i,j+100]=img[i,j]\n\n图片镜像newImgInfo=(height*2,width,mode)dst=np.zeros(newImgInfo,np.uint8)         #设置画板for i in range(0,height):                 #for 循环转置像素    for j in range(0,width):        dst[i,j]=img[i,j]        dst[height*2-i-1,j]=img[i,j]for i in range(0,width):    dst[height,i]=(0,0,255)      #BGR\n图片缩放img=cv2.imread(&#x27;image0.jpg&#x27;,1)cv2.imshow(&#x27;src&#x27;,img)matScale=np.float32([[0.5,0,0],[0,0.5,0]])dst=cv2.warpAffine(img,matScale,(int(width/2),int(height/2)))\n\n仿射变换matSrc=np.float32([[0,0],[0,height-1],[width-1,0]])matDst=np.float32([[50,50],[300,height-200],[width-300,100]])matAffine=cv2.getAffineTransform(matSrc,matDst)dst=cv2.warpAffine(img,matAffine,(width,height))\n\n旋转变化matRotate = cv2.getRotationMatrix2D((height*0.5,width*0.5),45,1)dst = cv2.warpAffine(img,matRotate,(height,width))\ngetRotationMatrix2D函数调用形式\nMat getRotationMatrix2D(Point2f center, double angle, double scale)\n参数详解：\nPoint2f center：表示旋转的中心点double angle：表示旋转的角度double scale：图像缩放因子","categories":["机器学习","opencv"],"tags":["机器学习","opencv","图片处理"]},{"title":"sklearn.svm.SVC中kernel参数说明","url":"/2022/01/16/sklearn.svm.SVC%E4%B8%ADkernel%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/","content":"sklearn.svm.SVC中kernel参数说明线性核函数kernel=‘linear’采用线性核kernel=’linear’的效果和使用sklearn.svm.LinearSVC实现的效果一样，但采用线性核时速度较慢，特别是对于大数据集，推荐使用线性核时使用LinearSVC\n多项式核函数kernel=‘poly’degree代表d，表示多项式的次数gamma为多项式的系数，coef0代表r，表示多项式的偏置注：coef0是sklearn.svm.SVC中的参数\n径向基核函数kernel=‘rbf’可以将gamma理解为支持向量影响区域半径的倒数，gamma越大，支持向量影响区域越小，决策边界倾向于只包含支持向量，模型复杂度高，容易过拟合；gamma越小，支持向量影响区域越大，决策边界倾向于光滑，模型复杂度低，容易欠拟合；gamma的取值非常重要，即不能过小，也不能过大\nsigmod核函数kernel=‘sigmod’coef0控制r,sigmod核函数是线性核函数经过tanh函数映射变化\n","categories":["计算机","机器学习","scikit-learn","SVM"],"tags":["机器学习","scikit-learn","SVC"]},{"title":"markdown的语法","url":"/2022/01/08/markdown/","content":"markdown的语法斜体和粗体*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~\n分级标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n超链接（同时可以插入图像）[超链接]# 带有文字的链接[文字](链接)\n\n代码行使用```#include &lt;stdio.h&gt;int main(void)&#123;    printf(&quot;Hello world\\n&quot;);&#125;结尾```\n\n","categories":["计算机","博客"],"tags":["markdown","博客"]},{"title":"博客上传报错汇总","url":"/2022/01/02/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E6%8A%A5%E9%94%99/","content":"hexo d报错原因：问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。\n解决办法：删除.deploy_git文件夹;\n输入git config --global core.autocrlf false\n然后，依次执行：\nhexo cleanhexo ghexo d","categories":["计算机","博客"],"tags":["博客","随笔"]},{"title":"从pdf中提取内容","url":"/2022/03/02/%E4%BB%8Epdf%E4%B8%AD%E6%8F%90%E5%8F%96%E5%86%85%E5%AE%B9/","content":"使用Fitz正则化代码如下import pdfplumberimport osimport fitzimport reimport timepdf_path=r&#x27;f://1.pdf&#x27;text_path=r&#x27;f://2.txt&#x27;word_path=r&#x27;f://3.docx&#x27;pic_path=r&#x27;f://picture&#x27;#提取文字#文本t0=time.process_time()with pdfplumber.open(pdf_path) as pdf:    for page in pdf.pages:        content=page.extract_text()        with open(text_path,&#x27;a&#x27;,encoding=&#x27;utf-8&#x27;) as text:            text.write(content)t1=time.process_time()print(f&#x27;text提取完成，用时：&#123;t1-t0&#125;&#x27;)#提取图片t0=time.process_time()if not os.path.exists(pic_path):    os.makedirs(pic_path)pdf=fitz.open(pdf_path)ob_num=pdf.xref_length()print(f&#x27;Object数量：&#123;ob_num&#125;&#x27;)#匹配正则表达式checkXO = r&quot;/Type(?= */XObject)&quot;checkIM = r&quot;/Subtype(?= */Image)&quot;imgcount=0for index in range(1,ob_num):    text=pdf.xref_object(index)    isXObject=re.search(checkXO,text)    isImage=re.search(checkIM,text)    if not isXObject or not isImage:        continue    imgcount+=1    #匹配图片    pix=fitz.Pixmap(pdf,index)    pic_name=f&quot;img_&#123;imgcount&#125;.png&quot;    new_name = os.path.join(pic_path, pic_name)    #控制像素，不能过大，否则ValueError: unsupported colorspace for &#x27;png&#x27;    if pix.n&lt;3:        pix.save(new_name)    else:        pix0=fitz.Pixmap(fitz.csRGB,pix)        pix0.save(new_name)        pix0=None    pix=Noneprint(f&#x27;图片数量：&#123;imgcount&#125;&#x27;)t1=time.process_time()print(f&#x27;图片提取完成，用时：&#123;t1-t0&#125;&#x27;)","categories":["python"],"tags":["python","pdf","提取"]},{"title":"opencv图像灰度处理","url":"/2022/01/02/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86/","content":"灰度处理imread()函数import cv2img0=cv2.imread(&#x27;image0.jpg&#x27;,0)img1=cv2.imread(&#x27;image0.jpg&#x27;,1)print(img0.shape)print(img1.shape)\n\ncvtColor()函数import cv2img=cv2.imread(&#x27;image0.jpg&#x27;,1)dst=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  #颜色空间转换    1 data   2BGR gra\n\nR=G=B=grey 取平均值import cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeheight=imgInfo[0]width=imgInfo[1]#RGB  R=G=B=gray--------------取平均值dst=np.zeros((height,width,3),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r)=img[i,j]        gray=(int(b)+int(g)+int(r))/3             #uint进行相加时容易溢出，所以先取整数再转换回来        dst[i,j]=np.uint8(gray)cv2.imshow(&#x27;dst&#x27;,dst)cv2.waitKey(0)\n\n神奇的心理学公式gray=r0.299+g0.587+b*0.114\nimport cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeheight=imgInfo[0]width=imgInfo[1]#RGB  R=G=B=gray--------------取平均值dst=np.zeros((height,width,3),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r)=img[i,j]        b=int(b)        g=int(g)        r=int(r)        gray=r*0.299+g*0.587+b*0.114            #uint进行相加时容易溢出，所以先取整数再转换回来        dst[i,j]=np.uint8(gray)\n\n算法优化定点运算&gt;浮点运算&gt;移位运算\n#gray=r*0.299+g*0.587+b*0.114#gray=(r*1+g*2+b*1)/4      #浮点转换为定点运算gray=(r+(g&lt;&lt;1)+b)&gt;&gt;2       #定点运算转换为移位运算\n","categories":["机器学习","opencv"],"tags":["机器学习","opencv","计算机视觉"]},{"title":"对非平衡数据进行处理","url":"/2022/01/30/%E5%AF%B9%E9%9D%9E%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%A2%B3%E7%90%86/","content":"对非平衡数据进行处理详解[https://blog.csdn.net/weixin_43329700/article/details/107325026]\n非平衡数据定义数据比例差距过大，多数类远远大于少数类。比如预测癌症患者模型中，健康比例远大于百分之99，使模型训练机器不精准。\n处理方法from imblearn.combine import SMOTETomekst=SMOTETomek()x_train_st,y_train_st=st.fit_resample(X_train,y_train)print(X_train.shape)print(x_train_st.shape)            #增加了少数类样本\n新增少数类样本SMOTE函数过采样删除不符合要求的多数类样本TOMEK","categories":["机器学习","数据处理"],"tags":["机器学习","深度学习","数据处理","非平衡数据处理"]},{"title":"归一化与标准化","url":"/2022/01/19/%E5%BD%92%E4%B8%80%E5%8C%96%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96/","content":"数据的归一化与标准化对数据归一化与标准化的理解数据通过标准化处理，对机器学习中很多算法会产生很好的优化效果。如果数据未标准化，在数据集（例如银行统计的个人年收入）中会对算法产生不同影响。\n归一化的目的1.提升模型的收敛速度2.提升模型的精度3.防止模型梯度爆炸\n归一化方法sklearn–minmax_scale()函数官方文档：[https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html?highlight=minmax_scale#sklearn.preprocessing.minmax_scale]\n","categories":["机器学习","数据处理"],"tags":["机器学习","sklearn","深度学习","数据处理"]},{"title":"贷款违规行为预测实例","url":"/2022/01/16/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E8%A1%8C%E4%B8%BA%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B/","content":"","categories":["机器学习","数据处理"],"tags":["机器学习","sklearn","深度学习","数据处理"]}]
[{"title":"Anaconda使用","url":"/2022/05/06/Anaconda%E4%BD%BF%E7%94%A8/","content":"介绍Conda是Anaconda中的一个开源的包和环境管理工具，可以在终端窗口通过命令行使用，也可以在Anaconda Navigator中通过图形化界面使用,对编程创建独立的环境和包管理，最初是为Python语言开发，现在已不限制语言，支持Python, R, Ruby, Lua, Scala, Java, JavaScript,C/ C++, FORTRAN等。\n安装使用使用conda管理环境#创建环境conda create -n yourname python=3.6#查看环境conda env list#进入环境conda activate yourname#产看该环境中已安装的第三方库conda list#关闭虚拟环境conda deactivate\n\n管理conda#查看版本conda --version#更新至最新版本conda update conda\n\n实用配置配置pycharm中","tags":["Anconda"]},{"title":"API--MaxPoling1D","url":"/2022/01/26/API%E2%80%94%E2%80%94MaxPoling1D%E8%AF%A6%E8%A7%A3/","content":"官方文档：[https://www.tensorflow.org/api_docs/python/tf/keras/layers/MaxPool1D]\nAPI–MaxPoling1DAPI说明该函数会创建一层池化层，通过在大小为pool_size的空间窗口上取最大值，对输入进行处理。窗口每次的移动步数为strides。\n使用“valid”padding选项时，结果输出的形状为：output_shape=（input_shape-pool_size+1）/strips使用“SAME”填充选项时得到的输出形状是：output_shape = input_shape / strides\n参数说明tf.keras.layers.MaxPool1D(    pool_size=2, strides=None, padding=&#x27;valid&#x27;,    data_format=&#x27;channels_last&#x27;, **kwargs)\npool_size  :空间窗口大小strides    :窗口移动步长padding    :窗口覆盖模式当使用“valid”padding时：   不会对矩阵外部填充\nx = tf.constant([1., 2., 3., 4., 5.])x = tf.reshape(x, [1, 5, 1])max_pool_1d = tf.keras.layers.MaxPooling1D(pool_size=2,   strides=1, padding=&#x27;valid&#x27;)max_pool_1d(x)\n当使用“SAME”padding时：   对矩阵外部填充0\nx = tf.constant([1., 2., 3., 4., 5.])x = tf.reshape(x, [1, 5, 1])max_pool_1d = tf.keras.layers.MaxPooling1D(pool_size=2,   strides=1, padding=&#x27;same&#x27;)max_pool_1d(x)\ndata_format  :数据形式Input shape:\nIf data_format=&#x27;channels_last&#x27;: 3D tensor with shape (batch_size, steps, features).If data_format=&#x27;channels_first&#x27;: 3D tensor with shape (batch_size, features, steps).\n\nOutput shape:\nIf data_format=&#x27;channels_last&#x27;: 3D tensor with shape (batch_size, downsampled_steps, features).If data_format=&#x27;channels_first&#x27;: 3D tensor with shape (batch_size, features, downsampled_steps).","categories":["机器学习","卷积神经网络"],"tags":["深度学习","卷积神经网络","layers","池化层- 计算机","机器学习"]},{"title":"Apifox文档的使用","url":"/2022/04/29/Apifox%E6%96%87%E6%A1%A3%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"Api介绍下载部署","tags":["Apifox"]},{"title":"Aop概括","url":"/2022/07/01/Aop%E6%A6%82%E6%8B%AC/","content":""},{"title":"JDBC详解","url":"/2022/05/11/JDBC%E8%AF%A6%E8%A7%A3/","content":"JDBC介绍介绍什么是JDBC\n    Java数据库连接（Java DataBase Connectivity）\n    \nJDBC作用\n    能够帮助我们实现用java代码操作数据库\n    \nJDBC的本质\n    JDBC是JavaEE技术之一\n    \n    JavaEE是13种技术的统称\n    \n    JDBC就是SUN公司提供的一套规范，一套接口\n\n案例0.导入jar包1.注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);2.获取数据库连接对象Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db6&quot;, &quot;root&quot;, &quot;123&quot;);3.获取执行sql语句的对象Statement stat = conn.createStatement();4.执行sql语句int i = stat.executeUpdate(&quot;insert into user values(1,&#x27;tom&#x27;, 18)&quot;);System.out.println(i);5.释放资源stat.close();conn.close();\n步骤详解0.导入jar包\t为什么要jar包？\t\t因为我们用java语句操作数据库，具体的实现类和方法都在jar里呢，JDBC只是提供一些接口\t\t1.注册驱动\tClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\t解释：将com.mysql.jdbc.Driver.class文件加载进内存方法区中，形成字节码文件对象\t\t为什么要注册驱动？\t\t告诉程序要操作的数据库是哪一个数据库\t\t注册驱动的原始代码：DriverManager.registerDrvier(new Driver());\t按照原始写法有两点不好的地方：\t\t1.太过依赖于jar包，如果jar不存在，编译的时候就报错了\t\t2.会造成2次注册\t\t2.获取数据库连接对象\tConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db6&quot;, &quot;root&quot;, &quot;123&quot;);\t\t三个参数：\t\t\t1.第一个参数：jdbc:mysql://localhost:3306/db6\t\t\t\t\t\t\t协议         IP地址  端口 数据库名\t\t\t2.第二个参数：root 用户名\t\t\t3.第三个参数：123  密码\t\t\t\t\t有几个重载的方法：\t\t\tpublic static Connection getConnection(String url,String user, String password)\t\t\tpublic static Connection getConnection(String url)\t\t\tpublic static Connection getConnection(String url,java.util.Properties info)\t\t\t\t\t注意：如果ip是localhost，端口是3306的话，第一个参数可以简写为：jdbc:mysql:///db63.获取执行sql语句的对象\tStatement stat = conn.createStatement();\t\t后面要修改写法，因为上面的写法是有弊端的，有什么弊端呢？不知道\t\tPreparedStatement ps = conn.prepareStatement(&quot;sql语句&quot;);\t使用PreparedStatement能够解决sql注入问题，因为它采用的是预处理模式，里面使用的是占位符？\t\t\t\t4.执行sql语句\tint i = stat.executeUpdate(&quot;insert into user values(1,&#x27;tom&#x27;, 18)&quot;);\tSystem.out.println(i);\t\tint executeUpdate()：增删改\t\t返回值：实际影响的行数\t\t\tResultSet executeQuery()：查询\t\t返回值：结果集对象\t\t\tResultSet：\t\t\t\tboolean next()：判断结果集里有没有数据\t\t\t\tint getInt(int i)：根据第几个字段获取对应的字段的数据\t\t\t\tint getInt(String name)：根据指定的字段名获取对应的字段数据\t\t\t\tString getString(int i)：根据第几个字段获取对应的字段的数据\t\t\t\tString getString(String name)：根据指定的字段名获取对应的字段数据\t\t\tboolean execute()：增删改查，底层使用的，我们自己用的很少\t\t返回值：\t\t\t增删改 返回false\t\t\t查询   返回true5.释放资源\trs.close();\tstat.close();\tconn.close();\n\nJDBC工具类public class JdbcUtils &#123;\tprivate static String driver;\tprivate static String url;\tprivate static String username;\tprivate static String password;\t\tstatic &#123;\t\ttry &#123;\t\t\tProperties p = new Properties();\t\t\tp.load(JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;));\t\t\t\t\t\tdriver = p.getProperty(&quot;driver&quot;);\t\t\turl = p.getProperty(&quot;url&quot;);\t\t\tusername = p.getProperty(&quot;username&quot;);\t\t\tpassword = p.getProperty(&quot;password&quot;);\t\t\t\t\t\t//注册驱动\t\t\tClass.forName(driver);\t\t&#125; catch(Exception e) &#123;\t\t\tSystem.out.println(&quot;初始化失败&quot;);\t\t&#125;\t&#125;\t\tpublic static Connection getConnection() throws SQLException &#123;\t\t//获取数据连接对象\t\tConnection conn = DriverManager.getConnection(url, username, password);\t\treturn conn;\t&#125;\t\tpublic static void close(Connection conn, PreparedStatement ps) &#123;\t\tclose(conn, ps, null);\t&#125;\t\tpublic static void close(Connection conn, PreparedStatement ps, ResultSet rs) &#123;\t\tif(rs != null) &#123;\t\t\ttry &#123;\t\t\t\trs.close();\t\t\t&#125; catch (SQLException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t\tif(ps != null) &#123;\t\t\ttry &#123;\t\t\t\tps.close();\t\t\t&#125; catch (SQLException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\t\t\tif(conn != null) &#123;\t\t\ttry &#123;\t\t\t\tconn.close();\t\t\t&#125; catch (SQLException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t&#125;&#125;\nJDBC事务处理案例：转账\t//获取数据库连接对象\tConnection conn = JdbcUtils.getConnection();\t\t//开启事务\tconn.setAutoCommit(false);\t\t//获取执行sql语句对象\tPreparedStatement ps = conn.prepareStatement(&quot;update user set money = money + ? where name = ?&quot;);\t\t//tom减去100元钱\tps.setInt(1, -100);\tps.setString(2, &quot;tom&quot;);\tps.executeUpdate();\t\tSystem.out.println(1/0);\t\t//jerry加100元钱\tps.setInt(1, 100);\tps.setString(2, &quot;jerry&quot;);\tps.executeUpdate();\t\t//提交事务\tconn.commit();\t\t//释放资源\tJdbcUtils.close(conn, ps);\n","tags":["javaEE","数据库","JDBC"]},{"title":"Flutter-界面报错-No-MediaQuery-widget-ancestor-found","url":"/2022/03/14/Flutter-%E7%95%8C%E9%9D%A2%E6%8A%A5%E9%94%99-No-MediaQuery-widget-ancestor-found/","content":"Flutter 界面报错 ( No MediaQuery widget ancestor found. | Scaffold widgets require a MediaQuery )报错如下（红屏）\n错误代码：\n// @dart=2.9import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_app/page/welcome.dart&#x27;;void main() &#123;   runApp(Welcome());&#125;\n\n分析修改忘了未跳转后页面添加一层 MaterialApp解决如下import &#x27;package:flutter/material.dart&#x27;;import &#x27;package:flutter_app/page/welcome.dart&#x27;;void main() =&gt; runApp(MaterialApp(      title: &#x27;导航演示1&#x27;,      home: Welcome(),    ));\n","categories":["计算机","Flutter","错误记录"],"tags":["Flutter","错误记录"]},{"title":"JdncTemplate","url":"/2022/05/29/JdncTemplate/","content":"JdbcTemplate简介JdbcTemplate是Spring框架针对Jdbc的封装，它就是一个(Jdbc工具类)，简化了代码的书写，提供了更加方便的操作。JdbcTemplate也是一个基于ORM思想的工具类(小框架)。\nORM架构简介对象关系映射(Object Relational Mapping)在实际开发中，往往是数据库中的一张表会对应Java中一个类，类名和表名，字段名和属性名都是一样的。\nJdbcTemplate的基本使用使用步骤：1.导入相关的jar包    导入5个关联jar包\n2.创建JdbcTemplate对象    JdbcTemplate jt = new JdbcTemplate();\n3.将数据库连接池对象封装到JdbcTemplate对象中方案一：通过JdbcTemplate有参构造赋值        JdbcTemplate jt = new JdbcTemplate(数据库连接池对象);\n方案二：通过JdbcTemplate中的setXXX()方法赋值        JdbcTemplate jt = new JdbcTemplate();        jt.setDataSource(数据库连接池对象);\n4.执行sql语句\n添加：\tjt.update(&quot;insert into user values(null, ?, ?)&quot;, &quot;tom&quot;, &quot;123&quot;);\t\t\t修改：\tjt.update(&quot;update user set username = ?, password = ? where id = ?&quot;, &quot;jerry&quot;,&quot;root&quot;,&quot;1&quot;);\t\t\t删除：\tjt.update(&quot;delete from user where id = ?&quot;, 1);\t\t\t查询：\t查询多条记录？\t\tList&lt;User&gt; users = jt.query(&quot;select * from user&quot;, \t\tnew BeanPropertyRowMapper&lt;User&gt;(User.class));\t\t\t\t    查询一条记录？    \tUser user = jt.queryForObject(&quot;select * from user where id = ?&quot;,     \tnew BeanPropertyRowMapper&lt;User&gt;(User.class), 1);\t\t\t\t    查询一个数据？    \t查询id为1的username是什么？    \t\t\tString username = jt.queryForObject(&quot;select username from user where id = ?&quot;,     \t\t\tString.class, 1);    \t\t\tSystem.out.println(username);\t\t\t\t\t    \t查询表中有多少条记录？    \t\tint count = jt.queryForObject(&quot;select count(*) from user&quot;, int.class);    \t\tSystem.out.println(count); ","tags":["数据库","JDBC","JdbcTemplate"]},{"title":"Kneighborsclassifier中参数说明","url":"/2022/03/21/Kneighborsclassifier%E4%B8%AD%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/","content":"官方文档：[https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html?highlight=kneighborsclassifier#sklearn.neighbors.KNeighborsClassifier]\nAPI–sklearn.neighbors.KNeighborsClassifie参数如下class sklearn.neighbors.KNeighborsClassifier(n_neighbors=5, *, weights=&#x27;uniform&#x27;, algorithm=&#x27;auto&#x27;, leaf_size=30, p=2, metric=&#x27;minkowski&#x27;, metric_params=None, n_jobs=None)[source]\nn_neighborsint, default=5:临近参数所搜寻数量，默认为5。\nweights{‘uniform’, ‘distance’} or callable, default=’uniform’:‘uniform’ :默认每个neighborhood权重相等，一般默认为此设置。\n‘distance’:以距离为指标\n[callable] :由用户定义，可以接受数组的功能，返回一个包含相同形状的权重数组。\nalgorithm{‘auto’, ‘ball_tree’, ‘kd_tree’, ‘brute’}, default=’auto’：快速搜索算法，默认是auto\nball_tree ：使用ball_tree算法\nkd_tree   ：使用kd_tree算法\nbrute     ：使用brute-force搜索\nauto      ：根据传递给fit的值，自动尝试最合适的算法。\nleaf_sizeint, default=30：树的大小，传给BallTree或者KDTree算法，将影响构造和查询的速度以及存储的内存。最佳值取决于问题性质(一般默认是30，可以在其值不大的范围内调试看看效果。)\np: int, default=2对于Minkowski metric很重要的参数。\np=1:manhattan_distance (l1)p=2:euclidean_distance (l2)metric: str or callable, default=’minkowski’p：p=1是曼哈顿距离，p=2的欧氏距离。\nmetric_params:dict, default=None距离公式的其他关键参数，默认为None。\nn_jobs:int, default=None：n_jobsint, default=None并行处理。默认为1，临近点搜索。如果为-1，表示CPU的所有cores都并行工作。\n方法：fit(X, y)：拟合训练数据集\npredict(X)，predict_proba(X)：输出预测，输出预测为每个类的概率\n例子：&gt;&gt;&gt; X = [[0], [1], [2], [3]]&gt;&gt;&gt; y = [0, 0, 1, 1]&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier&gt;&gt;&gt; neigh = KNeighborsClassifier(n_neighbors=3)&gt;&gt;&gt; neigh.fit(X, y)KNeighborsClassifier(...)&gt;&gt;&gt; print(neigh.predict([[1.1]]))                #输出预测[0]&gt;&gt;&gt; print(neigh.predict_proba([[0.9]]))          #输出预测为每个类的概率[[0.666... 0.333...]]\nkneighbors([X, n_neighbors, return_distance])例子：&gt;&gt;&gt; samples = [[0., 0., 0.], [0., .5, 0.], [1., 1., .5]]&gt;&gt;&gt; from sklearn.neighbors import NearestNeighbors&gt;&gt;&gt; neigh = NearestNeighbors(n_neighbors=1)&gt;&gt;&gt; neigh.fit(samples)NearestNeighbors(n_neighbors=1)&gt;&gt;&gt; print(neigh.kneighbors([[1., 1., 1.]]))array([[0.5]]), array([[2]])\n\nkneighbors_graph([X, n_neighbors, mode])&gt;&gt;&gt; X = [[0], [3], [1]]&gt;&gt;&gt; from sklearn.neighbors import NearestNeighbors&gt;&gt;&gt; neigh = NearestNeighbors(n_neighbors=2)&gt;&gt;&gt; neigh.fit(X)NearestNeighbors(n_neighbors=2)&gt;&gt;&gt; A = neigh.kneighbors_graph(X)&gt;&gt;&gt; A.toarray()array([[1., 0., 1.],       [0., 1., 1.],       [1., 0., 1.]])","categories":["机器学习","KNN"],"tags":["机器学习","KNN","参数说明","sklearn"]},{"title":"Jenkins入门","url":"/2022/03/28/Jenkins%E5%85%A5%E9%97%A8/","content":"第一章  Jenkins是什么？Jenkins介绍是一个开源的、可扩展的持续集成、交付、部署（软件/代码的编译、打包、部署）的基于web界面的平台。允许持续集成和持续交付项目，无论用的是什么平台，可以处理任何类型的构建或持续集成。\n持续集成持续集成指的是，频繁地（一天多次）将代码集成到主干。将软件个人研发的部分向软件整体部分交付，频繁进行集成以便更快地发现其中的错误。\n持续交付持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。\n持续部署持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。\n官网官方文档\n第二章 快速安装Jenkins通常作为一个独立的应用程序在其自己的流程中运行， 内置Java servlet 容器/应用程序服务器（Jetty）。Jenkins也可以运行在不同的Java servlet容器(（如Apache Tomcat 或 GlassFish）)中作为servlet运行,但是设置本篇暂不讲起。\n安装平台(Docker)可以参考上篇Docker安装。\n在Docker中下载并运行Jenkins注意：安装最低配置不少于256M内存，不低于1G磁盘，JDK版本&gt;=8（openjdk也可以）。\n拉取镜像我们使用官网推荐的jenkinsci/blueocean该镜像包含当前的长期支持 (LTS) 的Jenkins版本 （可以投入使用） ，捆绑了所有Blue Ocean插件和功能。这意味着你不需要单独安装Blue Ocean插件。但是发现网速根本行不通，于是又给自己配了个docker加速器。\n可以看我另一个帖子docker加速器此外还有停更的jenkins停更了，和长期版本的jenkins/jenkins。\ndocker pull jenkinsci/blueocean\n\n运行容器使用以下docker run 命令将其作为Docker中的容器运行\ndocker run \\  -u root \\  --rm \\       #关闭时自动删除  -d \\         #后台运行  -p 8080:8080 \\   -p 50000:50000 \\   -v jenkins-data:/var/jenkins_home \\   -v /var/run/docker.sock:/var/run/docker.sock \\   jenkinsci/blueocean \n\n然后我们根据docker hub文档指示在容器里运行镜像\nrun -p 8080:8080 jenkinsci/blueocean\n\n打开本地端口浏览到 http://localhost:8080或安装时为Jenkins配置的任何端口），并等待 解锁 Jenkins 页面出现。\n1.从Jenkins控制台日志输出中，复制自动生成的字母数字密码（在两组星号之间）。2.然后创建第一个管理员用户如果不知道自己需要哪些插件 请选择安装建议的插件\n3.最后重启jenkins.大功告成\n注意:如果该页面在一分钟后不会自动刷新，请使用Web浏览器手动刷新页面。如果需要，请使用您刚刚创建的用户的凭据登录到Jenkins，并准备好开始使用Jenkins！\n","categories":["centos/linux","Jenkins"],"tags":["Jenkins","centos","docker"]},{"title":"My first blog","url":"/2022/01/01/My%20first%20blog/","content":"今天是2022年元旦节，我开心的发布了第一篇文章，希望给自己一个新的开始。新的一年，祝你心情好，身体好，一切顺心！","categories":["生活随笔"],"tags":["生活"]},{"title":"ORM架构","url":"/2022/05/18/ORM%E6%9E%B6%E6%9E%84/","content":"ORM架构概念ORM，即Object Relational Mapping，它是对象关系模型的简称。它的作用是在关系型数据库和对象之间作一个映射。使程序能够通过操纵描述对象方式来操纵数据库。\nORM 把数据库映射成对象。\n数据库的表（table） --&gt; 类（class）记录（record，行数据）--&gt; 对象（object）字段（field）--&gt; 对象的属性（attribute）\n优缺点优点\n数据模型都在一个地方定义，更容易更新和维护，也利于重用代码。\nORM 有现成的工具，很多功能都可以自动完成，比如数据消毒、预处理、事务等等。\n它迫使你使用 MVC 架构，ORM 就是天然的 Model，最终使代码更清晰。\n基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。\n你不必编写性能不佳的 SQL。\n\n缺点\nORM 库不是轻量级工具，需要花很多精力学习和设置。\n对于复杂的查询，ORM 要么是无法表达，要么是性能不如原生的 SQL。\nORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL。\n\n","tags":["JDBC","ORM","JPA"]},{"title":"Spring事务","url":"/2022/07/01/Spring%E4%BA%8B%E5%8A%A1/","content":""},{"title":"NLP——词嵌入","url":"/2022/06/18/NLP%E2%80%94%E2%80%94%E8%AF%8D%E5%B5%8C%E5%85%A5/","content":""},{"title":"Thymeleaf模板引擎","url":"/2022/07/11/Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/","content":""},{"title":"bert中文模型+cnn","url":"/2022/06/26/bert%E4%B8%AD%E6%96%87%E6%A8%A1%E5%9E%8B-cnn/","content":""},{"title":"centos下一些常用的命令","url":"/2022/04/12/centos%E4%B8%8B%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","content":"基础命令删除命令#删除目录或者文件，如果是链接文件，则只删除这个链接文件而不是链接指向的文件rm xx#    -r　　　　　　递归删除目录#　　-f　　　　　　忽略不存在提示和确认提示，本身确认提示系统默认添加-i参数#　　-i　　　　　　删除文件前提示，输入y确认，输入任何非y字符取消一般 -rf联合使用# 删除文件夹里所有文件rm -rf  *# 删除文件夹里所有文件除了a,brm -f  !(a|b)\n复制移动命令#移动mv 文件 /xx/xx路径cp 参数 源文件/目录 目标目录-r 复制目录-p 连带文件属性复制-d 若源文件事链接文件 则复制链接属性-a 相当于-pdr#移动某文件夹下所有文件到另一个文件夹mv  目标文件的上一级目录/*  新的目录\n创建命令# 创建文件touch  文件名# 创建文件夹mkdir  文件名# 创建嵌套的文件夹mkdir -p a/b/c    \n\n\n解压命令tar.gz文件压缩tar cvfz backup.tar.gz /xxx/       -c, --create              create a new archive       -v, --verbose              verbosely list files processed       -f, --file [HOSTNAME:]F              use archive file or device F (default /dev/rmt0)       -z, --gzip, --ungzip              filter the archive through gzip\ntar.gz文件解压tar -zxvf xxx.tar.gz这样会生成一个以文件名命名的文件夹       -z, --gzip, --ungzip              filter the archive through gzip       -x, --extract, --get              extract files from an archive       -v, --verbose              verbosely list files processed       -f, --file [HOSTNAME:]F              use archive file or device F (default /dev/rmt0)#指定路径解压tar -xvzf filename.tar.gz -C ~/path/to/extract\n\n其他类型*.tar 用 tar –xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar –xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar –xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar –xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压\n\n文本编辑命令显示/隐藏行号#显示行号:set number/nu #隐藏行号:set nonu","tags":["centos","常用命令"]},{"title":"centos下查看自己ip的几种方法","url":"/2022/03/31/centos%E4%B8%8B%E6%9F%A5%E7%9C%8B%E8%87%AA%E5%B7%B1ip%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","content":"linux下获取自己ip地址使用dig命令查找公共IP地址dig命令是一个DNS查找实用程序，用于Linux系统通过连接到OpenDNS服务器来查找公共IP地址。\n$ dig +short myip.opendns.com @resolver1.opendns.com \n\n使用wget命令获取公共IP地址$ wget http://ipecho.net/plain -O - -q ; echo\n\n使用curl命令获取公共地址$ curl ipecho.net/plain; echo$ curl icanhazip.com$ curl ifconfig.me","categories":["centos/linux"],"tags":["centos","网络","ip"]},{"title":"centos关闭防火墙","url":"/2022/03/30/centos%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/","content":"今天部署rancher时，发现web页面总被防火墙阻拦。\n解决方法：先查看防火墙状态\nsystemctl status firewalld.service\n\nactive(running)表示防火墙开启\n关闭防火墙\nsystemctl stop firewalld service\n\n开关机设置\nsystemctl disable firewalld.service       #开机禁止防火墙服务器systemctl enable firewalld.service        #开机启动防火墙服务器","categories":["centos/linux"],"tags":["centos","防火墙"]},{"title":"centos下的几种下载方式","url":"/2022/05/16/centos%E4%B8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8B%E8%BD%BD%E6%96%B9%E5%BC%8F/","content":""},{"title":"docker中部署jar包","url":"/2022/04/14/docker%E4%B8%AD%E9%83%A8%E7%BD%B2jar%E5%8C%85/","content":"编写Dockerfile文件在自己目录下创建文件#创建文件touch Dockerfile #修改vi Dockerfile\n然后按照以下格式\n# 使用这个命令会将java8 环境集成在你打好的镜像中FROM java:8# 作者名MAINTAINER xxx# 将jar包改成你想要的名字ADD jeecg-boot.jar xxx.jar# 端口EXPOSE 8080# jar包启动命令ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;xxx.jar&quot;]\n制作镜像然后我们开始用build命令制作镜像\n#格式为docker build [参数] [路径] [目标]#例如docker build -t 镜像名字 .\n成功\n运行容器docker run -itd –name xxx xxx.jar\n然后神奇的发现报错了。status状态码127\n查看状态码125：是由Docker守护程序本身造成的，一般是因为 docker run 命令本身报错了126：无法调用所包含的命令，例如权限不足，无法访问目录或者执行命令127：找不到所包含的命令，例如环境中没有安装 curl 命令，但你调用了 curl 命令，那就找不到咯128+N：N是Bash的信号，比如信号是15，那么128+15=143，这时候 docker 的 退出代码就是 Exited(143)\n似乎是Dockerfile里面不能拉取jdk8导致。只能自己拉取一个jdk8的镜像了\n重新拉取并运行jdk8镜像#拉取docker pull jdk:8#运行成容器docker run -d -it -name xxx -p 8080:8080 jave#进入容器docker exec -it id bash#将宿主机jar包复制到容器（重开一个终端）docker cp 宿主机地址 id:容器地址# 在容器中运行jar包java -jar xxx.jar","tags":["docker","jar打包","Dockerfile"]},{"title":"docker加速器","url":"/2022/03/28/docker%E5%8A%A0%E9%80%9F%E5%99%A8/","content":"本来以为自己挂个vpn，docker就可以不用配国内镜像的。结果发现不行哈哈哈哈这是配置前配置成功后！\n\n 首先配置镜像加速器\nsudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://ia2rmrkg.mirror.aliyuncs.com&quot;]&#125;EOF\n 然后关闭重启docker\nsudo systemctl daemon-reloadsudo systemctl restart docker\n然后就可以随意pull，但是国内镜像好少。好多官网推荐的镜像都没有\n\n\n阿里云镜像地址\n","categories":["centos/linux","docker"],"tags":["centos","docker"]},{"title":"docker入门(centos)","url":"/2022/03/28/docker%E5%85%A5%E9%97%A8/","content":"第一章 docker简史Docker项目最初是由一家名为DotCloud的平台即服务厂商所打造，其后该公司更名为Docker。Docker 在1.8以前直接使用Linux Containers (LXC)，而后自己抽象出Libcontainer层，支持多种容器技术，默认采用LXC实现。与其它容器平台不同，Docker引入了一整套与容器管理相关的生态系统。其中包括一套高效的分层式容器镜像模型、一套全局及本地容器注册表、一个精简化REST API以及一套命令行界面等等。\n第二章 容器和镜像\n容器(container)什么是容器呢？容器就是在你的电脑上一个隔绝其他配置的地方，可以理解为一个小虚拟机，它拥有自己的终端空间(kernel namespaces)、根目录(chroot)和控制组(cgroups)。它的特点如下：\n\n 可以运行镜像(image),你可以创造删除移动修改docker的API或者CLI.\n 可以运行在本地电脑或虚拟机，甚至配置在本地\n 非常便捷，可以在几乎所有操作系统下运行\n 每个容器是独立的，可以独自运行自己的软件、配置\n\n镜像(images)什么是镜像呢？当运行容器时，容器需要独立的文件系统。这个文件系统就是镜像。一个镜像需要包含所需的依赖、脚本各种二进制文件等等。当然我们也可以将容器打包成镜像，在另一台环境不同的机器上运行。因为容器自带配置，所以省去了很多配置环境带来的麻烦。\n仓库(repository)仓库是集中保管镜像的地方，仓库分为公开仓库(public)和私有仓库(private)两种形式。\n\n 最大的开放仓库是Docker hub\n 国内的公开仓库包括阿里云，网易云都有容器服务器等\n\n第三章 如何开始centos下安装docker安装方法有三种，可以挑自己需要的\n\n 设置docker仓库进行安装，这也本文所介绍的\n 提前下载，并选择RPM包进行手动安装(适合连不了网的电脑)\n 使用便捷的自动化脚本\n\n首先可能要卸载旧版本sudo yum remove docker \\                 docker-client \\                 docker-client-latest \\                 docker-common \\                 docker-latest \\                 docker-latest-logrotate \\                 docker-logrotate \\                 docker-engine\n设置仓库$ sudo yum install -y yum-utils$ sudo yum-config-manager \\   --add-repo \\   https://download.docker.com/linux/centos/docker-ce.repo\n\n注意，如果连接不上仓库可以考虑国内的镜像。臂如清华开源的[https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/] ,进网站注意自己找所需要的版本替代即可。docker加速器\n安装Docker查看版本\nyum list docker-ce --showduplicates|sort -r\n安装你刚刚下的\n$ sudo yum install docker-ce docker-ce-cli containerd.io或者yum -y install docker-ce-xx.xx.x.ce\n\n启动Docker$ sudo systemctl start docker\n然后可以用命令：docker version测试Docker是否安装成功，并查看版本信息。\n第四章 Docker使用管理容器# 列出所有运行的容器docker psdocker pa -a  #查看所有容器# 进入容器docker exec -it 容器id bashdocker update –-restart=always id #设置开机自启docker start 容器id\t\t# 启动容器docker restart 容器id\t# 重启容器docker stop 容器id\t\t# 停止正在运行的容器docker kill 容器id\t\t# 强制停止当前容器# 新建容器并启动docker run [可选参数] image--name=&quot;Name&quot;\t 容器名字,用于区分容器-d\t\t\t\t后台方式运行-it\t\t\t\t使用交互方式运行,进入容器查看内容-p\t\t\t\t指定容器端口(小写)-p ip:主机端口:容器端口例如：-p 8080:8080# 容器停止并退出exit# 容器不停止退出Ctrl+p+q# 删除指定容器,不能删除正在运行的容器,强制删除用rm -fdocker rm 容器id# 从容器内拷贝文件到主机docker cp 容器id:容器内路径 目的主机路径\n管理镜像# 下载镜像docker pull 镜像名[:tag]# 查看本地所有镜像docker images# 搜索镜像docker search 镜像名字# 删除镜像docker rmi `docker rmi -f 镜像id`：删除指定镜像 `docker rmi -f 镜像id 镜像id 镜像id`：删除指定多个镜像 `docker rmi -f $(docker images -aq)`：删除全部镜像#查看容器映射docker inspect 容器id\n\n进阶status状态码125：是由Docker守护程序本身造成的，一般是因为 docker run 命令本身报错了126：无法调用所包含的命令，例如权限不足，无法访问目录或者执行命令127：找不到所包含的命令，例如环境中没有安装 curl 命令，但你调用了 curl 命令，那就找不到咯128+N：N是Bash的信号，比如信号是15，那么128+15=143，这时候 docker 的 退出代码就是 Exited(143)\n","categories":["centos/linux","docker"],"tags":["centos","docker","linux"]},{"title":"find查找","url":"/2022/04/21/find%E6%9F%A5%E6%89%BE/","content":""},{"title":"flask服务器部署","url":"/2022/05/15/flask%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/","content":"先拉取docker镜像docker pull python:3.6\n\n运行镜像docker run python:3.6 -p 2222:2222     #一定要记得留端口docker exec -d -it 容器id bash\n\n把python文件传输到docker中#再开一个终端docker cp main.py 容器id:路径\n\n运行","tags":["docker","flask","centos/linux"]},{"title":"git的克隆与上传","url":"/2022/04/10/git%E7%9A%84%E5%85%8B%E9%9A%86%E4%B8%8E%E4%B8%8A%E4%BC%A0/","content":"git clone创建本地仓库先在本地创建自己一个文件夹作为本地仓库。然后打开 git bash\ngit clone  仓库ssh链接\n\ngit add将文件加入缓存区#将数据全部添加缓存，不用一个个添加git add .\n\ngit status查看文件状态\ngit commit提交命令git commit -m &#x27;注释&#x27;\n\ngit push拉取仓库git pull origin master\ngit push将本地master分支上所有代码，都推送到master分支上#推送到起始分支git push origin master\n\ngit log可以查看日志","tags":["git"]},{"title":"ide常用快捷键","url":"/2022/05/05/ide%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"java快捷键psvm\tpublic static void main(String[] args)&#123;&#125;sout\tSystem.out.println()souf\tSystem.out.printf()fori\tfor (int i = 0; i &lt; ; i++) &#123; &#125;\n\n基本操作快捷键ctrl+x //删除行(其实是剪切)ctrl+d //复制当前选择内容，没有选中内容则为复制当前行双击shift\t//查找文件ctrl+shift+f\t//查找内容ctrl+shift+r\t//查找替换内容ctrl+鼠标右键\t//链接到接口等关联ctrl+alt+鼠标右键\t//链接到接口的实现类","tags":["ide","javaee"]},{"title":"github上传大文件","url":"/2022/04/10/github%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/","content":""},{"title":"Hello World","url":"/2021/12/29/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"java多线程机制","url":"/2022/05/06/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/","content":"多线程概念什么是进程打开一个应用程序，就开启一条进程。\n什么是线程进程中的一条执行单元，执行路径\n什么是并行在同一时刻，多个指令可以在多个CPU上同时执行\n什么是并发在同一时刻，多个指令可以在一个CPU上交替执行\n多线程实现方法方法一            1.定义一个类，继承Thread类2.重写run()方法3.创建该类对象4.调用strat()方法\n例如\npackage com.thread1;public class Demo01 &#123;\tpublic static void main(String[] args) &#123;\t\t//创建第一个线程\t\tMyThread mt1 = new MyThread();\t\t//mt1.run();\t\tmt1.start();//开启线程，底层调用了run()方法\t\t\t\t//创建第二个线程\t\tMyThread mt2 = new MyThread();\t\t//mt2.run();\t\tmt2.start();\t\t\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t&#125;&#125;class MyThread extends Thread &#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t&#125;&#125;\n\n方法二            1.定义一个类，实现Runnable接口2.重写run()方法3.创建该类对象4.创建Thread对象，把上一个对象传入其中5.调用start()方法 \n例如\npackage com.thread1;public class Demo02 &#123;\tpublic static void main(String[] args) &#123;\t\tMyRunnable mr = new MyRunnable();\t\t\t\tThread t1 = new Thread(mr);\t\tt1.start();\t\t\t\tThread t2 = new Thread(mr);\t\tt2.start();\t\t\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t&#125;&#125;class MyRunnable implements Runnable &#123;\t@Override\tpublic void run() &#123;\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t&#125;&#125;\n\n方法三            1.定义一个类，实现Callable接口2.重写call()方法3.创建该类对象对象4.创建Future的实现类FutureTask对象，将上一个对象传入其中5.调用get()，可以获取到线程执行完之后的返回值结果6.创建Thread对象，将上一个对象传入其中7.调用start()方法\n例如\npackage com.thread1;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Demo03 &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\tMyCallable mc = new MyCallable();\t\t\t\tFutureTask&lt;String&gt; ft1 = new FutureTask&lt;&gt;(mc);\t\tThread t1 = new Thread(ft1);\t\tt1.start();\t\t\t\tFutureTask&lt;String&gt; ft2 = new FutureTask&lt;&gt;(mc);\t\tThread t2 = new Thread(ft2);\t\tt2.start();\t\t\t\tfor(int i = 1; i &lt;= 100; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t\t\t\tSystem.out.println(ft1.get());\t\tSystem.out.println(ft2.get());\t&#125;&#125;class MyCallable implements Callable&lt;String&gt; &#123;\t@Override\tpublic String call() throws Exception &#123;\t\tfor(int i = 1; i &lt;= 1000; i++) &#123;\t\t\tSystem.out.println(i);\t\t&#125;\t\treturn &quot;约吗&quot;;\t&#125;&#125;\n三种方法的区别1.继承Thread优点：编写代码比较简单，可以直接使用Thread类中的方法\n缺点：扩展性比较差，因为继承了一个类就不能再继承其他的类\n\n2.实现Runnable和Callable接口优点：扩展性比较好，在实现接口的同时还可以继承其他的类\n缺点：编写代码比较复杂，而且不能直接使用Thread类中的方法\n\nThread中的常用API    public final void setName(String name)：设置线程的名字\tpublic final String getName()：获取正在执行的线程的名字\tpublic static Thread currentThread()：获取当前正在执行的线程对象\tpublic final void setPriority(int newPriority)：设置线程优先级#\t\t\t默认优先级为5#\t\t\t数字越大优先级越高#\t\t\t优先级范围：1-10\t\t\t\tpublic final int getPriority()：获取线程优先级\tpublic final void setDaemon(boolean on)：将该线程标记为守护线程或用户线程\t\t\t用户线程全部执行完了守护线程如果没执行完的话它会自动被jvm终止，然后结束程序\tpublic static void sleep(long millis)：让线程睡一会\n\n线程的生命周期#五种状态    新建状态\t就绪状态\t运行状态\t阻塞状态\t死亡状态\n!{}(1.jpg)\n多线程并发问题例子比如一家电影院在出售电影票，一共有三个窗口出售100张。\npublic class Demo01 &#123;\tpublic static void main(String[] args) &#123;\t\tTicket t = new Ticket();\t\t\t\tThread t1 = new Thread(t, &quot;窗口1&quot;);\t\tt1.start();\t\t\t\tThread t2 = new Thread(t, &quot;窗口2&quot;);\t\tt2.start();\t\t\t\tThread t3 = new Thread(t, &quot;窗口3&quot;);\t\tt3.start();\t&#125;&#125;class Ticket implements Runnable &#123;\tpublic int tickets = 100;\t\t@Override\tpublic void run() &#123;\t\t//售票\t\twhile(true) &#123;\t\t\tif(tickets &gt; 0) &#123;\t\t\t\tSystem.out.println(Thread.currentThread().getName() + &quot;...正在出售第...&quot; + tickets + &quot;...张票&quot;);\t\t\t\ttickets--;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n查看结果发现有1.重复的票数2.负数的票数\n解决方法同步代码块1.同步代码块格式：synchronized(锁对象) &#123;\t\t\t\t&#125;\t\t\t\t注意：锁对象可以是任意引用数据类型的对象，但是要保证多个线程是同一把锁对象\t\t\t\t我们什么时候需要用到同步机制？\t1.是多线程的程序\t2.是否有共享资源\t3.操作共享资源的代码是否有多条\t\t\t\t同步代码块又该写在哪个位置？\t把出现共享资源的代码都包含起来即可\n同步格式2.同步方法格式：\t修饰符 synchronized 返回值类型 方法的名字(形参) &#123;\t\tXXXOOO;\t&#125;\t\t\t\t\t同步方法的锁对象是什么？\tthis\n静态同步方法3.静态同步方法格式：\t修饰符 synchronized static 返回值类型 方法的名字(形参) &#123;\t\tXXXOOO;\t&#125;\t\t\t\t\t静态同步方法的锁对象是什么？\t字节码文件对象\t类名.class\nLock锁4.Lock锁ReentrantLock lock = new ReentrantLock();lock.lock();lock.unlock();\n\n\n","tags":["javaee","多线程","蜗牛学苑笔记"]},{"title":"java8的public接口报错","url":"/2022/04/19/java8%E7%9A%84public%E6%8E%A5%E5%8F%A3%E6%8A%A5%E9%94%99/","content":"如图：\n原因：java 8接口中所有方法自动是public,所以接口中定义public关键字不是必须的。\n","tags":["java8","报错"]},{"title":"java线程的其他机制","url":"/2022/05/11/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E6%9C%BA%E5%88%B6/","content":"1.等待唤醒机制解决生产者和消费者的问题\npublic final void wait()：让线程等待public final void notify()：唤醒线程public final void notifyAll()：唤醒所有线程\nwait()方法和sleep()方法的区别    1.wait()是Object类中的普通成员方法\n      sleep()是Thread类中的静态成员方法\n      \n    2.wait()方法等待之后，必须被唤醒\n      sleep()方法睡觉之后，自己会醒\n     \n    3.wait()方法在等待的时候，会释放锁对象\n      sleep()方法在睡觉的时候，不会释放锁对象\n\n2.关于Java中线程安全的类StringBuffer和StringBuilder    StringBuilder：线程不安全的，效率高\n    StringBuffer：线程安全的，效率低\n\nArrayList和Vector    ArrayList：线程不安全的，效率高\n    Vector：线程安全，效率低\n\nHashMap和Hashtable    HashMap：线程不安全，效率高\n    Hashtable：线程安全，效率低\n\n3.死锁现象同步代码块的嵌套会造成死锁现象\n4.Timer类  用法:可安排任务执行一次，或者定期重复执行，计时器类\n常见构造方法public Timer()：   #创建一个新计时器\n常见成员方法public void schedule(TimerTask task, Date time)：安排在指定的时间执行指定的任务。public void schedule(TimerTask task, long delay)：安排在指定延迟后执行指定的任务。public void schedule(TimerTask task, Date firstTime, long period)：\t安排指定的任务在指定的时间开始进行重复的固定延迟执行。public void schedule(TimerTask task, long delay, long period)：\t安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。\n\n5.单例设计模式介绍使用单例设计模式，能够实现一个类只能有一个对象\n实现1饿汉式(立即加载)：因为饿，非常着急的要吃东西\t\t\tclass Singleton &#123;\t\t\t\tprivate static final Singleton singleton = new Singleton();\t\t\t\t\t\t\t\tprivate Singleton() &#123;\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\tpublic static Singleton getInstance() &#123;\t\t\t\t\treturn singleton;\t\t\t\t&#125;\t\t\t&#125;\t\t\t优点：不会出现多线程并发访问问题缺点：对象太早的进内存，太晚消失，占内存\t\t\t\n实现2方法1                class Singleton &#123;\t\t\t\t\tprivate static Singleton singleton;\t\t\t\t\t\t\t\t\t\tprivate Singleton() &#123;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tpublic static Singleton getInstance() &#123;\t\t\t\t\t\tif(singleton == null) &#123;\t\t\t\t\t\t\tsingleton = new Singleton();\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\treturn singleton;\t\t\t\t\t&#125;\t\t\t\t&#125;优点：对象不会太早的进内存，不占用内存缺点：在多线程中，可能会创建出多个对象，就不构成单例了\n\n方法2\t\t\t\tclass Singleton &#123;\t\t\t\t\tprivate static Singleton singleton;\t\t\t\t\t\t\t\t\t\tprivate Singleton() &#123;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tpublic static synchronized Singleton getInstance() &#123;\t\t\t\t\t\tif(singleton == null) &#123;\t\t\t\t\t\t\tsingleton = new Singleton();\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\treturn singleton;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t优点：不占内存，解决线程安全问题缺点：效率低\n\n方法3(主推荐)\t\t\t\tclass Singleton &#123;\t\t\t\t\tprivate static Singleton singleton;\t\t\t\t\t\t\t\t\t\tprivate Singleton() &#123;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tpublic static Singleton getInstance() &#123;\t\t\t\t\t\tif(singleton == null) &#123;\t\t\t\t\t\t\tsynchronized(Singleton.class) &#123;\t\t\t\t\t\t\t\tif(singleton == null) &#123;\t\t\t\t\t\t\t\t\tsingleton = new Singleton();\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\treturn singleton;\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\t优点：不占内存，解决线程安全问题，解决线程安全引发的效率低问题\n\n\n","tags":["javaee","多线程","蜗牛学苑笔记"]},{"title":"java枚举类","url":"/2022/05/11/java%E6%9E%9A%E4%B8%BE%E7%B1%BB/","content":""},{"title":"k8s入门","url":"/2022/04/26/k8s%E5%85%A5%E9%97%A8/","content":"k8s概念先上中文文档\nMasterNodeEtcdReplication ControllerReplicaSetDeploymentPodServiceLabelVolumeNamespaceConfigMap","tags":["linux","centos/linux","服务器"]},{"title":"markdown的语法","url":"/2022/01/08/markdown/","content":"markdown的语法斜体和粗体*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~\n分级标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n超链接（同时可以插入图像）[超链接]# 带有文字的链接[文字](链接)\n\n代码行使用```#include &lt;stdio.h&gt;int main(void)&#123;    printf(&quot;Hello world\\n&quot;);&#125;结尾```\n\n","categories":["计算机","博客"],"tags":["markdown","博客"]},{"title":"linux下的目录结构","url":"/2022/04/19/linux%E4%B8%8B%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","content":"/boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。/etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。/lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。/sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中指令集合：\n/bin：存放着最常用的程序和指令/sbin：只有系统管理员能使用的程序和指令。外部文件管理：\n**/dev **：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。/media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。/mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。临时文件：\n/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。/lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。/tmp：这个目录是用来存放一些临时文件的。账户：\n/root：系统管理员的用户主目录。/home：用户的主目录，以用户的账号命名的。/usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。/usr/bin：系统用户使用的应用程序与指令。/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。/usr/src：内核源代码默认的放置目录。运行过程中要用：\n/var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。/proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。扩展用的：\n/opt：默认是空的，我们安装额外软件可以放在这个里面。/srv：存放服务启动后需要提取的数据（不用服务器就是空）\n","tags":["centos/linux","目录结构"]},{"title":"mybaits和spring集成","url":"/2022/06/15/mybaits%E5%92%8Cspring%E9%9B%86%E6%88%90/","content":"Spring与MyBatis集成Spring+Mybatis \n1、添加依赖&lt;!-- mybatis --&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;5.1.38&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;druid&lt;/artifactId&gt;      &lt;version&gt;1.1.23&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.4.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 对于持久层框架的支持 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;      &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- mybatis和Spring关联的jar --&gt;    &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;2.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.12&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;\n\n2、逆向生成Mybatis代码（手写）方法一ide下载”better-mybaits-generator”\n方法二使用脚本Mybatis-Generator\n添加依赖&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.5&lt;/version&gt;            &lt;configuration&gt;                &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;                &lt;verbose&gt;true&lt;/verbose&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;            &lt;executions&gt;                &lt;!-- &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; --&gt;            &lt;/executions&gt;            &lt;dependencies&gt;                &lt;dependency&gt;                    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                    &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                    &lt;version&gt;1.3.5&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n创建配置文件generatorContext.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;&lt;generatorConfiguration&gt;    &lt;classPathEntry            location=&quot;D:/javaee/repository/mysql/mysql-connector-java/8.0.25/mysql-connector-java-8.0.25.jar&quot; /&gt;    &lt;context id=&quot;mysql&quot; targetRuntime=&quot;MyBatis3&quot; defaultModelType=&quot;flat&quot;&gt;        &lt;!-- 生成的Java文件的编码 --&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;!-- 格式化java代码 --&gt;        &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;        &lt;!-- 格式化XML代码 --&gt;        &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;        &lt;!--beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号；--&gt;        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;        &lt;!-- 为了防止生成的代码中有很多注释，比较难看，加入下面的配置控制 --&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/seven_group?serverTimezone=UTC&amp;amp;charactorEncoding=utf-8&quot;                        userId=&quot;root&quot; password=&quot;root&quot; /&gt;        &lt;!--实体生成路径 --&gt;        &lt;javaModelGenerator targetPackage=&quot;com.Springdemo.enity&quot;                            targetProject=&quot;src/main/java&quot; &gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;            &lt;!--&lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;--&gt;        &lt;/javaModelGenerator&gt;        &lt;!--mapper文件生成路径 --&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.Springdemo&quot;                         targetProject=&quot;src/main/resources&quot; /&gt;        &lt;!--dao层生成路径 --&gt;        &lt;javaClientGenerator targetPackage=&quot;com.Springdemo&quot;                             targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot; /&gt;        &lt;table tableName=&quot;表明字&quot; domainObjectName=&quot;要创建的名字&quot;               enableCountByExample=&quot;true&quot;               enableUpdateByExample=&quot;true&quot;               enableDeleteByExample=&quot;true&quot;               enableSelectByExample=&quot;true&quot;               selectByExampleQueryId=&quot;false&quot;&gt;        &lt;property name=&quot;my.isgen.usekeys&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;useActualColumnNames&quot; value=&quot;true&quot;/&gt;        &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;\n注意    1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；\n启动配置文件右键启动!{}(1.png)\n3、Spring的配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!--        扫描所有要被Spring管理的实例    --&gt;    &lt;context:component-scan base-package=&quot;com.woniu&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--        生成数据库连接池对象    --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;!--&lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;--&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        生成SqlSessionFactory    --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.woniu.pojo&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        扫描所有dao        通过下面的配置扫描com.woniu.dao,将所有dao接口对应dao.xml生成对应的实例    --&gt;    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.woniu.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n4、生成代码EmpService\npackage com.woniu.service.impl;import com.woniu.dao.EmpDAO;import com.woniu.pojo.Emp;import com.woniu.service.EmpService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @Author: Panda * @Date: 2021/4/21 11:57 * @Description: */@Servicepublic class EmpServiceImpl implements EmpService &#123;    @Autowired    private EmpDAO empDAO;    @Override    public List&lt;Emp&gt; getAllEmps() &#123;        return empDAO.selectByExample(null);    &#125;&#125;\n\nEmpServlet\npackage com.woniu.controller;import com.woniu.pojo.Emp;import com.woniu.service.EmpService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;/** * @Author: Panda * @Date: 2021/4/21 12:02 * @Description: */@WebServlet(&quot;/emp&quot;)public class EmpServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app.xml&quot;);        EmpService empService = (EmpService) applicationContext.getBean(&quot;empServiceImpl&quot;);        List&lt;Emp&gt; emps = empService.getAllEmps();        req.setAttribute(&quot;emps&quot;,emps);        req.getRequestDispatcher(&quot;list.jsp&quot;).forward(req,resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;\n\nlist.jsp\n&lt;%@ page import=&quot;com.woniu.pojo.Emp&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%--  Created by IntelliJ IDEA.  User: Panda  Date: 2021/4/21  Time: 12:07  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;%           List&lt;Emp&gt; emps = (List&lt;Emp&gt;) request.getAttribute(&quot;emps&quot;);           for(Emp emp:emps)&#123;        %&gt;            &lt;li&gt;&lt;%=emp.getEname() %&gt;&lt;/li&gt;        &lt;%           &#125;        %&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;\n","tags":["mybaits","spring","蜗牛学院笔记"]},{"title":"mybaits","url":"/2022/05/30/mybaits/","content":"###MyBatis简介\n介绍MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。iBATIS一词来源于“internet”和“abatis”的组合，是一个(基于Java的持久层框架)。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）MyBatis基于ORM思想的框架\n使用Java代码操作数据库的方式1.JDBC 最原始的2.JdbcTemplate JDBC工具类 基于ORM3.MyBatis 框架 基于ORM\nMyBatis的优点1.简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学\n习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。\n    \n2.灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 \nsql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。\n    \n3.解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，\n更易单元测试。sql和代码的分离，提高了可维护性。\n    \n4.提供映射标签，支持对象与数据库的orm字段关系映射\n    \n5.提供对象关系映射标签，支持对象关系组建维护\n    \n6.提供xml标签，支持编写动态sql\n    \n\nMyBatis的使用步骤：1.导入相关jar2个jar包            \nmybatis.jar\nmysql驱动.jar\n        \n\n2.编写普通的Java类创建一个User类\n        \n\n3.编写Dao的接口UserDao接口\n    里面提供增删改查等方法\n        \n\n4.编写MyBatis核心配置文件在src路径下创建一个名为sqlMapConfig.xml的配置文件，建议名字不要起别的\n\n\t&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\t&lt;!DOCTYPE configuration\tPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\t&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\t&lt;configuration&gt;\t\t&lt;environments default=&quot;mysql&quot;&gt;\t\t\t&lt;environment id=&quot;mysql&quot;&gt;\t\t\t\t&lt;transactionManager type=&quot;JDBC&quot;/&gt;\t\t\t\t&lt;dataSource type=&quot;POOLED&quot;&gt;\t\t\t\t\t&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\t\t\t\t\t&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db6&quot;/&gt;\t\t\t\t\t&lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\t\t\t\t\t&lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt;\t\t\t\t&lt;/dataSource&gt;\t\t\t&lt;/environment&gt;\t\t&lt;/environments&gt;\t\t\t\t\t\t\t&lt;mappers&gt;\t\t\t&lt;mapper resource=&quot;com/mybatis/dao/UserMapper.xml&quot;/&gt;\t\t&lt;/mappers&gt;\t&lt;/configuration&gt;```\t\t#### 5.编写MyBatis的映射文件在dao包下创建一个名为UserMapper.xml的映射文件```\t\t&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mybatis.dao.UserDao&quot;&gt;\t&lt;select id=&quot;findAll&quot; resultType=&quot;com.mybatis.pojo.User&quot;&gt;\t\tselect * from user\t&lt;/select&gt;&lt;/mapper&gt;```\t\t\t#### 6.进行测试\n1.获取流对象，读取核心核心配置文件    InputStream is = Resources.getResourceAsStream(“sqlMapConfig.xml”);\n2.创建SqlSession工厂的构建者对象    SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\n3.获取SqlSession工厂对象    SqlSessionFactory factory = builder.build(is);\n4.获取SqlSession对象    SqlSession session = factory.openSession();\n5.获取UserDao的代理对象    UserDao userDao = session.getMapper(UserDao.class);\n6.调用查询方法    List users = userDao.findAll();    for (User user : users) {        System.out.println(user);    }```\n","tags":["数据库","mybaits"]},{"title":"mybaits进阶","url":"/2022/05/31/mybaits%E8%BF%9B%E9%98%B6/","content":""},{"title":"mybaits逆向工程","url":"/2022/06/11/mybaits%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","content":""},{"title":"nginx入门","url":"/2022/04/12/nginx%E5%85%A5%E9%97%A8/","content":"nginx简介先看官网的介绍.NGINX应用程序平台是一套产品，它们共同构成了企业创建具有性能、可靠性、安全性和规模的应用程序所需的核心。NGINX应用平台包括用于负载均衡和应用程序交付的NGINX Plus、用于安全的NGINX App Protect，以及用于运行应用程序代码的NGINX单元，所有这些都由NGINX Controller监控和管理。它的功能有1.作为web服务器 （本篇着重讲解，其余的日后整理）2.正向代理3.反向代理4.负载均衡5.动静分离\nnginx的安装下载地址 （记得下载stable长期稳定版）\nnginx的常用命令和配置文件nginx -s signalsignal：stop — fast shutdownquit — graceful shutdownreload — reloading the configuration filereopen — reopening the log files\n注意：输入命令前要加上可执行文件,如:\n./sbin/nginx -s stop\nnginx.conf编写listen：80如果配置项直接就是listen 80，那么相当于默认监听该端口下的所有地址，即*.80。\n查看进程ps -ef|grep nginx\n\n\ndocker run  -d -it --name jeecg_nginx -p 2233:2233 --restart=always -v /data/nginx_cn_en_pu/nginx/logs/nginx:/var/log/nginx -v /data/nginx_cn_en_pu/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /data/nginx_cn_en_pu/nginx/conf.d:/etc/nginx/conf.d -v /data/nginx_cn_en_pu/nginx/html:/usr/share/nginx/html nginx","tags":["centos/linux","web服务器"]},{"title":"opencv图像变换","url":"/2022/01/11/opencv%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2/","content":"图片处理图片处理四个步骤 1.load 2.info 3.resize 4.check\n共同代码：\nimport cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeprint(imgInfo)height=imgInfo[0]width=imgInfo[1]mode=imgInfo[2]        #颜色\n图片缩放将长高等比例缩小\ndstHeight=int(height*0.5)           #等比例缩小dstWidth=int(width*0.5)dst=cv2.resize(img,(dstHeight,dstWidth))\n图片剪切dst=img[100:200,0:300]            #从多少像素切到多少像素\n\n图片移位使用warpAffine()函数移位matShift=np.float32([[1,0,100],[0,1,200]])         #2*3dst=cv2.warpAffine(img,matShift,(height,width))      #1-data  2-mat  3-info\nwarpAffine变换矩阵实现图像移位\nvoid cv::warpAffine     (   InputArray      src,        OutputArray     dst,        InputArray      M,        Size    dsize,        int     flags = INTER_LINEAR,        int     borderMode = BORDER_CONSTANT,        const Scalar &amp;      borderValue = Scalar()     )\n参数解释：. src: 输入图像. dst: 输出图像，尺寸由dsize指定，图像类型与原图像一致. M: 2X3的变换矩阵. dsize: 指定图像输出尺寸. flags: 插值算法标识符，有默认值INTER_LINEAR，如果插值算法为WARP_INVERSE_MAP, \nfor循环移动像素移位dst = np.zeros(img.shape,np.uint8)height = imgInfo[0]width = imgInfo[1]for i in range(0,height):    for j in range(0,width-100):        dst[i,j+100]=img[i,j]\n\n图片镜像newImgInfo=(height*2,width,mode)dst=np.zeros(newImgInfo,np.uint8)         #设置画板for i in range(0,height):                 #for 循环转置像素    for j in range(0,width):        dst[i,j]=img[i,j]        dst[height*2-i-1,j]=img[i,j]for i in range(0,width):    dst[height,i]=(0,0,255)      #BGR\n图片缩放img=cv2.imread(&#x27;image0.jpg&#x27;,1)cv2.imshow(&#x27;src&#x27;,img)matScale=np.float32([[0.5,0,0],[0,0.5,0]])dst=cv2.warpAffine(img,matScale,(int(width/2),int(height/2)))\n\n仿射变换matSrc=np.float32([[0,0],[0,height-1],[width-1,0]])matDst=np.float32([[50,50],[300,height-200],[width-300,100]])matAffine=cv2.getAffineTransform(matSrc,matDst)dst=cv2.warpAffine(img,matAffine,(width,height))\n\n旋转变化matRotate = cv2.getRotationMatrix2D((height*0.5,width*0.5),45,1)dst = cv2.warpAffine(img,matRotate,(height,width))\ngetRotationMatrix2D函数调用形式\nMat getRotationMatrix2D(Point2f center, double angle, double scale)\n参数详解：\nPoint2f center：表示旋转的中心点double angle：表示旋转的角度double scale：图像缩放因子","categories":["机器学习","opencv"],"tags":["机器学习","opencv","图片处理"]},{"title":"rancher入门","url":"/2022/03/30/rancher%E5%85%A5%E9%97%A8/","content":"第一章  什么是rancherRancher是一个开源的企业级全栈化容器部署及管理平台。随着Kubernetes在市场上的崛起，Rancher 专门部署和管理在任何提供商的任何地方运行的Kubernetes集群。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。\nrancher又以下四部分组成\n基础设施编排Rancher可以使用任何公有云或者私有云的Linux主机资源。Linux主机可以是虚拟机，也可以是物理机。Rancher仅需要主机有CPU，内存，本地磁盘和网络资源。从Rancher的角度来说，一台云厂商提供的云主机和一台自己的物理机是一样的。\nRancher为运行容器化的应用实现了一层灵活的基础设施服务。Rancher的基础设施服务包括网络， 存储， 负载均衡， DNS和安全模块。Rancher的基础设施服务也是通过容器部署的，所以同样Rancher的基础设施服务可以运行在任何Linux主机上。\n容器编排与调度很多用户都会选择使用容器编排调度框架来运行容器化应用。Rancher包含了当前全部主流的编排调度引擎，例如Docker Swarm， Kubernetes， 和Mesos。同一个用户可以创建Swarm或者Kubernetes集群。并且可以使用原生的Swarm或者Kubernetes工具管理应用。\n除了Swarm，Kubernetes和Mesos之外，Rancher还支持自己的Cattle容器编排调度引擎。Cattle被广泛用于编排Rancher自己的基础设施服务以及用于Swarm集群，Kubernetes集群和Mesos集群的配置，管理与升级。\n应用商店Rancher的用户可以在应用商店里一键部署由多个容器组成的应用。用户可以管理这个部署的应用，并且可以在这个应用有新的可用版本时进行自动化的升级。Rancher提供了一个由Rancher社区维护的应用商店，其中包括了一系列的流行应用。Rancher的用户也可以创建自己的私有应用商店。\n企业级权限管理Rancher支持灵活的插件式的用户认证。支持Active Directory，LDAP， Github等 认证方式。 Rancher支持在环境级别的基于角色的访问控制 (RBAC)，可以通过角色来配置某个用户或者用户组对开发环境或者生产环境的访问权限。\n下图展示了Rancher的主要组件和功能：\n第二章  rancher安装和介绍快速部署 Rancher 和 Kubernetes 集群的方式共有三种：\n\n一种是在 Amazon EKS 上部署 Rancher\n另一种是在虚拟机上部署 Rancher，支持的虚拟机厂商包括：AWS、DigitalOcean、Azure、Google Cloud Platform 和 Vagrant。\n采用在已有虚拟机上手动部署（也是本文采用的方式）\n\n相关名词介绍Rancher Server： 是用于管理和配置 Kubernetes 集群。你可以通过 Rancher Server 的 UI 与下游 Kubernetes 集群进行交互。\n**RKE（Rancher Kubernetes Engine)**：是经过认证的 Kubernetes 发行版，它拥有对应的 CLI 工具可用于创建和管理 Kubernetes 集群。在 Rancher UI 中创建集群时，它将调用 RKE 来配置 Rancher 启动的 Kubernetes 集群。\n**K3s (轻量级 Kubernetes)**： 和 RKE 类似，也是经过认证的 Kubernetes 发行版。它比 RKE 更新，更易用且更轻量化，全部组件都在一个小于 100 MB 的二进制文件中。从 Rancher v2.4 开始，Rancher 可以安装在 K3s 集群上。\nRKE2是一个完全合规的 Kubernetes 发行版，专注于安全和合规性。\nRancherD是安装 Rancher 的新工具，从 Rancher v2.5.4 开始支持。它是一个实验性功能。RancherD 是一个二进制文件，它首先启动一个 RKE2 Kubernetes 集群，然后在集群上安装 Rancher Server Helm chart。\n常规pull rancher镜像docker pull rancher/server\n\n运行docker run -d --restart=unless-stopped -p 8080:8080 rancher/server\n\n\n第三章  如何通过ui界面管理(暂时使用1.6版本，以后会更新)\n点击添加主机\n根据步骤操作\n1 安装docker\n2 UDP端口测试\n#先确定是否装有nc服务which nc#用法:nc -vuz &lt;目标服务器 IP&gt; &lt;待测试端口&gt;# 参数说明：-v 详细输出（用两个-v可得到更详细的内容）-u 使用UDP传输协议-z 让nc只扫描端口，不发送任何的数据\n\n3 在主机上增加标签，起个名字\n4 设置此台主机ip\n5 cv到另一台主机上运行rancher\nrancher文档rancher官网\n","categories":["centos/linux","rancher"],"tags":["centos","docker","rancher"]},{"title":"mysql数据库的约束","url":"/2022/04/02/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BA%A6%E6%9D%9F/","content":"mysql的各种约束非空约束  NOT NULL保证列中所有的数据不能有null值。\n语法如下:\n\n添加约束\n-- 创建表时添加非空约束CREATE TABLE 表名(   列名 数据类型 NOT NULL,   …); -- 建完表后添加非空约束ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL; -- 删除约束ALTER TABLE 表名 MODIFY 字段名 数据类型;\n\n唯一约束  UNIQUE保证列中所有数据各不相同。\n语法如下:\n\n添加约束\n -- 创建表时添加唯一约束 CREATE TABLE 表名(    列名 数据类型 UNIQUE [AUTO_INCREMENT],    -- AUTO_INCREMENT: 当不指定值时自动增长,如id     );  CREATE TABLE 表名(    列名 数据类型,        [CONSTRAINT] [约束名称] UNIQUE(列名) );  -- 建完表后添加唯一约束 ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;-- 删除约束 ALTER TABLE 表名 DROP INDEX 字段名;\n\n主键约束  PRIMARY KEY主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。比如id\n语法如下:\n\n添加约束\n-- 创建表时添加主键约束CREATE TABLE 表名(   列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],   …); CREATE TABLE 表名(   列名 数据类型,   [CONSTRAINT] [约束名称] PRIMARY KEY(列名)); -- 建完表后添加主键约束ALTER TABLE 表名 ADD PRIMARY KEY(字段名);-- 删除约束ALTER TABLE 表名 DROP PRIMARY KEY;\n检查约束  CHECK保证列中的值满足某一条件。\n\n语法如下:*\n\n添加约束\n\n\n\n默认约束  DEFAULT保存数据时，未指定值则采用默认值\n语法如下:\n\n添加约束-- 创建表时添加默认约束CREATE TABLE 表名(   列名 数据类型 DEFAULT 默认值,   …); -- 建完表后添加默认约束ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值; -- 删除约束ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;\n\n外键约束  FOREIGN KEY外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。(可以建立多表)\n语法如下:\n\n添加约束 -- 创建表时添加外键约束CREATE TABLE 表名(   列名 数据类型,   …   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) );  -- 建完表后添加外键约束ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); -- 删除外键约束ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n","categories":["数据库","mysql"],"tags":["数据库","mysql"]},{"title":"root用户启动firefox报错","url":"/2022/03/29/root%E7%94%A8%E6%88%B7%E5%90%AF%E5%8A%A8firefox%E6%8A%A5%E9%94%99/","content":"今天遇见了个很神奇的报错centos中admin账户可以打开火狐浏览器，而权限更高的root不可以\n报错如下：\n解决方案cd /run/user/1000# 然后修改权限就行了chown -R root ./\n\n然后就解决了，可能会警告，但是最后发现可以打开了。\n"},{"title":"servlet概括","url":"/2022/07/08/servlet%E6%A6%82%E6%8B%AC/","content":"servlet的生命周期？三个生命周期方法：init()：初始化方法service()：执行方法destroy()：销毁方法\n1.当我们通过浏览器第一次访问一个servlet的时候，servlet对象会被创建，    随后会执行init方法，随后会执行service方法\n2.当我们通过浏览器重复的访问同一个servlet的时候，servlet对象不会再创建，也不会再执行in法，    但是会执行service方法\n3.当我们正常的关闭服务器，就会执行destroy方法\n如何将Servlet对象的创建提前呢？需要配置：            servletDemo02        com.servlet.ServletDemo02        1    \n注意：load-on-startup的默认值为-1，也就说当我们第一次访问servlet的时候才会创建对象，调用init方法      数字用来给多个servlet的创建时机排序的\nservlet的参数配置？等第三阶段学习三大框架整合的时候会用上\n&lt;servlet&gt;\t&lt;servlet-name&gt;servletDemo04&lt;/servlet-name&gt;\t&lt;servlet-class&gt;com.servlet.ServletDemo04&lt;/servlet-class&gt;\t&lt;init-param&gt;\t\t&lt;param-name&gt;name&lt;/param-name&gt;\t\t&lt;param-value&gt;tom&lt;/param-value&gt;\t&lt;/init-param&gt;\t&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;\n@Overridepublic void init(ServletConfig config) throws ServletException &#123;\t//获取到xml中配置的参数的数据\t\t\t\tString value = config.getInitParameter(&quot;name&quot;);\tSystem.out.println(value);&#125;\n\nservlet的注解配置//@WebServlet(urlPatterns= &#123;&quot;/servletDemo05&quot;&#125;)//@WebServlet(urlPatterns = &quot;/servletDemo05&quot;)//@WebServlet(value = &quot;/servletDemo05&quot;)@WebServlet(&quot;/servletDemo05&quot;)\n\nservlet的体系结构通用接口javax.servlet.Servlet 接口    通用的servlet接口    – javax.servlet.GenericServlet 抽象类    通用的servlet实现类        – javax.servlet.http.HttpServlet 抽象类    具体的实现类(针对http协议的servlet实现类)        –javax.servlet.ftp.FtpServlet        – javax.servlet.ppp.PPPServlet\n适配器设计模式interface A&#123;    public void aaaa();    public void bbbb();    public void cccc();    public void dddd();    public void eeee();                                                           &#125;//类B充当了适配器abstract class B interface A&#123;//抽象类中不一定有抽象方法，有抽象方法的一定是抽象类    @Override    public void aaa()&#123;    &#125;    .    .    .    @Override    public void eeee()&#123;    &#125;class C extends B&#123;\t//这样方法C就不用重写A中的所有方法\tpublic void bbb()&#123;\t&#125;&#125;\nIO流底层的设计模式装饰设计模式\n适配器设计模式\n        \n\nservlet的实现方式？方式一：实现Servlet接口\tclass ServletDemo1 implements Servlet &#123;\t\t\t&#125;```\t\t#### 方式二：继承GenericServlet\nclass ServletDemo02 extends GenericServlet &#123;\n            \n&#125;\n\n#### 方式三：继承HttpServlet\nclass ServletDemo03 extends HttpServlet &#123;\n            \n&#125;\n    \n注意：重写doGet()和doPost()\n\n            \n### servlet的url-pattern的配置？\n        @WebServlet(&quot;路径&quot;)\n    \n        路径的写法有哪些？\n            1. /XXX\n                @WebServlet(&quot;/servletDemo1&quot;)\n                @WebServlet(&quot;/aaa&quot;)\n                \n            2. /XXX/OOO\n                @WebServlet(&quot;/aaa/servletDemo08&quot;)\n                @WebServlet(&quot;/aaa/bbb&quot;)\n                @WebServlet(&quot;/aaa/bbb/*&quot;)\n                \n            3. *.do\n                @WebServlet(&quot;*.do&quot;)\n                @WebServlet(&quot;*.aaa&quot;)\n                \n        注意：\n            1. /*.do\n                /和*.do是不能写在一起的\n                \n            2. /*/servletDemo08\n                此时的*不是通配符\n            \n            3. /\n\n","tags":["servlet"]},{"title":"rancher管理服务器","url":"/2022/04/22/rancher%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":""},{"title":"springboot日志配置","url":"/2022/07/11/springboot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/","content":""},{"title":"simhash求文本相似度","url":"/2022/06/12/simhash%E6%B1%82%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6/","content":"定义SimHash是一种局部敏感hash，它也是Google公司进行海量网页去重使用的主要算法。\n传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统的hash算法产生的两个签名，如果原始内容在一定概率下是相等的；如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大。所以传统的Hash是无法在签名的维度上来衡量原内容的相似度，而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。我们主要解决的是文本相似度计算，要比较的是两个文章是否相似，当然我们降维生成了hash签名也是用于这个目的。看到这里估计大家就明白了，我们使用的simhash就算把文章中的字符串变成 01 串也还是可以用于计算相似度的，而传统的hash却不行。\n基本流程1.分词2.hash3.加权4.合并5.降维","tags":["机器学习","文本相似度"]},{"title":"sklearn.svm.SVC中kernel参数说明","url":"/2022/01/16/sklearn.svm.SVC%E4%B8%ADkernel%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/","content":"sklearn.svm.SVC中kernel参数说明线性核函数kernel=‘linear’采用线性核kernel=’linear’的效果和使用sklearn.svm.LinearSVC实现的效果一样，但采用线性核时速度较慢，特别是对于大数据集，推荐使用线性核时使用LinearSVC\n多项式核函数kernel=‘poly’degree代表d，表示多项式的次数gamma为多项式的系数，coef0代表r，表示多项式的偏置注：coef0是sklearn.svm.SVC中的参数\n径向基核函数kernel=‘rbf’可以将gamma理解为支持向量影响区域半径的倒数，gamma越大，支持向量影响区域越小，决策边界倾向于只包含支持向量，模型复杂度高，容易过拟合；gamma越小，支持向量影响区域越大，决策边界倾向于光滑，模型复杂度低，容易欠拟合；gamma的取值非常重要，即不能过小，也不能过大\nsigmod核函数kernel=‘sigmod’coef0控制r,sigmod核函数是线性核函数经过tanh函数映射变化\n","categories":["计算机","机器学习","scikit-learn","SVM"],"tags":["机器学习","scikit-learn","SVC"]},{"title":"springboot概括","url":"/2022/07/11/springboot%E6%A6%82%E6%8B%AC/","content":""},{"title":"spring框架","url":"/2022/06/05/spring%E6%A1%86%E6%9E%B6/","content":"Spring框架介绍Spring是一个轻量级的IoC和AOP的框架\nIoC控制反转\nAOP面向切面编程\nSpring的功能image-20210310101742629\n优点：1）方便解耦，简化开发Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给 Spring 管理。2）方便集成各种优秀框架Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如 Struts2、Hibernate、MyBatis等）的直接支持。3）降低 Java EE API 的使用难度Spring 对 Java EE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些API 应用的难度大大降低。4）方便程序的测试Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。5）AOP 编程的支持Spring 提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。6）声明式事务的支持只需要通过配置就可以完成对事务的管理，而无须手动编程。  \n接口和Spring是完美搭配\n以前\npublic interface UserDAO&#123;\tvoid save();&#125;public class UserDAOImpl implements UserDAO&#123;\tpublic void save()&#123;\t\t....\t&#125;&#125;public class UserServiceImpl implements UserService&#123;    private UserDAO userDAO;    public void reg()&#123;        userDAO.save();        ....    &#125;&#125;--------------------------------------------------------------    public class UserDAOJDBCImpl implements UserDAO&#123;\tpublic void save()&#123;\t\t....\t&#125;&#125;public class UserServiceImpl implements UserService&#123;    private UserDAO userDAO;    public void reg()&#123;        userDAO.save();        ....    &#125;&#125;我们在UserServiceImpl中不再实例化DAO对象从Spring容器中获得\n\n\n\n\n\n搭建Spring环境1、添加依赖&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\n2、编写Beanpackage com.woniu.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * @Author: Panda * @Date: 2021/4/20 11:38 * @Description: */@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    private String uname;    private String upwd;&#125;\n\n3、编写配置文件先将模板在idea中生成\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        com.woniu.User user = new com.woniu.User();        &lt;bean&gt;声明实例化对象的信息        id对象的名称        class对象的类型    --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.woniu.pojo.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n4、测试获取user对象package com.woniu.test;import com.woniu.pojo.User;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @Author: Panda * @Date: 2021/4/20 11:48 * @Description: */public class AppTest &#123;    @Test    public void test()&#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app.xml&quot;);        User user = (User) applicationContext.getBean(&quot;user&quot;);        user.setUname(&quot;admin&quot;);        user.setUpwd(&quot;123&quot;);        System.out.println(&quot;AppTest.test&quot;+user);    &#125;&#125;\n\n\n\nIoC容器介绍BeanFactory在没有获取容器中实例时，不实例化对应的对象\nBeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;app.xml&quot;));BeanFactory beanFactory1 = new XmlBeanFactory(new FileSystemResource(&quot;d:/app.xml&quot;));\n\n\n\nApplicationContextApplicationContext applicationContext2 = new FileSystemXmlApplicationContext(&quot;d:/app.xml&quot;);ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app.xml&quot;);ApplicationContext applicationContext3 = new AnnotationConfigApplicationContext(JavaConfig.class);\n\n容器生成时，就会实例化配置文件中声明的对象\nApplicationContext从BeanFactory派生出来的\nApplicationContext增加了以下功能\n\n国际化（MessageSource）\n\n访问资源，如URL和文件（ResourceLoader）\n\n载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  \n\n消息发送、响应机制（ApplicationEventPublisher）\n\nAOP（拦截器）\n\n\nBean的概念Spring中Bean就是一个类的实例\n&lt;bean id=&quot;&quot; class=&quot;&quot; /&gt;通过构造器完成类的实例化\n\nBean的生成方式有三种：\n1、构造器生成\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        Bean的生成方式        1、构造器生成        com.woniu.pojo.User必须有为空的构造器    --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.woniu.pojo.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n@Test    public void testConstrutor()&#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app2.xml&quot;);        User user = (User) applicationContext.getBean(&quot;user&quot;);        System.out.println(user);    &#125;\n\n2、静态工厂\npackage com.woniu.util;import com.woniu.pojo.User;/** * @Author: Panda * @Date: 2021/4/20 15:22 * @Description: */public class UserFactory &#123;    public static User getUser()&#123;        return new User();    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        2、静态工厂        User user = UserFactory.getUser();    --&gt;    &lt;bean id=&quot;user2&quot; class=&quot;com.woniu.util.UserFactory&quot; factory-method=&quot;getUser&quot;&gt;&lt;/bean&gt;  &lt;/beans&gt;\n\n3、实例工厂\npackage com.woniu.util;import com.woniu.pojo.User;/** * @Author: Panda * @Date: 2021/4/20 15:22 * @Description: */public class UserFactory2 &#123;    public User getUser()&#123;        return new User();    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        3、实例工厂        UserFactory userFactory = new UserFactory();        User user = userFactory.getUser();    --&gt;    &lt;bean id=&quot;userFactory&quot; class=&quot;com.woniu.util.UserFactory2&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;user3&quot; factory-bean=&quot;userFactory&quot; factory-method=&quot;getUser&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\nbean的作用域范围scope有如下五个取值：\nsingleton：单例的（默认的），使用singleton定义的Bean是单例的，每次调用getBean都是调用的同一个对象。只要IoC容器一创建就会创建Bean的实例。prototype：多例的，每次通过Spring IoC容器获取prototype定义的Bean时，容器都将创建一个新的Bean实例。创建时不会实例该Bean，只有调用getBean方法时，才会实例化。request：作用于web的请求范围，在每一次HTTP请求时，容器会返回Bean的同一个实例，对不同的HTTP请求则会产生一个新的Bean，而且该Bean仅在当前HTTP Request内有效。session：作用于web的会话范围，在一次HTTP Session中，容器会返回该Bean的同一个实例，对不同的HTTP请求则会产生一个新的Bean，而且该Bean仅在当前HTTP Session内有效。global-session：作用于集群环境的会话范围（全局会话范围），在一个全局的HTTP Session中，容器返回Bean的同一个实例。当不是集群环境时，它就是session。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        Bean的作用范围        prototype   原型  每次获取产生一个新的实例        singleton   单例  每次获取都是同一个实例        request     以下三个属性是在web应用中使用        session        gobal-session    --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.woniu.pojo.User&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n@Testpublic void testScope()&#123;    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;app3.xml&quot;);    //从容器中两次获得相同的id，判断两个实例是否相等，相等为单例，否则为多例    User user = (User) applicationContext.getBean(&quot;user&quot;);    User user2 = (User) applicationContext.getBean(&quot;user&quot;);    System.out.println(user==user2);&#125;\n\n\n\n依赖注入概述Setter注入package com.woniu.service.impl;import com.woniu.dao.UserDAO;import com.woniu.service.UserService;/** * @Author: Panda * @Date: 2021/4/20 15:53 * @Description: */public class UserServiceImpl implements UserService &#123;    private UserDAO userDAO;    public UserServiceImpl()&#123;    &#125;\t//setter注入    public void setUserDAO(UserDAO userDAO)&#123;        this.userDAO = userDAO;    &#125;    @Override    public void save() &#123;        userDAO.save();        System.out.println(&quot;UserServiceImpl.save&quot;);    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--        DI  依赖注入        UserDAO userDAO = new UserDAOImpl();        UserService userService = new UserServiceImpl();        这时需要通过setter或者构造器注入        1、setter注入    --&gt;    &lt;bean id=&quot;userDAO&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot;&gt;        &lt;!-- 调用UserServiceImpl中的setUserDAO方法 --&gt;        &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n构造器注入package com.woniu.service.impl;import com.woniu.dao.UserDAO;import com.woniu.service.UserService;/** * @Author: Panda * @Date: 2021/4/20 15:53 * @Description: */public class UserServiceImpl implements UserService &#123;    private UserDAO userDAO;    public UserServiceImpl(UserDAO userDAO)&#123;        this.userDAO = userDAO;    &#125;    @Override    public void save() &#123;        userDAO.save();        System.out.println(&quot;UserServiceImpl.save&quot;);    &#125;&#125;\n\n\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;       &lt;!--        2、构造器注入    --&gt;    &lt;bean id=&quot;userDAO2&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService2&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot;&gt;        &lt;!-- 调用UserServiceImpl中的有参构造器 --&gt;        &lt;constructor-arg name=&quot;userDAO&quot; ref=&quot;userDAO2&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;   &lt;/beans&gt;\n\n\n\n命名空间&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       //添加下面两个命名空间       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;       &lt;!--        命名空间注入        本质还是setter和构造器注入，只是换了种方式    --&gt;    &lt;bean id=&quot;userDAO3&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService3&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot; c:userDAO-ref=&quot;userDAO3&quot; p:userDAO-ref=&quot;userDAO3&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\n自动装配&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--       自动装配       byName 按照名字装配，要求bean的id于servcie中声明的对象一致       byType 按照类型装配，要求容器中该类型只能有一个实例    --&gt;    &lt;bean id=&quot;userDAO&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\nFactoryBeanSpring 中有两种类型的Bean，一种是普通Bean，另一种是工厂Bean 即 FactoryBean。FactoryBean跟普通Bean不同，其返回的对象不是指定类的一个实例，而是该FactoryBean的getObject方法所返回的对象。创建出来的对象是否属于单例由isSingleton中的返回决定。\n一般情况下，Spring通过反射机制利用的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean的形式\n以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。\npackage com.woniu.util;import com.woniu.dao.impl.UserDAOImpl;import com.woniu.service.UserService;import com.woniu.service.impl.UserServiceImpl;import org.springframework.beans.factory.FactoryBean;/** * @Author: Panda * @Date: 2021/4/20 17:01 * @Description: */public class UserServiceFactoryBean implements FactoryBean&lt;UserService&gt; &#123;    /**     * &lt;bean id=&quot;roleDAO&quot; class=&quot;com.woniu.dao.impl.RoleDAOImpl&quot;&gt;     *     &lt;/bean&gt;     *     &lt;bean id=&quot;userDAO&quot; class=&quot;com.woniu.dao.impl.UserDAOImpl&quot;&gt;&lt;/bean&gt;     *     &lt;bean id=&quot;userService&quot; class=&quot;com.woniu.service.impl.UserServiceImpl&quot;&gt;     *         &lt;property name=&quot;userDAO&quot; ref=&quot;userDAO&quot;&gt;&lt;/property&gt;     *         &lt;property name=&quot;roleDAO&quot; ref=&quot;roleDAO&quot;&gt;&lt;/property&gt;     *     &lt;/bean&gt;     * @return     * @throws Exception    \t通过FactoryBean返回指定类型的对象     */    @Override    public UserService getObject() throws Exception &#123;    \t//编写复杂的组装逻辑        UserServiceImpl userService = new UserServiceImpl();        userService.setUserDAO(new UserDAOImpl());        return userService;    &#125;\t//当前对象的类型    @Override    public Class&lt;?&gt; getObjectType() &#123;        return null;    &#125;\t//返回的对象是否为单例    @Override    public boolean isSingleton() &#123;        return true;    &#125;&#125;\n\n\n\nSpring常用注解@Component\n​    @Controller \n​    @Service\n​    @Repository\n在配置文件中添加命名空间context，还需添加格式文件\n扫描指定包下所有的类，找到有以上注解的类，并添加到Spring容器中进行管理&lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt;\n\n\n注意：\n1、需要注入的对象，在属性上添加注解@Autowire或者@Resource\n2、所有bean的id默认为类名首字母小写。否则需要在注解中声明实例的id。\n\n","tags":["spring","蜗牛学院笔记"]},{"title":"springboot集成nacos","url":"/2022/05/15/springboot%E9%9B%86%E6%88%90nacos/","content":""},{"title":"springmvc概括","url":"/2022/07/02/springmvc%E6%A6%82%E6%8B%AC/","content":"SpringMVCSpringMVC概述使用SpringMVC替换Servlet\nServlet的问题：\n1、需要判断调用哪个方法。（逻辑需要自己编写）\n2、需要获得request的数据，并且需要手动封装，还要进行类型转换。\n3、跳转和转发数据的代码太繁琐。\n4、通过ajax请求的对象，需要通过fastjson进行转换，并使用相应对象的输出流写出。\n以上问题SpringMVC都给出了解决方案。\n1、添加依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n2、在web.xml中配置前端控制器&lt;!--     前端控制器  --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;         &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;!--      /表示拦截了除了jsp之外所有的请求    --&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;\n\n\n\n3、编写SpringMVC的配置文件（结构和Spring配置文件一致）&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--        映射器  ：找到类中的方法    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;/bean&gt;    &lt;!--        适配器  ：执行类中的方法    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot; &gt;&lt;/bean&gt;    &lt;!--        视图解析器 ：返回所需的文件后缀（jsp,html）    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置Controller    --&gt;    &lt;bean id=&quot;/user&quot; class=&quot;com.woniu.controller.UserController&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\n4、编写Controllerpackage com.woniu.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;/** * @Author: Panda * @Date: 2021/4/23 14:35 * @Description: */public class UserController implements Controller &#123;    @Override    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;        System.out.println(&quot;UserController.handleRequest&quot;);        return null;    &#125;&#125;\n\n\n\n5、通过浏览器访问Controller\nSpringMVC的工作机制\nDispatcherServlet&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--        映射器        BeanNameUrlHandlerMapping        在浏览器中发送/user        通过/user在Spring容器中找到id对应的实例        SimpleUrlHandlerMapping        声明一个映射关系        Properties    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;        &lt;property name=&quot;mappings&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;/user&quot;&gt;userController&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--        适配器        SimpleControllerHandlerAdapter        可以执行实现了Controller接口的控制器        HttpRequestHandlerAdapter        可以执行实现了HttpRequestHandler接口的控制器    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot; &gt;&lt;/bean&gt;    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot; &gt;&lt;/bean&gt;    &lt;!--        视图解析器        prefix 从webapp根目录指定        suffix 是后缀    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置Controller    --&gt;    &lt;bean id=&quot;userController&quot; class=&quot;com.woniu.controller.UserController&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\n\n\nController的实现使用注解配置Controller\npackage com.woniu.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;/** * @Author: Panda * @Date: 2021/4/23 16:34 * @Description: */@Controllerpublic class UserController3 &#123;    @RequestMapping(&quot;list&quot;)    public ModelAndView list()&#123;        System.out.println(&quot;UserController3.save&quot;);        ModelAndView mav = new ModelAndView();        mav.setViewName(&quot;list&quot;);  //    /list.jsp        User user = new User();        user.setUname(&quot;leon&quot;);        user.setUpwd(&quot;123&quot;);        //request.setAttribute();        mav.addObject(&quot;user&quot;,user);        return  mav;    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu&quot;&gt;&lt;/context:component-scan&gt;    &lt;!--        RequestMappingHandlerMapping        找到注解RequestMapping的值userSave，找到了要执行的方法         &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;&gt;&lt;/bean&gt;         &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;&lt;/bean&gt;        &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;可以替换上面两个配置，不仅仅如此    --&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--        视图解析器        prefix 从webapp根目录指定        suffix 是后缀    --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\nModelAndView类package com.woniu.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;/** * @Author: Panda * @Date: 2021/4/23 16:34 * @Description: */@Controllerpublic class UserController3 &#123;    @RequestMapping(&quot;list&quot;)    public ModelAndView list()&#123;        System.out.println(&quot;UserController3.save&quot;);        ModelAndView mav = new ModelAndView();        mav.setViewName(&quot;list&quot;);  //    /list.jsp        User user = new User();        user.setUname(&quot;leon&quot;);        user.setUpwd(&quot;123&quot;);        //request.setAttribute();        mav.addObject(&quot;user&quot;,user);        return  mav;    &#125;    @RequestMapping(&quot;list2&quot;)    public ModelAndView list2()&#123;        System.out.println(&quot;UserController3.delete&quot;);        ModelAndView mav = new ModelAndView();        mav.setViewName(&quot;list&quot;);  //    /list.jsp        List&lt;User&gt; list = new ArrayList&lt;&gt;();        User user = new User();        user.setUname(&quot;leon&quot;);        user.setUpwd(&quot;123&quot;);        User user2 = new User();        user2.setUname(&quot;jack&quot;);        user2.setUpwd(&quot;111&quot;);        list.add(user);        list.add(user2);        //request.setAttribute(); 名字默认为类型与泛型的组合 userList        mav.addObject(list);        return  mav;    &#125;    @RequestMapping(&quot;list3&quot;)    public String list3(Model model)&#123;        System.out.println(&quot;UserController3.save&quot;);        List&lt;User&gt; list = new ArrayList&lt;&gt;();        User user = new User();        user.setUname(&quot;leon&quot;);        user.setUpwd(&quot;123&quot;);        User user2 = new User();        user2.setUname(&quot;andy&quot;);        user2.setUpwd(&quot;111&quot;);        list.add(user);        list.add(user2);        model.addAttribute(list);        return  &quot;list&quot;; // /list.jsp    &#125;    @RequestMapping(&quot;list4&quot;)    public String list4()&#123;        return  &quot;redirect:list.jsp&quot;;    &#125;&#125;\n\n\n\n视图解析器概述将Controller的返回值进行解析，到浏览器。\n在SpringMVC中也有很多视图解析器\n\n这时通过视图解析器解析handler返回的值（逻辑视图，转发数据）\nInternalResourceViewResolver会将逻辑视图与prefix和suffix组合成物理视图名，如果逻辑视图返回值中包含redirect:,则进行重定向操作，如果是forward：或者没有前缀，则转发操作。\n\n编写一个视图\npackage com.woniu.controller.a_view;import org.springframework.web.servlet.View;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Map;/** * @Author: Panda * @Date: 2021/4/26 09:42 * @Description: */public class MyView implements View &#123;    private String viewUrl;    public MyView()&#123;    &#125;    public MyView(String viewUrl)&#123;        this.viewUrl = viewUrl;    &#125;    @Override    public String getContentType() &#123;        return null;    &#125;    @Override    public void render(Map&lt;String, ?&gt; map, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        if(viewUrl.startsWith(&quot;redirect:&quot;)) &#123;            httpServletResponse.sendRedirect(viewUrl.split(&quot;:&quot;)[1]);        &#125;else&#123;            for (Map.Entry&lt;String, ?&gt; entry : map.entrySet()) &#123;                httpServletRequest.setAttribute(entry.getKey(), entry.getValue());            &#125;            httpServletRequest.getRequestDispatcher(viewUrl).forward(httpServletRequest, httpServletResponse);        &#125;    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.a_view&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--\t\tBeanNameViewResolver是当前项目的中视图解析器\t\tMyView声明了跳转的方式和数据转发\t--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\npackage com.woniu.controller.a_view;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;/** * @Author: Panda * @Date: 2021/4/23 14:35 * @Description: */@Controllerpublic class UserController&#123;    @RequestMapping(&quot;save&quot;)    public ModelAndView save()&#123;        System.out.println(&quot;UserController.save&quot;);        ModelAndView mav = new ModelAndView();        mav.setView(new MyView(&quot;redirect:abc.jsp&quot;));        mav.addObject(&quot;a&quot;,&quot;123&quot;);        return mav;    &#125;&#125;\n\n\n\n请求映射1、RequestMapping可以声明在类和方法上RequestMapping\n可以声明在类上，如果要访问方法，需要将类的RequestMapping的值与方法上的RequestMapping的值组合访问。\nhttp://localhost:8080/项目名称/类上注解/方法上注解\n\n\n为了防止直接通过浏览器访问jsp页面，将所有页面放到WEB-INF下。只能通过控制器跳转。在视图解析器中的前缀添加WEB-INF。\n\n2、可以根据不同的请求方式，来控制哪种请求可以访问@Controller@RequestMapping(&quot;user&quot;)  // /user/savepublic class UserController &#123;    //method = RequestMethod.POST只有页面通过post传参，才可以访问到这个方法    @RequestMapping(value = &quot;save&quot;,method = RequestMethod.POST)    public String save()&#123;        System.out.println(&quot;UserController.save123&quot;);        return &quot;abc&quot;;    &#125;&#125;\n\n\n浏览器地址栏访问都是Get请求。\n\n3、在RequestMapping中添加params//页面需要传递params中声明的参数，且值必须相等，这时才可以访问该方法@RequestMapping(value = &quot;login&quot;,params = &#123;&quot;token=asdfarwerqwer&quot;&#125;)public String login(String uname,String upwd)&#123;    System.out.println(&quot;UserController.login:&quot;+uname+&quot;:&quot;+upwd);    return &quot;abc&quot;;&#125;\n\n4、在RequestMapping中添加headers//可以在RequestMapping中声明headers,获得页面传递的请求头，从请求头中获得对应的信息，如果该信息相等，允许访问该方法   @RequestMapping(value = &quot;list&quot;,headers = &quot;host=localhost:8080&quot;)  //headers = &quot;host=localhost:8080&quot;只允许本机访问。   public String list()&#123;       System.out.println(&quot;UserController.list&quot;);       return &quot;abc&quot;;   &#125;\n\n5、在RequestMapping中添加占位符@RequestMapping(&quot;login2/&#123;upwd&#125;/&#123;uname&#125;&quot;)//需要使用注解public String login2(@PathVariable(&quot;upwd&quot;) String p,@PathVariable(&quot;uname&quot;) String n)&#123;    System.out.println(&quot;UserController.login2:&quot;+n+&quot;:&quot;+p);    return &quot;abc&quot;;&#125;\n\n\n\n控制器方法入参1、基本数据类型的自动转化2、自动封装数据package com.woniu.controller.c_param;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import java.util.List;/** * @Author: Panda * @Date: 2021/4/23 14:35 * @Description: */@Controllerpublic class UserController &#123;    /**     * 在SpringMVC的Controller中不再需要request.getParameter(),直接在方法的参数中声明即可，要求参数名与表单控件的name一致     * 如果非要不一致，则需要添加注解@RequestParam(&quot;表单的name值&quot;)     * @param name     * @param password     * @return     */    @RequestMapping(&quot;save1&quot;)    public String save1(String name,@RequestParam(&quot;pwd&quot;) String password)&#123;        System.out.println(&quot;UserController.save1:&quot;+name+&quot;:&quot;+password);        return null;    &#125;    //SpringMVC的Controller，可以对数据进行自动转换    @RequestMapping(&quot;save2&quot;)    public String save2(float age)&#123;        System.out.println(&quot;UserController.save2:&quot;+age);  //输出出生年份        return null;    &#125;    //可以将表单的数据自动封装成对象(参数中指定的类型)    @RequestMapping(&quot;save3&quot;)    public String save3(User user)&#123;        System.out.println(&quot;UserController.save3:&quot;+user);  //输出出生年份        return null;    &#125;    //复选框的值可以直接获得为字符串数据,整型数组,如果需要List&lt;Integer&gt;类型,则需要添加注解@RequestParam    @RequestMapping(&quot;save4&quot;)    public String save4(@RequestParam List&lt;Integer&gt; ids)&#123;        System.out.println(&quot;UserController.save4:&quot;+ids.get(0));  //输出出生年份        return null;    &#125;&#125;\n\n&lt;%--  Created by IntelliJ IDEA.  User: Panda  Date: 2021/4/23  Time: 16:48  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;false&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;传递参数到Controller&lt;/h3&gt;   &lt;form action=&quot;save1&quot; method=&quot;post&quot;&gt;       &lt;input name=&quot;name&quot;&gt;       &lt;input name=&quot;pwd&quot;&gt;       &lt;button&gt;submit&lt;/button&gt;   &lt;/form&gt;    &lt;hr&gt;    &lt;h3&gt;传递整型数据&lt;/h3&gt;    &lt;form action=&quot;save2&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;age&quot;&gt;        &lt;button&gt;submit&lt;/button&gt;    &lt;/form&gt;    &lt;hr&gt;    &lt;h3&gt;传递对象数据&lt;/h3&gt;    &lt;form action=&quot;save3&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;uname&quot;&gt;        &lt;input name=&quot;age&quot;&gt;        &lt;button&gt;submit&lt;/button&gt;    &lt;/form&gt;&lt;hr&gt;    &lt;h3&gt;模拟数据自动封装&lt;/h3&gt;    &lt;form action=&quot;userServlet&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;uname&quot;&gt;        &lt;input name=&quot;age&quot;&gt;        &lt;button&gt;submit&lt;/button&gt;    &lt;/form&gt;    &lt;hr&gt;    &lt;h3&gt;传递复选框数据&lt;/h3&gt;    &lt;form action=&quot;save4&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;1&quot;&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;2&quot;&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;3&quot;&gt;        &lt;button&gt;submit&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n模拟自动封装代码\npackage com.woniu.controller.c_param;import java.lang.reflect.Field;import java.util.Map;/** * @Author: Panda * @Date: 2021/4/26 14:30 * @Description: */public class Tools &#123;    public static Object map2Object(Map&lt;String, String[]&gt; parameterMap, Class&lt;?&gt; userClass) &#123;        try &#123;            Object object = userClass.newInstance();            for(Map.Entry&lt;String,String[]&gt; entry:parameterMap.entrySet())&#123;                String key = entry.getKey();        //uname  age                String[] value = entry.getValue();  //admin  25                    Field field = userClass.getDeclaredField(key); //uname                    field.setAccessible(true);                    if(field.getType()==String.class)&#123;                        field.set(object,value[0]);                    &#125;else if(field.getType()==int.class||field.getType()==Integer.class)&#123;                        field.set(object,Integer.parseInt(value[0]));                    &#125;            &#125;            return object;        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n\n\n时间类型参数SpringMVC中默认识别日期格式为yyyy/MM/dd\n其他格式需要自己编写转换类\npackage com.woniu.controller.d_convert;import org.springframework.core.convert.converter.Converter;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * @Author: Panda * @Date: 2021/4/26 15:18 * @Description: */public class DateConverter implements Converter&lt;String, Date&gt; &#123;    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);    @Override    public Date convert(String s) &#123;        Date date = null;        try &#123;            date = simpleDateFormat.parse(s);        &#125; catch (ParseException e) &#123;            try &#123;                date = simpleDateFormat2.parse(s);            &#125; catch (ParseException parseException) &#123;                parseException.printStackTrace();            &#125;        &#125;        return date;    &#125;&#125;\n\n将转换类配置到SpringMVC框架中\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.d_convert&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;        &lt;property name=&quot;converters&quot;&gt;            &lt;set&gt;                &lt;bean class=&quot;com.woniu.controller.d_convert.DateConverter&quot;&gt;&lt;/bean&gt;            &lt;/set&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n使用ServletAPIHttpServletRequest\nHttpServletResponse\nHttpSession\nServletContext\nHttpServletRequest，HttpServletResponse，HttpSession对象都可以从方法参数中获取\n@RequestMapping(&quot;login&quot;)public String login(String uname, HttpServletRequest req, HttpServletResponse resp, HttpSession session)&#123;     System.out.println(&quot;UserController.req:&quot;+req);     System.out.println(&quot;UserController.resp:&quot;+resp);     System.out.println(&quot;UserController.session:&quot;+session);     System.out.println(&quot;UserController.application:&quot;+session.getServletContext());     return null;&#125;\n\n\n\nSpringMVC数据校验正则表达式\n​    电话号码格式\n​    邮箱格式\n​    身份证格式等等\n前端数据校验\n后端数据校验\n1、添加依赖&lt;dependency&gt;      &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;      &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;      &lt;version&gt;6.0.20.Final&lt;/version&gt;    &lt;/dependency&gt;\n\n2、定义校验规则在封装类上定义校验规则，JSR303\npackage com.woniu.controller.e_validator;import javax.validation.constraints.NotBlank;/** * @Author: Panda * @Date: 2021/4/23 16:46 * @Description: */public class User &#123;    //null &quot;&quot;    @NotBlank(message = &quot;uname 不能为空!&quot;)    private String uname;    private String upwd;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;uname=&#x27;&quot; + uname + &#x27;\\&#x27;&#x27; +                &quot;, upwd=&#x27;&quot; + upwd + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public String getUname() &#123;        return uname;    &#125;    public void setUname(String uname) &#123;        this.uname = uname;    &#125;    public String getUpwd() &#123;        return upwd;    &#125;    public void setUpwd(String upwd) &#123;        this.upwd = upwd;    &#125;&#125;\n\n3、对需要校验的数据添加注解@Validatedpackage com.woniu.controller.e_validator;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.Errors;import org.springframework.validation.FieldError;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.Date;import java.util.List;/** * @Author: Panda * @Date: 2021/4/26 10:40 * @Description: */@Controllerpublic class UserController &#123;    @RequestMapping(&quot;save&quot;)   public String save(@Validated User user, Errors errors)&#123;        //获得表单传递值校验的错误信息        List&lt;FieldError&gt; fieldErrors = errors.getFieldErrors();        for(FieldError fieldError:fieldErrors)&#123;            System.out.println(fieldError.getField()+&quot;:&quot;+fieldError.getDefaultMessage());        &#125;        return null;   &#125;&#125;\n\n4、在SpringMVC中注册校验器&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.e_validator&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven validator=&quot;validator&quot;&gt;&lt;/mvc:annotation-driven&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;        &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\nSpringMVC集成JSON1、添加依赖将对象或者集合转换成json\n&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.11.4&lt;/version&gt;&lt;/dependency&gt;\n\n2、在方法上添加注解@ResponseBody@RequestMapping(&quot;list&quot;)   @ResponseBody  //返回的对象交给jackson-databind进行转json并输出的操作   public List&lt;User&gt; list(HttpServletResponse response)&#123;       System.out.println(&quot;UserController.list&quot;);       User user = new User();       user.setUname(&quot;admin&quot;);       user.setUpwd(&quot;123&quot;);       User user2 = new User();       user2.setUname(&quot;aaa&quot;);       user2.setUpwd(&quot;1213&quot;);       List&lt;User&gt; userList = new ArrayList&lt;&gt;();       userList.add(user);       userList.add(user2);       return userList;   &#125;\n\n\n\n1、要求页面传递数据格式为jsondata:JSON.stringify(jsonStr)\n\n2、在Controller方法上添加注解@RequestBodypublic String save(@RequestBody User user)\n\n3、因为默认按照键值对解析数据需要将请求类型改为application/json\ncontentType:&quot;application/json&quot;\n\n\n\n\n可以使用POSTMAN进行测试。\n\nRESTful概念REST（英文：Representational State Transfer，简称REST）\n表述性状态转移; 表现状态传输;\n描述了一个架构样式的网络系统，比如 web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，Roy Fielding是 HTTP 规范的主要编写者之一。\n在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。值得注意的是REST并没有一个明确的标准，而更像是一种设计的风格。 \n特点RESTFUL特点包括：\n1、每一个URI代表1种资源；\n2、客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；\n3、通过操作资源的表现形式来操作资源；\n4、资源的表现形式是XML或者HTML；\n5、客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。\nRESTful资源设计规则URIURI 表示资源，资源一般对应服务器端领域模型中的实体类。\nURI规范不用大写；用中杠-不用下杠_；参数列表要encode；URI中的名词表示资源集合，使用复数形式。\n资源集合 vs 单个资源URI表示资源的两种方式：资源集合、单个资源。\n资源集合：\n/zoos //所有动物园/zoos/1/animals //id为1的动物园中的所有动物\n单个资源：\n/zoos/1 //id为1的动物园/zoos/1;2;3 //id为1，2，3的动物园\n避免层级过深的URI/在url中表达层级，用于按实体关联关系进行对象导航，一般根据id导航。\n过深的导航容易导致url膨胀，不易维护，如 GET /zoos/1/areas/3/animals/4，尽量使用查询参数代替路径中的实体导航，如GET /animals?zoo=1&amp;area=3；\n对Composite资源的访问服务器端的组合实体必须在uri中通过父实体的id导航访问。\n组合实体不是first-class的实体，它的生命周期完全依赖父实体，无法独立存在，在实现上通常是对数据库表中某些列的抽象，不直接对应表，也无id。一个常见的例子是 User — Address，Address是对User表中zipCode/country/city三个字段的简单抽象，无法独立于User存在。必须通过User索引到Address：GET /user/1/addresses\n\nRequestHTTP方法通过标准HTTP方法对资源CRUD：\n\nGET：查询\nGET /zoosGET /zoos/1GET /zoos/1/employees\nPOST：创建单个资源。POST一般向“资源集合”型uri发起\nPOST /animals  //新增动物POST /zoos/1/employees //为id为1的动物园雇佣员工\nPUT：更新单个资源（全量），客户端提供完整的更新后的资源。与之对应的是 PATCH，PATCH 负责部分更新，客户端提供要更新的那些字段。PUT/PATCH一般向“单个资源”型uri发起\nPUT /animals/1PUT /zoos/1\nDELETE：删除\nDELETE /zoos/1/employees/2DELETE /zoos/1/employees/2;4;5DELETE /zoos/1/animals  //删除id为1的动物园内的所有动物\npackage com.woniu.controller.g_rest;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletResponse;import java.util.ArrayList;import java.util.List;/** * @Author: Panda * @Date: 2021/4/26 10:40 * @Description: */@RestController@RequestMapping(&quot;users&quot;)public class UserController &#123;    //get请求都是做查询操作    //使用get请求http://localhost:8080/projectname/users    @GetMapping    public String findAll()&#123;        System.out.println(&quot;UserController.findAll&quot;);        return &quot;a&quot;;    &#125;    //使用get请求http://localhost:8080/projectname/users/1    @GetMapping(value = &quot;&#123;id&#125;&quot;)    public String findOne(@PathVariable(&quot;id&quot;) Integer uid)&#123;        System.out.println(&quot;UserController.findOne:&quot;+uid);        return null;    &#125;    //post请求做新增操作    @PostMapping    public String save(User user)&#123;        System.out.println(&quot;UserController.save:&quot;+user);        return null;    &#125;    //put请求做修改操作    @PutMapping    public String update(User user)&#123;        System.out.println(&quot;UserController.update:&quot;+user);        return null;    &#125;    //delete请求做删除操作    @DeleteMapping(value = &quot;&#123;id&#125;&quot;)    public String delete(@PathVariable(&quot;id&quot;) Integer uid)&#123;        System.out.println(&quot;UserController.delete:&quot;+uid);        return null;    &#125;&#125;\n\n&lt;%--  Created by IntelliJ IDEA.  User: Panda  Date: 2021/4/23  Time: 16:48  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;false&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form  action=&quot;users&quot; method=&quot;post&quot;&gt;        &lt;input name=&quot;uname&quot;&gt;        &lt;input name=&quot;upwd&quot; &gt;        &lt;button&gt;save&lt;/button&gt;    &lt;/form&gt;    &lt;form  action=&quot;users&quot; method=&quot;post&quot;&gt;        &lt;!--            如果要做put请求:            1.需要添加隐藏域,声明put请求            2.使用一个过滤器读取隐藏域信息,完成put请求         --&gt;        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt;        &lt;input name=&quot;uname&quot;&gt;        &lt;input name=&quot;upwd&quot;&gt;        &lt;button&gt;update&lt;/button&gt;    &lt;/form&gt;    &lt;form  action=&quot;users/1002&quot; method=&quot;post&quot;&gt;        &lt;!--            如果要做put请求:            1.需要添加隐藏域,声明put请求            2.使用一个过滤器读取隐藏域信息,完成put请求         --&gt;        &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt;        &lt;button&gt;delete&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;!--    RESTful风格中过滤请求方式(put,delete)  --&gt;  &lt;filter&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--     前端控制器  --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:g_rest/springmvc-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;!--      /表示拦截了除了jsp之外所有的请求    --&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n\n\n处理静态资源1）采用&lt;mvc:default-servlet-handler /&gt;在springMVC-servlet.xml中配置&lt;mvc:default-servlet-handler /&gt;后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，它会像一个检查员，对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。\n一般Web应用服务器默认的Servlet名称是”default”，因此DefaultServletHttpRequestHandler可以找到它。如果你所有的Web应用服务器的默认Servlet名称不是”default”，则需要通过default-servlet-name属性显示指定：\n&lt;mvc:default-servlet-handler default-servlet-name=”所使用的Web服务器默认使用的Servlet名称” /&gt;\n2）采用&lt;mvc:resources /&gt;&lt;mvc:default-servlet-handler /&gt;将静态资源的处理经由Spring MVC框架交回Web应用服务器处理。而&lt;mvc:resources /&gt;更进一步，由Spring MVC框架自己处理静态资源，并添加一些有用的附加值功能。\n首先，&lt;mvc:resources /&gt;允许静态资源放在任何地方，如WEB-INF目录下、类路径下等，你甚至可以将JavaScript等静态文件打到JAR包中。通过location属性指定静态资源的位置，由于location属性是Resources类型，因此可以使用诸如”classpath:”等的资源前缀指定资源位置。传统Web容器的静态资源只能放在Web容器的根路径下，&lt;mvc:resources /&gt;完全打破了这个限制。\n其次，&lt;mvc:resources /&gt;依据当前著名的Page Speed、YSlow等浏览器优化原则对静态资源提供优化。你可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。在输出静态资源时，会根据配置设置好响应报文头的Expires 和 Cache-Control值。\n在接收到静态资源的获取请求时，会检查请求头的Last-Modified值，如果静态资源没有发生变化，则直接返回303相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.g_rest&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--        配置web服务器的默认Servlet来处理静态资源    --&gt;    &lt;!--&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;--&gt;    &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;&gt;&lt;/mvc:resources&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\nSpringMVC拦截器1.编写一个拦截器package com.woniu.controller.h_interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @Author: Panda * @Date: 2021/4/27 14:03 * @Description: */public class LoginInterceptor implements HandlerInterceptor &#123;    /**     * 在handle执行之前     * @param httpServletRequest     * @param httpServletResponse     * @param o     * @return     * @throws Exception     */    @Override    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;        System.out.println(&quot;LoginInterceptor.preHandle&quot;);        //如果return true则放行        return true;    &#125;    /**     * 在handle执行之后     * @param httpServletRequest     * @param httpServletResponse     * @param o     * @param modelAndView     * @throws Exception     */    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;LoginInterceptor.postHandle&quot;);    &#125;    /**     * 在视图解析之后     * @param httpServletRequest     * @param httpServletResponse     * @param o     * @param e     * @throws Exception     */    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;        System.out.println(&quot;LoginInterceptor.afterCompletion&quot;);    &#125;&#125;\n\n2、配置拦截器&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller.h_interceptor&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!--        配置web服务器的默认Servlet来处理静态资源    --&gt;    &lt;!--&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;--&gt;    &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;&gt;&lt;/mvc:resources&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        配置拦截器栈    --&gt;    &lt;mvc:interceptors&gt;        &lt;!--            配置拦截器        --&gt;        &lt;mvc:interceptor&gt;            &lt;!--                配置拦截规则            --&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;mvc:exclude-mapping path=&quot;/login&quot;/&gt;            &lt;!--                拦截器对象            --&gt;            &lt;bean class=&quot;com.woniu.controller.h_interceptor.LoginInterceptor&quot;&gt;&lt;/bean&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;&lt;/beans&gt;\n\n\n\nSpringMVC文件上传1、表单&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;file&quot; name=&quot;uploadFile&quot; /&gt;    &lt;button&gt;upload&lt;/button&gt;&lt;/form&gt;\n\n2、添加依赖&lt;dependency&gt;  &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;\n\n3、上传的操作package com.woniu.controller.i_upload;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.util.UUID;/** * @Author: Panda * @Date: 2021/4/27 14:23 * @Description: */@Controllerpublic class UploadController &#123;    @RequestMapping(&quot;upload&quot;)    public String upload(MultipartFile photo, HttpServletRequest request)&#123;        //声明一个指定目录,用来存放上传的文件        String realPath = request.getServletContext().getRealPath(&quot;/upload&quot;);        System.out.println(&quot;UploadController.upload:&quot;+realPath);        File dir = new File(realPath);        if(!dir.exists())&#123;            dir.mkdirs();        &#125;        //每个上传的文件名不重复UUID, 当前时间的毫秒数        String fileName = photo.getOriginalFilename();  //getName获取的是控件的名字        String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); //1.jpg  .jpg        fileName = UUID.randomUUID()+suffix;        try &#123;            photo.transferTo(new File(dir,fileName));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n4、上传解析器&lt;!-- 解析器必须添加id，否则会导致上传不成功 --&gt;    &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;maxUploadSize&quot; value=&quot;20000000&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;\n\n\n\nSpringMVC异常处理1、编写异常处理类package com.woniu.controller.j_exception;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * @Author: Panda * @Date: 2021/4/27 15:22 * @Description: */@ControllerAdvicepublic class ExceptionHandlerDemo implements HandlerExceptionResolver &#123;    @ExceptionHandler    @Override    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123;        System.out.println(&quot;ExceptionHandlerDemo.resolveException:&quot;+o.getClass());        ModelAndView modelAndView = new ModelAndView();        modelAndView.setViewName(&quot;error&quot;);        modelAndView.addObject(&quot;message&quot;,e.getMessage());        return modelAndView;    &#125;&#125;\n\n\n\n2、编写异常展示页面&lt;%--  Created by IntelliJ IDEA.  User: Panda  Date: 2021/4/23  Time: 16:48  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; isELIgnored=&quot;false&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   $&#123;message&#125;&lt;/body&gt;&lt;/html&gt;\n\n3、编写Controller生成异常package com.woniu.controller.j_exception;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;/** * @Author: Panda * @Date: 2021/4/27 15:21 * @Description: */@Controllerpublic class UserController &#123;    @RequestMapping(&quot;test/&#123;num&#125;&quot;)    public String test(@PathVariable(&quot;num&quot;) Integer num)&#123;        System.out.println(&quot;UserController.test:&quot;+(10/num));        return null;    &#125;&#125;\n\n\n\nSSM框架整合1、添加依赖Mybatis\n&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.38&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.23&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.4.6&lt;/version&gt;        &lt;/dependency&gt;\n\nSpringMVC\n&lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;        &lt;/dependency&gt;\n\nSpring对orm的支持\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;    &lt;version&gt;4.3.18.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\nMybatis和Spring的关联\n&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;2.0.6&lt;/version&gt;&lt;/dependency&gt;\n\n其他配置\n        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.12.3&lt;/version&gt;        &lt;/dependency&gt;&lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;            &lt;version&gt;6.2.0.Final&lt;/version&gt;        &lt;/dependency&gt;\n\n\n\n2、在web.xml中配置配置SpringMVC的前端控制器\n配置隐藏方法过滤器\n配置编码过滤器\n配置Spring的监听器\n配置Spring的配置文件位置\n&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;filter&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;  &lt;/filter&gt;  &lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n\n\n\n3、Spring配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;    &lt;!--        扫描所有带注解的类    --&gt;    &lt;context:component-scan base-package=&quot;com.woniu&quot; &gt;        &lt;!-- 排除Conroller注解 --&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;/context:component-scan&gt;    &lt;!--        数据源    --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; value=&quot;woniu&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        SqlSessionFactory    --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        扫描所有mapper    --&gt;    &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.woniu.dao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        事务管理器    --&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--        声明式事务    --&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt;\n\n\n\n4、SpringMVC的配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--        扫描所有的Controller    --&gt;    &lt;context:component-scan base-package=&quot;com.woniu.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n\n5、生成Mybatis的代码6、编写Service和Controller","tags":["蜗牛学院笔记","SpringMVC"]},{"title":"ssh远程连接","url":"/2022/03/31/ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/","content":" SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd,负责实时监听客户端的请求(IP 22端口)，包括公共秘钥等交换等信息。\nssh服务端由2部分组成： openssh(提供ssh服务)    openssl(提供加密的程序)\nssh的客户端可以用 XSHELL，Securecrt, Mobaxterm等工具进行连接\n一些常用的ssh命令#指定用户登录ssh root@ip地址      #修改端口登录ssh root -p 8080 ip地址 ssh  -Y root@host        #可以图形化操作(比如打开firefox) #重启sshd服务service sshd restart#退出连接exit\n一些常用的ssh配置命令#复制SSH密钥到目标主机，开启无密码SSH登录ssh-copy-id root@hos     #如果还没有密钥，请使用ssh-keygen命令生成。# 清除公钥ssh-keygen -R 10.36.xx.xx\n\nssh传输文件命令scp -r 【本地要上传文件地址】  [用户名]@[ip地址]：远程地址#-r代表上传的是文件夹以及文件夹里所有的东西\n\n\n\n\n\n相关博客：小a玖拾柒xxq_2010\n","categories":["centos/linux","ssh"],"tags":["centos/linux","ssh"]},{"title":"vue第一篇_语法","url":"/2022/07/12/vue%E7%AC%AC%E4%B8%80%E7%AF%87-%E8%AF%AD%E6%B3%95/","content":""},{"title":"xml技术","url":"/2022/05/19/xml%E6%8A%80%E6%9C%AF/","content":"xml概括xml是可扩展标记语言(Extensive Markup Language)。\n可扩展所谓的可扩展其实是相对于html来说的因为html中的标签都是固定的，提前都定义好每个标签代表什么意思，我们自己是不可以瞎写的而xml可以扩展，也就是说可以瞎写，随便写\n&lt;yuema&gt;&lt;/yuema&gt;\n\n标记语言代码是由标签组成的由一对尖括号&lt;&gt;组成的\nxml和html区别1.html的标签都是预定义的                    xml的标签都是自定义的        \n2.html是非常不严谨的，也就说我们很难把它给写错了        xml是非常严谨的，也就说我们很难把它给写对了\n3.html是用来也写页面，展示数据        xml是用来当做配置文件的，存储数据\nxml作用当做配置文件来使用\nxml作为配置文件和properties配置文件的区别properties配置文件：    主要用于单项配置\njdbc.properties：\tdriver=com.mysql.jdbc.Driver\turl=jdbc:mysql://localhost:3306/db1\tusername=root\tpassword=root\t\t\t\t\tdriver=com.oracle.jdbc.Driver\turl=jdbc:oracle://localhost:3306/db1\tusername=root\tpassword=123\nxml配置文件：    主要用于多项配置\njdbc.xml：\t&lt;databases&gt;\t\t&lt;database id=&quot;mysql&quot;&gt;\t\t\t&lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;\t\t\t&lt;url&gt;jdbc:mysql://localhost:3306/db1&lt;/url&gt;\t\t\t&lt;username&gt;root&lt;/username&gt;\t\t\t&lt;password&gt;root&lt;/password&gt;\t\t&lt;/database&gt;\t\t&lt;database id=&quot;oracle&quot;&gt;\t\t\t&lt;driver&gt;com.oracle.jdbc.Driver&lt;/driver&gt;\t\t\t&lt;url&gt;jdbc:oracle://localhost:3306/db2&lt;/url&gt;\t\t\t&lt;username&gt;root&lt;/username&gt;\t\t\t&lt;password&gt;123&lt;/password&gt;\t\t&lt;/database&gt;\t&lt;/databases&gt;\n案例#1.创建一个文本文件，后缀名该为xml#2.在xml文件中写以下内容：\t&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\t&lt;students&gt;\t\t&lt;student id=&quot;9527&quot;&gt;\t\t\t&lt;name&gt;tom&lt;/name&gt;\t\t\t&lt;age&gt;18&lt;/age&gt;\t\t&lt;/student&gt;\t\t&lt;student id=&quot;9528&quot;&gt;\t\t\t&lt;name&gt;jerry&lt;/name&gt;\t\t\t&lt;age&gt;19&lt;/age&gt;\t\t&lt;/student&gt;\t&lt;/students&gt;\t\t\t#3.通过浏览器打开，查看是否编写成功\n\n语法1.xml文件要以.xml为后缀名2.xml文件的第一行要写文档声明        注意：version属性是必须写的    version属性：版本号    encoding属性：告诉浏览器用什么编码方式打开该配置文件\n3.xml文件中有且只能有一个根标签4.xml文件中的标签中的属性要由单引号或者双引号括起来5.xml文件中标签的嵌套\n&lt;aaa&gt;\t&lt;bbb&gt;&lt;/bbb&gt;&lt;/aaa&gt;&lt;aaa&gt;\t&lt;bbb/&gt;&lt;/aaa&gt;\t&lt;aaa&gt;&lt;bbb&gt;&lt;/aaa&gt;&lt;/bbb&gt;\n6.xml文件中的标签名是严格区分大小写的    html：            xml：        \n7.xml文件中的标签名的命名规则：    1.标签名可以由数字，字母和一些字符组成    2.标签名的首字母不能是数字和标点符号    3.标签名中不能有空格\n8.CDATA区域格式：\n\t\t&lt;![CDATA[\t内容]]&gt;\n例子：\n&lt;![CDATA[\t&lt;bbb&gt;约吗&lt;/bbb&gt;\t&lt;ccc&gt;在吗&lt;/ccc&gt;\t&lt;bbb&gt;约吗&lt;/bbb&gt;\t&lt;ccc&gt;在吗&lt;/ccc&gt;\t&lt;bbb&gt;约吗&lt;/bbb&gt;\t&lt;ccc&gt;在吗&lt;/ccc&gt;]]&gt;\n约束约束的分类1.dtd约束    提供dtd约束文档2.schema约束    提供xsd约束文档\n约束区别1.schema约束比dtd约束难2.schema约束比dtd约束好\n推荐使用schema约束\ndtd约束1.创建xml配置文件2.写xml文档声明3.在xml配置文件中引入已经提供好的dtd约束文档4.根据dtd约束文档来写xml配置文件中的标签\n方式一：\t\t\t\t\t\t&lt;!DOCTYPE 根标签 [约束文档的内容]&gt;\t\t\t\t\t\t\t\t\t\t\t\t例子：\t\t\t\t\t\t\t&lt;?xml version=&quot;1.0&quot;?&gt;\t\t\t\t\t\t\t&lt;!DOCTYPE note [\t\t\t\t\t\t\t  &lt;!ELEMENT note (to,from,heading,body)&gt;\t\t\t\t\t\t\t  &lt;!ELEMENT to      (#PCDATA)&gt;\t\t\t\t\t\t\t  &lt;!ELEMENT from    (#PCDATA)&gt;\t\t\t\t\t\t\t  &lt;!ELEMENT heading (#PCDATA)&gt;\t\t\t\t\t\t\t  &lt;!ELEMENT body    (#PCDATA)&gt;\t\t\t\t\t\t\t]&gt;\t\t\t\t\t\t\t&lt;note&gt;\t\t\t\t\t\t\t  &lt;to&gt;George&lt;/to&gt;\t\t\t\t\t\t\t  &lt;from&gt;John&lt;/from&gt;\t\t\t\t\t\t\t  &lt;heading&gt;Reminder&lt;/heading&gt;\t\t\t\t\t\t\t  &lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;\t\t\t\t\t\t\t&lt;/note&gt;\t\t\t\t\t\t\t\t\t\t\t\t方式二：\t\t\t\t\t\t&lt;!DOCTYPE 根标签 SYSTEM &quot;约束文档的文件名&quot;&gt;\t\t\t\t\t\t\t\t\t\t\t\t例子：\t\t\t\t\t\t\t&lt;?xml version=&quot;1.0&quot;?&gt;\t\t\t\t\t\t\t&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;\t\t\t\t\t\t\t&lt;note&gt;\t\t\t\t\t\t\t\t&lt;to&gt;George&lt;/to&gt;\t\t\t\t\t\t\t\t&lt;from&gt;John&lt;/from&gt;\t\t\t\t\t\t\t\t&lt;heading&gt;Reminder&lt;/heading&gt;\t\t\t\t\t\t\t\t&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;\t\t\t\t\t\t\t&lt;/note&gt; \t\t\t\t\t\t\t\t\t\t\t\t方式三：\t\t\t\t\t\t引入网络端的某个约束文档\t\t\t\t\t\t\t\t\t\t\t\t&lt;!DOCTYPE 根标签 PUBLIC &quot;约束文档的文件名&quot; &quot;约束文档的URL&quot;&gt;\nschema约束其实schema约束文档，自身也是一个xml文件1.创建xml配置文件2.写xml文档声明3.在xml配置文件中引入已经提供好的schema约束文档引入步骤：    1.找到根标签    2.引入默认的名称空间        xmlns=”约束文档中targetNamespace的值”    3.关联schema的约束文档        schemaLocation=”默认名称空间的值 + 约束文档的名字”    4.引入schemaLocation的名称空间        xmlns:xsi=”xmlns:xs的值 + -instance”    5.在schemaLocation前面加上xsi:\n4.根据schema约束文档来写xml配置文件中的标签\n","tags":["蜗牛学院笔记","xml"]},{"title":"zut毕设部署保姆级教程","url":"/2022/05/22/zut%E6%AF%95%E8%AE%BE%E9%83%A8%E7%BD%B2%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B/","content":"服务器部署准备连接服务器我的是这样的一个虚拟机\n#终端输入命令连接ssh -Y root@10.36.31.165 #然后输入密码:ieat8\n文件上传到虚拟机上","tags":["zut","毕设"]},{"title":"从pdf中提取内容","url":"/2022/03/02/%E4%BB%8Epdf%E4%B8%AD%E6%8F%90%E5%8F%96%E5%86%85%E5%AE%B9/","content":"使用Fitz正则化代码如下import pdfplumberimport osimport fitzimport reimport timepdf_path=r&#x27;f://1.pdf&#x27;text_path=r&#x27;f://2.txt&#x27;word_path=r&#x27;f://3.docx&#x27;pic_path=r&#x27;f://picture&#x27;#提取文字#文本t0=time.process_time()with pdfplumber.open(pdf_path) as pdf:    for page in pdf.pages:        content=page.extract_text()        with open(text_path,&#x27;a&#x27;,encoding=&#x27;utf-8&#x27;) as text:            text.write(content)t1=time.process_time()print(f&#x27;text提取完成，用时：&#123;t1-t0&#125;&#x27;)#提取图片t0=time.process_time()if not os.path.exists(pic_path):    os.makedirs(pic_path)pdf=fitz.open(pdf_path)ob_num=pdf.xref_length()print(f&#x27;Object数量：&#123;ob_num&#125;&#x27;)#匹配正则表达式checkXO = r&quot;/Type(?= */XObject)&quot;checkIM = r&quot;/Subtype(?= */Image)&quot;imgcount=0for index in range(1,ob_num):    text=pdf.xref_object(index)    isXObject=re.search(checkXO,text)    isImage=re.search(checkIM,text)    if not isXObject or not isImage:        continue    imgcount+=1    #匹配图片    pix=fitz.Pixmap(pdf,index)    pic_name=f&quot;img_&#123;imgcount&#125;.png&quot;    new_name = os.path.join(pic_path, pic_name)    #控制像素，不能过大，否则ValueError: unsupported colorspace for &#x27;png&#x27;    if pix.n&lt;3:        pix.save(new_name)    else:        pix0=fitz.Pixmap(fitz.csRGB,pix)        pix0.save(new_name)        pix0=None    pix=Noneprint(f&#x27;图片数量：&#123;imgcount&#125;&#x27;)t1=time.process_time()print(f&#x27;图片提取完成，用时：&#123;t1-t0&#125;&#x27;)","categories":["python"],"tags":["python","pdf","提取"]},{"title":"使用docker部署redis","url":"/2022/04/21/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2redis/","content":"先拉取redis镜像docker pull redis\n\n创建挂载目录mkdir -p xxx/redis/confmkdir -p xxx/redis/data\n\n构建容器docker run -d -it --name jeecg_redis -p 6379:6379 -v /xxx/redis/conf/redis.conf:/etc/redis/redis.conf -v /xxx/redis/data:/data redis# 注意下redis.conf是个目录，不用提前创建文件\n\n重启容器和redis修改挂载的redis.conf后一定记得重启容器，不能只重启redis服务\ndocker id restart# 进入容器重启redis服务docker exec -it id bashe","tags":["docker","centos/linux","redis"]},{"title":"博客上传报错汇总","url":"/2022/01/02/%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E6%8A%A5%E9%94%99/","content":"hexo d报错原因：问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。\n解决办法：删除.deploy_git文件夹;\n输入git config --global core.autocrlf false\n然后，依次执行：\nhexo cleanhexo ghexo d","categories":["计算机","博客"],"tags":["博客","随笔"]},{"title":"在centos终端下启动应用程序","url":"/2022/04/11/%E5%9C%A8centos%E7%BB%88%E7%AB%AF%E4%B8%8B%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","content":"虚拟机下运行ide好饭好烦，于是我尝试建立软链接在终端直接启动。\n建立软链接ln -s /[可执行文件路径] /usr/bin/[应用程序名]\n\n更新hash表rehash（更新hash表）ls -al /usr/bin|grep pycharm(可以通过此命令来查询hash表是否更新成功)\n\n终端启动","tags":["centos"]},{"title":"图片风格转化实例","url":"/2022/02/09/%E5%9B%BE%E7%89%87%E9%A3%8E%E6%A0%BC%E8%BD%AC%E5%8C%96%E5%AE%9E%E4%BE%8B/","content":"","categories":["机器学习","opencv"],"tags":["机器学习","opencv","图片处理"]},{"title":"opencv图像灰度处理","url":"/2022/01/02/%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86/","content":"灰度处理imread()函数import cv2img0=cv2.imread(&#x27;image0.jpg&#x27;,0)img1=cv2.imread(&#x27;image0.jpg&#x27;,1)print(img0.shape)print(img1.shape)\n\ncvtColor()函数import cv2img=cv2.imread(&#x27;image0.jpg&#x27;,1)dst=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  #颜色空间转换    1 data   2BGR gra\n\nR=G=B=grey 取平均值import cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeheight=imgInfo[0]width=imgInfo[1]#RGB  R=G=B=gray--------------取平均值dst=np.zeros((height,width,3),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r)=img[i,j]        gray=(int(b)+int(g)+int(r))/3             #uint进行相加时容易溢出，所以先取整数再转换回来        dst[i,j]=np.uint8(gray)cv2.imshow(&#x27;dst&#x27;,dst)cv2.waitKey(0)\n\n神奇的心理学公式gray=r0.299+g0.587+b*0.114\nimport cv2import numpy as npimg=cv2.imread(&#x27;image0.jpg&#x27;,1)imgInfo=img.shapeheight=imgInfo[0]width=imgInfo[1]#RGB  R=G=B=gray--------------取平均值dst=np.zeros((height,width,3),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r)=img[i,j]        b=int(b)        g=int(g)        r=int(r)        gray=r*0.299+g*0.587+b*0.114            #uint进行相加时容易溢出，所以先取整数再转换回来        dst[i,j]=np.uint8(gray)\n\n算法优化定点运算&gt;浮点运算&gt;移位运算\n#gray=r*0.299+g*0.587+b*0.114#gray=(r*1+g*2+b*1)/4      #浮点转换为定点运算gray=(r+(g&lt;&lt;1)+b)&gt;&gt;2       #定点运算转换为移位运算\n","categories":["机器学习","opencv"],"tags":["机器学习","opencv","计算机视觉"]},{"title":"在阿里云上创建docker仓库","url":"/2022/04/10/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8A%E5%88%9B%E5%BB%BAdocker%E4%BB%93%E5%BA%93/","content":""},{"title":"多环境配置","url":"/2022/07/11/%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":""},{"title":"对非平衡数据进行处理","url":"/2022/01/30/%E5%AF%B9%E9%9D%9E%E5%B9%B3%E8%A1%A1%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%A2%B3%E7%90%86/","content":"对非平衡数据进行处理详解[https://blog.csdn.net/weixin_43329700/article/details/107325026]\n非平衡数据定义数据比例差距过大，多数类远远大于少数类。比如预测癌症患者模型中，健康比例远大于百分之99，使模型训练机器不精准。\n处理方法from imblearn.combine import SMOTETomekst=SMOTETomek()x_train_st,y_train_st=st.fit_resample(X_train,y_train)print(X_train.shape)print(x_train_st.shape)            #增加了少数类样本\n新增少数类样本SMOTE函数过采样删除不符合要求的多数类样本TOMEK","categories":["机器学习","数据处理"],"tags":["深度学习","机器学习","数据处理","非平衡数据处理"]},{"title":"报错汇总-数据库关键字","url":"/2022/06/04/%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E9%94%AE%E5%AD%97/","content":"今天写mybaits一直显示语法错误，找了半天  测试了半天。最后发现竟是我将order作为一个表名，而order是数据库的一个关键字。所以要加反引号（就是键盘1左边那个）上图报错前修改后\n","tags":["数据库","报错汇总"]},{"title":"归一化与标准化","url":"/2022/01/19/%E5%BD%92%E4%B8%80%E5%8C%96%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96/","content":"数据的归一化与标准化对数据归一化与标准化的理解数据通过标准化处理，对机器学习中很多算法会产生很好的优化效果。如果数据未标准化，在数据集（例如银行统计的个人年收入）中会对算法产生不同影响。\n归一化的目的1.提升模型的收敛速度2.提升模型的精度3.防止模型梯度爆炸\n归一化方法sklearn–minmax_scale()函数官方文档：[https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.minmax_scale.html?highlight=minmax_scale#sklearn.preprocessing.minmax_scale]\n","categories":["机器学习","数据处理"],"tags":["深度学习","机器学习","sklearn","数据处理"]},{"title":"数据库连接池","url":"/2022/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","content":"概念可以存储数据库连接对象的池子，就说了就是一个容器，里面装了几个数据库连接对象连接池：提供了一种池子思想，数据库连接池，线程池…\n作用使用数据库连接池，避免了重复的来回创建Connection对象，然后等着它消亡，然后再用，再重新创建，用完了再消亡。因为数据库连接池提供一个池子，里面已经提前准备好了一些连接对象，如果我们用直接从池子中取，用完再归还即可。节省时间，节约资源。\n自定义数据库连接池public class MySimpleConnectionPool &#123;\tprivate static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;(); \t\tstatic &#123;\t\ttry &#123;\t\t\tfor(int i = 1; i &lt;= 5; i++) &#123;\t\t\t\t//获取数据库连接对象\t\t\t\tConnection conn = JdbcUtils.getConnection();\t\t\t\t//将连接对象放入到pool里\t\t\t\tpool.add(conn);\t\t\t&#125;\t\t&#125; catch(Exception e) &#123;\t\t\tSystem.out.println(&quot;数据库连接池初始化失败~&quot;);\t\t&#125;\t&#125;\t\t\t//2.提供获取数据库连接对象的方法public static synchronized Connection getConnection() &#123;\tif(pool.size() &gt; 0) &#123;\t\treturn pool.removeFirst();\t&#125;\t\tthrow new RuntimeException(&quot;对不起，池子中啥都没有了~&quot;);&#125;//3.提供归还数据库连接对象的方法public static void close(Connection conn) &#123;\tpool.addLast(conn);&#125;\n第三方数据库连接池原理SUN公司提供了一个数据库连接池的接口：DataSource获取数据库连接对象：getConnection()归还数据库连接对象：close()    注意：如果Connection对象是通过DriverManager.getConnection()获取到的话，调用close()就是释源          如果Connection对象是通过数据库连接池获取到的话，调用close()就是归还\nC3P01.使用配置文件的版本：使用步骤：\t1.导入jar包\t\tc3p0-0.9.5.2.jar\t\tmchange-commons-java-0.2.12.jar\t\t2.拷贝配置文件\t\tc3p0-config.xml\t\t3.创建数据库连接池对象\t\tDataSource dataSource = new ComboPooledDataSource();\t\t\t\t\t\t4.获取数据库连接对象\t\tConnection conn = dataSource.getConnection();\t\t\t\t\t\t5.归还数据库连接对象\t\tconn.close();\n2.不使用配置文件的版本：使用步骤：\t1.导入jar包\t\tc3p0-0.9.5.2.jar\t\tmchange-commons-java-0.2.12.jar\t\t\t\t\t\t2.创建数据库连接池对象\t\tComboPooledDataSource dataSource = new ComboPooledDataSource();\t\t\t\t\t\t3.配置各个参数\t\tdataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);\t\tdataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/db6&quot;);\t\tdataSource.setUser(&quot;root&quot;);\t\tdataSource.setPassword(&quot;123&quot;);\t\t\t\t\t\t\t4.获取数据库连接对象\t\tConnection conn = dataSource.getConnection();\t\t\t\t\t\t5.归还数据库连接对象\t\tconn.close();\n\nDruid(德鲁伊)1.使用配置文件的版本：1.导入jar包\tdruid-1.0.9.jar2.拷贝配置文件\tdruid.properties\t\t\t\t\t3.创建数据库连接池对象\tProperties p = new Properties();\tp.load(Demo01.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));\tDataSource dataSource = DruidDataSourceFactory.createDataSource(p);\t\t\t\t\t4.获取数据库连接对象\tConnection conn = dataSource.getConnection();\t\t\t\t\t5.归还数据库连接对象\tconn.close();\n2.不使用配置文件的版本：1.导入jar包\tdruid-1.0.9.jar\t\t\t\t\t2.创建数据库连接池对象\tDruidDataSource dataSource = new DruidDataSource();\t\t\t\t\t\t3.配置参数信息\tdataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);\tdataSource.setUrl(&quot;jdbc:mysql://localhost:3306/db6&quot;);\tdataSource.setUsername(&quot;root&quot;);\tdataSource.setPassword(&quot;123&quot;);\t\t\t\t\t4.获取数据库连接对象\tConnection conn = dataSource.getConnection();\t\t\t\t\t5.归还数据库连接对象\tconn.close();","tags":["蜗牛学院笔记","数据库连接池","C3P0","Druid"]},{"title":"注解要点","url":"/2022/05/19/%E6%B3%A8%E8%A7%A3%E8%A6%81%E7%82%B9/","content":"注解概括注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。\n注解作用注释：用来解释说明的，给程序员看的\n注解：用来解释说明的，给程序看的\n\n1.编写文档：通过代码里标识的注解生成文档【生成文档doc文档】2.代码分析：通过代码里标识的注解对代码进行分析【使用反射】3.编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】注解的书写位置@注解名字public Tools &#123;&#125;------------------@注解名字public Tools &#123;\t@注解名字\tpublic void show() &#123;\t\t&#125;&#125;------------------class Tools &#123;\t@注解名字\tprivate int age;&#125;------------------class Tools &#123;\tpublic void show(@注解名字 int i, @注解名字 int j) &#123;\t\t&#125;&#125;\n\n注解的分类预定义注解人家已经起好名字的注解，人家提供的，我们直接使用的\n   @Override：作用是用来检查方法是否是重写方法@Deprecated：作用是用来标记方法是否已经过时@SuppressWarnings：作用是用来压制警告\t注意：一般都会给参数设置为all，用来压制所有的警告\n自定义注解自己写的注解，自己起的名字\n注解的定义格式元注解\t修饰符 @interface 注解名字 &#123;\t\t\t\t\t&#125;\t\t\t\t例子：\tpublic @interface MyAnno &#123; \t\t\t\t\t\t&#125;\n注解的本质注解的本质就是一个接口，只不过该接口默认继承了Annotation接口\npublic interface MyAnno1 extends java.lang.annotation.Annotation &#123;\t\t\t&#125;\n注解的属性因为接口中有很多抽象方法，在接口中定义的方法就称为抽象方法，在注解中定义的抽象方法就称为属性。数据的数据类型：基本数据类型、String、枚举、注解、以上几种数据类型对应的数组类型\n\tpublic @interface MyAnno &#123;\t\t数据类型 属性名();\t&#125;\t\t\t\t\t举例子：\tpublic @interface MyAnno &#123;\t\tString aaa();\t&#125;属性的使用\t//@MyAnno2(aaa=12)\t//@MyAnno2(bbb=&quot;abc&quot;)\t//@MyAnno2(ccc=MyEnum.M1)\t//@MyAnno2(ddd=@MyAnno1)\t//@MyAnno2(eee=&quot;aaa&quot;)\t//@MyAnno2(eee= &#123;&quot;aaa&quot;&#125;)\t@MyAnno2(eee= &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;)\tclass C &#123;\t\t\t\t\t\t\t&#125;数据类型： public @interface MyAnno2 &#123;\t\tint aaa();\t\tString bbb();\t\tMyEnum ccc();\t\tMyAnno1 ddd();\t\tString[] eee();\t\t\t\t\t\t&#125;\n注解属性需要注意的问题我们在使用注解的时候需要注意哪些问题？    1.如果一个注解中存在多个属性的时候，我们在使用需要给这些属性都要赋值，属性      与属性之间要用逗号隔开    2.我们可以注解中的属性设置默认值(default)，一旦设置了默认值，我们在使用      属性的时候，就不需要给该属性赋值了，当然也可以赋值    3.注解中有一个非常特殊的属性名，叫做value，一旦我们起的属性名字叫做value,      我们在使用注解给该属性赋值的时候，其实是不需要写属性名的，前提条件是该      注解有且只有一个属性\n元注解用来标注注解的注解就称为元注解\n*@Target：约束被该注解所标注的注解的书写范围\tElementType.TYPE：如果设置这个属性值，被标注的注解只能放在类的上面\tElementType.FIELD：如果设置这个属性值，被标注的注解只能放在属性的上面\tElementType.METHOD：如果设置这个属性值，被标注的注解只能放在方法的上面\t\t\t\t\t\t*@Retention：设置被该注解所标注的注解的声明时长\tRetentionPolicy.SOURCE：存活在源文件期间，编译之后就消失了\tRetentionPolicy.CLASS：存活在源文件期间和字节码文件期间，运行之后就消失了\tRetentionPolicy.RUNTIME：存活在源文件期间和字节码文件期间和运行期间\t\t\t\t\t@Documented：被该注解所标注的注解能够存在于帮助文档中@Inherited：被该注解所标注的注解能够被子类继承\n\n注解的解析通过反射技术，来获取注解中的属性的值\n注意：想要对注解进行解析，前提条件@Retention(RetentionPolicy.RUNTIME)\n获取类上面的注解的属性值public class Demo01 &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//使用反射技术获取类上面的注解的属性值：tom,18\t\t\t\t//获取字节码文件对象\t\tClass clazz = Class.forName(&quot;com.annotation.A&quot;);\t\t\t\t//获取类上面的注解对象\t\t//Annotation annotation = clazz.getAnnotation(MyAnno1.class);\t\tMyAnno1 myanno = (MyAnno1)clazz.getAnnotation(MyAnno1.class);\t\t\t\tSystem.out.println(myanno);\t\t\t\t//获取name和age的属性值\t\tString name = myanno.name();\t\tint age = myanno.age();\t\tSystem.out.println(name + &quot;...&quot; + age);\t&#125;&#125;@MyAnno1(name=&quot;tom&quot;, age=18)class A &#123;\t&#125;\n获取方法上面的注解的属性值public class Demo02 &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//获取字节码文件对象\t\tClass clazz = Class.forName(&quot;com.annotation.B&quot;);\t\t\t\t\t\t\t//获取show方法对象\t\tMethod method = clazz.getMethod(&quot;show&quot;);\t\t\t\t\t\t\t//获取方法上的注解对象\t\tMyAnno1 myAnno1 = method.getAnnotation(MyAnno1.class);\t\t\t\t\t\t\t//获取name和age属性值\t\tString name = myAnno1.name();\t\tint age = myAnno1.age();\t\tSystem.out.println(name + &quot;...&quot; + age);\t&#125;&#125;class B &#123;\t@MyAnno1(name=&quot;jerry&quot;,age=19)\tpublic void show() &#123;\t\t\t\t\t\t&#125;&#125;\n\n获取属性上面的注解的属性值public class Demo03 &#123;\tpublic static void main(String[] args) throws Exception &#123;\t\t//获取字节码文件对象\t\tClass clazz = Class.forName(&quot;com.annotation.C&quot;);\t\t\t\t\t\t\t//获取name属性对象\t\tField field = clazz.getDeclaredField(&quot;name&quot;);\t\t\t\t\t\t\t//获取name属性上的注解对象\t\tMyAnno1 myAnno1 = field.getAnnotation(MyAnno1.class);\t\t\t\t\t\t\t//获取name和age属性值\t\tString name = myAnno1.name();\t\tint age = myAnno1.age();\t\tSystem.out.println(name + &quot;...&quot; + age);\t&#125;&#125;class C &#123;\t@MyAnno1(name=&quot;rose&quot;,age=20)\tprivate String name;&#125;","tags":["javaee","蜗牛学院笔记","注解"]},{"title":"网络编程要点","url":"/2022/05/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%A6%81%E7%82%B9/","content":"网络编程概念什么是网络编程通过我们写好的程序，可以实现数据在网络端进行传输。也叫做Socket编程，也叫做套接字编程。\n网络编程三要素    1.IP地址\n    2.端口\n    3.协议\n\nIP地址P地址代表计算机的唯一标识\nIP地址查看？\nipconfigipconfig -all\n测试两台计算机的网络是否互通？\nping IP地址\n\n端口端口号代表应用程序的唯一标识\n所谓的端口，就好像是门牌号一样，客户端可以通过ip地址找到对应的服务器端，但是服务器端是有很多端的，每个应用程序对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。为了对端口进行区分，将每个端口进行了编号，这就是端口号\n端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535\n查看端口号所对应的PID(进程id)？\nnetstat -ano\n\n协议    协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。\n    如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。\n    \n    为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），\n    它最终体现为在网络上传输的数据包的格式\n\n    本篇所讲的协议：TCP UDP\n\nInetAddress类此类表示互联网协议ip地址\n常见的构造方法 ————用不了            \n#\t\t常见的成员方法\t\t\tpublic static InetAddress getByName(String host)：可以通过主机名或者IP地址，\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t获取的是InetAddress对象\t\t\t\t/*\t\t\t\t\tclass InetAddress &#123;\t\t\t\t\t\tprivate InetAddress() &#123;\t\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\tpublic static InetAddress getByName(String name) &#123;\t\t\t\t\t\t\tif(当前的环境是IPV4) &#123;\t\t\t\t\t\t\t\treturn new Ipv4Address();\t\t\t\t\t\t\t&#125; else if(当前的环境是IPV6) &#123;\t\t\t\t\t\t\t\treturn new Ipv6Address();\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tclass Ipv4Address extends InetAddress &#123;\t\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tclass Ipv6Address extends InetAddress &#123;\t\t\t\t\t\t\t\t\t\t&#125;\t\t\t\t\t\t\t\t\t\tclass Demo &#123;\t\t\t\t\t\tmain() &#123;\t\t\t\t\t\t\tInetAddress ia = InetAddress.getByName(&quot;&quot;);\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t*/\t\t\t\t\t\t\tpublic String getHostName()：获取此 IP 地址的主机名\t\t\tpublic String getHostAddress()：返回 IP 地址字符串（以文本表现形式）\n\nUDP协议下的数据的传输####UDP协议的特点        1.面向无连接        2.传输的速度相对较快        3.传输的数据不安全，容易丢失\n发送端1.创建Socket对象DatagramSocket ds = new DatagramSocket();2.产生一个数据String data = &quot;约吗&quot;;3.创建数据报包对象，将数据封装到里面DatagramPacket dp = new DatagramPacket(data.getBytes(), data.getBytes().length, \tInetAddress.getByName(&quot;192.168.8.170&quot;), 10086);4.发送数据报包对象ds.send(dp);5.关闭Socket对象ds.close();\n接收端1.创建Socket对象DatagramSocket ds = new DatagramSocket(10086);2.创建数据报包对象byte[] bys = new byte[1024];DatagramPacket dp = new DatagramPacket(bys, bys.length);3.接收数据报包对象ds.receive(dp);4.解析String ip = dp.getAddress().getHostAddress();String data = new String(dp.getData(), 0, dp.getLength());System.out.println(ip + &quot;...&quot; + data);5.关闭Socket对象ds.close();\nTCP协议下的数据的传输TCP协议的特点    1.面向有连接\n        3次握手(建立连接)：\n            1.发送端 对 接收端 说： 你瞅啥？\n            2.接收端 对 发送端 说： 瞅你咋地？\n            3.发送端 对 接收端 说： 来，咱们聊一聊？\n        \n        4次挥手(断开连接)：\n            1.发送端 对 接收端 说： 我们分手吧！\n            2.接收端 对 发送端 说： 好的，我知道了！\n            3.接收端 对 发送端 说： 你真的要分手吗？不再想一想吗？\n            4.发送端 对 接收端 说： 确定，我百分百要分手！\n    \n    2.传输的速度相对较慢\n    3.传输的数据安全\n\n发送端1.创建Socket对象Socket s = new Socket(&quot;192.168.8.170&quot;, 10086);2.产生一个数据String data = &quot;约吗&quot;;3.获取管道输出流对象OutputStream os = s.getOutputStream();4.写出数据os.write(data.getBytes());5.释放资源s.close();\n接收端    \t\t1.创建Socket对象ServerSocket ss = new ServerSocket(10086);2.监听连接Socket s = ss.accept();3.获取管道输入流对象InputStream is = s.getInputStream();4.读取数据byte[] bys = new byte[1024];int len = is.read(bys);String data = new String(bys, 0, len);System.out.println(data);5.释放资源s.close();ss.close();","tags":["javaee","蜗牛学苑笔记"]},{"title":"虚拟机下解压报错","url":"/2022/04/16/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E8%A7%A3%E5%8E%8B%E6%8A%A5%E9%94%99/","content":"三天，报错了整整三天。后来发现竟然是没完全装上vmtools导致传输文件受损。\n先看官方文档不想解释文档\n坑1点这个里面的安装vmtools然后之前的我天真的以为就结束了，其实并没有。这个vmtools只安装一半，只能实现全屏和复制粘贴功能。往下看\n坑2点那个新弹出来的镜像，找vmtools(本来以为没有，结果自己找了好久)。然后按照文档步骤。\n坑3注意注意注意！！ 最后配置的时候一路按yes/no ，如果是路径的时候摁回车(不要按别的)。\n然后你就能安心的用共享文件夹，但是直接拖屏幕传输还是会有文件损失(不知道怎么解决)\n共享文件夹位置#默认这里cd /mnt/hgfs","tags":["报错","centos/lingux"]},{"title":"记录——学习开源项目book_shop","url":"/2022/04/27/%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEbook-shop/","content":"先运行项目MybatisPlusConfig中发现有报错，有导入的包爆红。登录mybaits官网发现是插件主体过时，将PaginationInterceptor替换为最新的MybatisPlusInterceptor即可。然后发现官网没有及时更新开发文档\n#setUseDeprecatedExecutor已经过时了，所以ConfigurationCustomizer这段应该删掉@Configuration@MapperScan(&quot;scan.your.mapper.package&quot;)public class MybatisPlusConfig &#123;    /**     * 新的分页插件,一缓和二缓遵循mybatis的规则,需要设置 MybatisConfiguration#useDeprecatedExecutor = false 避免缓存出现问题(该属性会在旧插件移除后一同移除)     */    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.Mysql));   #H2修改为Mysql        return interceptor;    &#125;    @Bean    public ConfigurationCustomizer configurationCustomizer() &#123;        return configuration -&gt; configuration.setUseDeprecatedExecutor(false);    &#125;&#125;\n\n\n\n发现项目的依赖有问题根据mybait-plus官网的配置要求spring-boot的项目依赖应该为\n&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;\n可项目采用的依赖是spring项目里的\n&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;    &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt;\n然后我神奇的发现导入最新springboot的项目依赖会一直无法解析，折腾了很久没有办法。采用旧版本\n&lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;\n然后项目就能基本运行了\n大致看下application.yml文件配置如下\n服务器配置\n数据库配置（记得修改成本地）\nmybatis plus配置\n\n项目结构\n实体类entity实体类有Address Book Cart Order User等,如图\n打开Book实体# @Data 相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。# @TableName 表名注解，标识实体类对应的表# @EqualsAndHashCode#1. 此注解会生成equals(Object other) 和 hashCode()方法。#2. 它默认使用非静态，非瞬态的属性#3. 可通过参数exclude排除一些属性#4. 可通过参数of指定仅使用哪些属性#5. 它默认仅使用该类中定义的属性且不调用父类的方法#6. 可通过callSuper=true解决上一点问题。让其生成的方法中调用父类的方法。# @TableId(type = IdType.AUTO)  id自增@Data@TableName(value = &quot;bs_book&quot;)                   @EqualsAndHashCode(callSuper = false)public class Book extends Model&lt;Book&gt; &#123;    @TableId(type = IdType.AUTO)    private Integer id;    private String isbn;    private String name;    private String author;    private String publisher;    private Date publishDate;    private double oldPrice;    private double newPrice;    private String authorLoc;                           private Suit suit;                              #这    private Category category;                      #注意这里两个自定义的类    private String info;    private String imgUrl;&#125;\n\n接口层 mapper业务层 service","tags":["mysql","Javeee","Mybait-plus","maven"]},{"title":"贷款违规行为预测实例","url":"/2022/01/16/%E8%B4%B7%E6%AC%BE%E8%BF%9D%E7%BA%A6%E8%A1%8C%E4%B8%BA%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B/","content":"","categories":["机器学习","数据处理"],"tags":["深度学习","机器学习","sklearn","数据处理"]}]